###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               12/Sep/2018  17:17:19
# Copyright 2004-2018 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation version 10.20
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Components\stack\zdo\ZDSecMgr.c
#    Command line       =  
#        -f C:\Users\ANANDA~1\AppData\Local\Temp\EWD469.tmp ("C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Components\stack\zdo\ZDSecMgr.c"
#        -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
#        LCD_SUPPORTED=DEBUG -lC "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\RouterEB\List"
#        -lA "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\RouterEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\RouterEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\SOURCE\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\"
#        -Ohz --require_prototypes)
#    Locale             =  English_USA.1252
#    List file          =  
#        C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\RouterEB\List\ZDSecMgr.lst
#    Object file        =  
#        C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\RouterEB\Obj\ZDSecMgr.r51
#
###############################################################################

C:\Users\Ananda Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2010-08-20 15:30:00 -0700 (Fri, 20 Aug 2010) $
      4            Revision:       $Revision: 23463 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          // Total number of preconfigured trust center link key
     93          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     94            #define ZDSECMGR_TC_DEVICE_MAX 1
     95          #endif
     96            
     97          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     98            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     99          #endif
    100            
    101          #define ZDSECMGR_CTRL_NONE       0
    102          #define ZDSECMGR_CTRL_INIT       1
    103          #define ZDSECMGR_CTRL_TK_MASTER  2
    104          #define ZDSECMGR_CTRL_SKKE_INIT  3
    105          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    106          #define ZDSECMGR_CTRL_SKKE_DONE  5
    107          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    108          #define ZDSECMGR_CTRL_TK_NWK     7
    109          
    110          #define ZDSECMGR_CTRL_BASE_CNTR      1
    111          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    112          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    113          
    114          // set SKA slot maximum
    115          #define ZDSECMGR_SKA_SLOT_MAX 1
    116          
    117          // APSME Stub Implementations
    118          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    119          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    120          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
    121          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    122          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
    123          
    124          /******************************************************************************
    125           * TYPEDEFS
    126           */
    127          typedef struct
    128          {
    129            uint8 extAddr[Z_EXTADDR_LEN];
    130            uint8 key[SEC_KEY_LEN];
    131          } ZDSecMgrPreConfigData_t;
    132          
    133          typedef struct
    134          {
    135            uint16 ami;
    136            uint8  key[SEC_KEY_LEN];
    137          } ZDSecMgrMasterKeyData_t;
    138          
    139          typedef struct
    140          {
    141            uint16            ami;
    142            uint16            keyNvId;   // index to the Link Key table in NV
    143            ZDSecMgr_Authentication_Option authenticateOption;
    144          } ZDSecMgrEntry_t;
    145          
    146          typedef struct
    147          {
    148            ZDSecMgrEntry_t* entry;
    149            uint16           parentAddr;
    150            uint8            secure;
    151            uint8            state;
    152            uint8            cntr;
    153          } ZDSecMgrCtrl_t;
    154          
    155          typedef struct
    156          {
    157            uint16          nwkAddr;
    158            uint8*          extAddr;
    159            uint16          parentAddr;
    160            uint8           secure;
    161            uint8           devStatus;
    162            ZDSecMgrCtrl_t* ctrl;
    163          } ZDSecMgrDevice_t;
    164          
    165          /******************************************************************************
    166           * LOCAL VARIABLES
    167           */
    168          #if 0 // Taken out because the following functionality is only used for test
    169                // purpose. A more efficient (above) way is used. It can be put
    170                // back in if customers request for a white/black list feature.
    171          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    172          {
    173            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    174            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    175            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    176          };
    177          #endif
    178          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    179          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    180            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    181          
    182          // Key data is put in CONST area for security reasons

   \                                 In  segment CODE_C, align 1
    183          CONST uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171
    184            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    185             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    186          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    187          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    189          
    190          //devtag.pro.security - remove this
    191          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    192          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    193          {
    194            //---------------------------------------------------------------------------
    195            // DEVICE A
    196            //---------------------------------------------------------------------------
    197            {
    198              // extAddr
    199              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    200          
    201              // key
    202              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    203               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    204            },
    205            //---------------------------------------------------------------------------
    206            // DEVICE B
    207            //---------------------------------------------------------------------------
    208            {
    209              // extAddr
    210              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    211          
    212              // key
    213              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    214               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    215            },
    216            //---------------------------------------------------------------------------
    217            // DEVICE C
    218            //---------------------------------------------------------------------------
    219            {
    220              // extAddr
    221              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    222          
    223              // key
    224              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    225               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    226            },
    227          };
    228          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    229          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    230          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    231          ZDSecMgrCtrl_t*  ZDSecMgrCtrlData = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    232          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    233          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    234          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    235          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    236          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    237          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    238          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    239          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    240          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS 27
   \   00001B                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    241          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z
    242          
    243          /******************************************************************************
    244           * PRIVATE FUNCTIONS
    245           *
    246           *   ZDSecMgrMasterKeyInit
    247           *   ZDSecMgrAddrStore
    248           *   ZDSecMgrExtAddrStore
    249           *   ZDSecMgrExtAddrLookup
    250           *   ZDSecMgrMasterKeyLookup
    251           *   ZDSecMgrMasterKeyStore
    252           *   ZDSecMgrEntryInit
    253           *   ZDSecMgrEntryLookup
    254           *   ZDSecMgrEntryLookupAMI
    255           *   ZDSecMgrEntryLookupExt
    256           *   ZDSecMgrEntryLookupExtGetIndex
    257           *   ZDSecMgrEntryFree
    258           *   ZDSecMgrEntryNew
    259           *   ZDSecMgrCtrlInit
    260           *   ZDSecMgrCtrlRelease
    261           *   ZDSecMgrCtrlLookup
    262           *   ZDSecMgrCtrlSet
    263           *   ZDSecMgrCtrlAdd
    264           *   ZDSecMgrCtrlTerm
    265           *   ZDSecMgrCtrlReset
    266           *   ZDSecMgrMasterKeyLoad
    267           *   ZDSecMgrAppKeyGet
    268           *   ZDSecMgrAppKeyReq
    269           *   ZDSecMgrEstablishKey
    270           *   ZDSecMgrSendMasterKey
    271           *   ZDSecMgrSendNwkKey
    272           *   ZDSecMgrDeviceEntryRemove
    273           *   ZDSecMgrDeviceEntryAdd
    274           *   ZDSecMgrDeviceCtrlHandler
    275           *   ZDSecMgrDeviceCtrlSetup
    276           *   ZDSecMgrDeviceCtrlUpdate
    277           *   ZDSecMgrDeviceRemove
    278           *   ZDSecMgrDeviceValidateSKKE
    279           *   ZDSecMgrDeviceValidateRM
    280           *   ZDSecMgrDeviceValidateCM
    281           *   ZDSecMgrDeviceValidate
    282           *   ZDSecMgrDeviceJoin
    283           *   ZDSecMgrDeviceJoinDirect
    284           *   ZDSecMgrDeviceJoinFwd
    285           *   ZDSecMgrDeviceNew
    286           *   ZDSecMgrAssocDeviceAuth
    287           *   ZDSecMgrAuthInitiate
    288           *   ZDSecMgrAuthNwkKey
    289           *   APSME_TCLinkKeyInit
    290           *   APSME_IsDefaultTCLK
    291           */
    292          //-----------------------------------------------------------------------------
    293          // master key data
    294          //-----------------------------------------------------------------------------
    295          void ZDSecMgrMasterKeyInit( void );
    296          
    297          //-----------------------------------------------------------------------------
    298          // address management
    299          //-----------------------------------------------------------------------------
    300          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    301          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    302          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    303          
    304          //-----------------------------------------------------------------------------
    305          // MASTER key data
    306          //-----------------------------------------------------------------------------
    307          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId );
    308          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    309          
    310          //-----------------------------------------------------------------------------
    311          // entry data
    312          //-----------------------------------------------------------------------------
    313          void ZDSecMgrEntryInit(uint8 state);
    314          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    315          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    316          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    318          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    319          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    320          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    321          void ZDSecMgrApsLinkKeyInit(void);
    322          #if defined NV_RESTORE
    323          static void ZDSecMgrWriteNV(void);
    324          static void ZDSecMgrRestoreFromNV(void);
    325          #endif
    326          
    327          //-----------------------------------------------------------------------------
    328          // control data
    329          //-----------------------------------------------------------------------------
    330          void ZDSecMgrCtrlInit( void );
    331          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    332          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    333          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    334                                ZDSecMgrEntry_t*  entry,
    335                                ZDSecMgrCtrl_t*   ctrl );
    336          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    337          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    338          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    339                                       ZDSecMgrEntry_t*  entry );
    340          
    341          //-----------------------------------------------------------------------------
    342          // key support
    343          //-----------------------------------------------------------------------------
    344          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    345          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    346                                       uint8*  initExtAddr,
    347                                       uint16  partNwkAddr,
    348                                       uint8*  partExtAddr,
    349                                       uint8** key,
    350                                       uint8*  keyType );
    351          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    352          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    353          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    354          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    355          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    356          
    357          //-----------------------------------------------------------------------------
    358          // device entry
    359          //-----------------------------------------------------------------------------
    360          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    361          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    362          
    363          //-----------------------------------------------------------------------------
    364          // device control
    365          //-----------------------------------------------------------------------------
    366          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    367          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    368          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    369          
    370          //-----------------------------------------------------------------------------
    371          // device management
    372          //-----------------------------------------------------------------------------
    373          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    374          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    375          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    376          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    377          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    378          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    379          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    382          
    383          //-----------------------------------------------------------------------------
    384          // association management
    385          //-----------------------------------------------------------------------------
    386          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    387          
    388          //-----------------------------------------------------------------------------
    389          // authentication management
    390          //-----------------------------------------------------------------------------
    391          void ZDSecMgrAuthInitiate( uint8* responder );
    392          void ZDSecMgrAuthNwkKey( void );
    393          
    394          //-----------------------------------------------------------------------------
    395          // APSME function
    396          //-----------------------------------------------------------------------------
    397          void APSME_TCLinkKeyInit( uint8 setDefault );
    398          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    399          
    400          /******************************************************************************
    401           * @fn          ZDSecMgrMasterKeyInit                     ]
    402           *
    403           * @brief       Initialize master key data in NV
    404           *
    405           * @param       none
    406           *
    407           * @return      none
    408           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    409          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    410          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    411            uint16 index;
    412            ZDSecMgrMasterKeyData_t   masterKeyData;
    413          
    414            masterKeyData.ami = INVALID_NODE_ADDR;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   74FE         MOV       A,#-0x2
   \   000012   F0           MOVX      @DPTR,A
   \   000013   A3           INC       DPTR
   \   000014   04           INC       A
   \   000015   F0           MOVX      @DPTR,A
    415          
    416            osal_memset( &masterKeyData.key, 0x00, SEC_KEY_LEN );
   \   000016                ; Setup parameters for call to function osal_memset
   \   000016   7C10         MOV       R4,#0x10
   \   000018   7D00         MOV       R5,#0x0
   \   00001A   7900         MOV       R1,#0x0
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   AA82         MOV       R2,DPL
   \   000023   AB83         MOV       R3,DPH
   \   000025   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    417          
    418            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   000028   75..00       MOV       ?V0,#0x0
   \   00002B   75..00       MOV       ?V1,#0x0
    419            {
    420              if ( osal_nv_item_init( (ZCD_NV_MASTER_KEY_DATA_START + index), 
    421                                 sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData) == SUCCESS)
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   00002E   12....       LCALL     ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000031   88..         MOV       ?V2,R0
   \   000033   89..         MOV       ?V3,R1
   \   000035   78..         MOV       R0,#?V2
   \   000037   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003A   7C12         MOV       R4,#0x12
   \   00003C   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   00003F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000042   E9           MOV       A,R1
   \   000043   7016         JNZ       ??ZDSecMgrMasterKeyInit_1
    422              {
    423                // the item already exists in NV just needs to be set to default values
    424                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    425                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   000045                ; Setup parameters for call to function osal_nv_write
   \   000045   78..         MOV       R0,#?V2
   \   000047   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004A   75..12       MOV       ?V2,#0x12
   \   00004D   75..00       MOV       ?V3,#0x0
   \   000050   78..         MOV       R0,#?V2
   \   000052   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000055   12....       LCALL     ?Subroutine35 & 0xFFFF
    426              }
    427            }
   \                     ??CrossCallReturnLabel_269:
   \   000058   12....       LCALL     ?DEALLOC_XSTACK8
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   00005B   05..         INC       ?V0
   \   00005D   EE           MOV       A,R6
   \   00005E   7002         JNZ       ??ZDSecMgrMasterKeyInit_2
   \   000060   05..         INC       ?V1
   \                     ??ZDSecMgrMasterKeyInit_2:
   \   000062   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000065   40C7         JC        ??ZDSecMgrMasterKeyInit_0
    428          }
   \   000067   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   7D00         MOV       R5,#0x0
   \   000002   EE           MOV       A,R6
   \   000003   FA           MOV       R2,A
   \   000004   EF           MOV       A,R7
   \   000005   FB           MOV       R3,A
   \   000006                REQUIRE ??Subroutine88_0
   \   000006                ; // Fall through to label ??Subroutine88_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine88_0:
   \   000000   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   C3           CLR       C
   \   000001   9403         SUBB      A,#0x3
   \   000003   E5..         MOV       A,?V1
   \   000005   9400         SUBB      A,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   E5..         MOV       A,?V0
   \   000002   2401         ADD       A,#0x1
   \   000004   FE           MOV       R6,A
   \   000005   E5..         MOV       A,?V1
   \   000007   3403         ADDC      A,#0x3
   \   000009   FF           MOV       R7,A
   \   00000A                ; Setup parameters for call to function osal_nv_item_init
   \   00000A                ; Setup parameters for call to function osal_nv_read
   \   00000A                ; Setup parameters for call to function osal_nv_read
   \   00000A   A8..         MOV       R0,?XSP + 0
   \   00000C   A9..         MOV       R1,?XSP + 1
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7412         MOV       A,#0x12
   \   000002                REQUIRE ??Subroutine109_0
   \   000002                ; // Fall through to label ??Subroutine109_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine110_0
   \   000003                ; // Fall through to label ??Subroutine110_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   7C00         MOV       R4,#0x0
   \   000002   7D00         MOV       R5,#0x0
   \   000004   EE           MOV       A,R6
   \   000005   FA           MOV       R2,A
   \   000006   EF           MOV       A,R7
   \   000007                REQUIRE ??Subroutine123_0
   \   000007                ; // Fall through to label ??Subroutine123_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine123_0:
   \   000000   FB           MOV       R3,A
   \   000001                REQUIRE ??Subroutine124_0
   \   000001                ; // Fall through to label ??Subroutine124_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine124_0:
   \   000000   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000003   7404         MOV       A,#0x4
   \   000005   22           RET
    429          
    430          /******************************************************************************
    431           * @fn          ZDSecMgrAddrStore
    432           *
    433           * @brief       Store device addresses.
    434           *
    435           * @param       nwkAddr - [in] NWK address
    436           * @param       extAddr - [in] EXT address
    437           * @param       ami     - [out] Address Manager index
    438           *
    439           * @return      ZStatus_t
    440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    442          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    443            ZStatus_t      status;
    444            AddrMgrEntry_t entry;
    445          
    446          
    447            // add entry
    448            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   7402         MOV       A,#0x2
   \   000012   F0           MOVX      @DPTR,A
    449            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC       A
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   12....       LCALL     ?Subroutine24 & 0xFFFF
    450            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_25:
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   AA82         MOV       R2,DPL
   \   00001F   AB83         MOV       R3,DPH
   \   000021   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000024   7416         MOV       A,#0x16
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   12....       LCALL     ?Subroutine48 & 0xFFFF
    451          
    452            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_49:
   \   00002C   700A         JNZ       ??ZDSecMgrAddrStore_0
    453            {
    454              // return successful results
    455              *ami   = entry.index;
   \   00002E   740B         MOV       A,#0xb
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   12....       LCALL     ?Subroutine17 & 0xFFFF
    456              status = ZSuccess;
    457            }
   \                     ??CrossCallReturnLabel_119:
   \   000036   8008         SJMP      ??CrossCallReturnLabel_28
    458            else
    459            {
    460              // return failed results
    461              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   000038   740B         MOV       A,#0xb
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   12....       LCALL     ?Subroutine25 & 0xFFFF
    462              status = ZNwkUnknownDevice;
    463            }
    464          
    465            return status;
   \                     ??CrossCallReturnLabel_28:
   \   000040   02....       LJMP      ?Subroutine7 & 0xFFFF
    466          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FE           MOV       R6,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FF           MOV       R7,A
   \   000005                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000005                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000005   12....       LCALL     ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   AA..         MOV       R2,?XSP + 0
   \   000002   AB..         MOV       R3,?XSP + 1
   \   000004                REQUIRE ??Subroutine89_0
   \   000004                ; // Fall through to label ??Subroutine89_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine89_0:
   \   000000   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000003   E9           MOV       A,R1
   \   000004   6401         XRL       A,#0x1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL     ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000003   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000006   79C8         MOV       R1,#-0x38
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000005   7403         MOV       A,#0x3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL     ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000003                REQUIRE ??Subroutine90_0
   \   000003                ; // Fall through to label ??Subroutine90_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine90_0:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000003   7900         MOV       R1,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL     ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000003   F9           MOV       R1,A
   \   000004   8E82         MOV       DPL,R6
   \   000006   8F83         MOV       DPH,R7
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   740D         MOV       A,#0xd
   \   000002   02....       LJMP      ??Subroutine100_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine100_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine101_0
   \   000003                ; // Fall through to label ??Subroutine101_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine101_0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET
    467          
    468          /******************************************************************************
    469           * @fn          ZDSecMgrExtAddrStore
    470           *
    471           * @brief       Store EXT address.
    472           *
    473           * @param       extAddr - [in] EXT address
    474           * @param       ami     - [out] Address Manager index
    475           *
    476           * @return      ZStatus_t
    477           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    478          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    479          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    480            ZStatus_t      status;
    481            AddrMgrEntry_t entry;
    482          
    483          
    484            // add entry
    485            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   7402         MOV       A,#0x2
   \   000012   F0           MOVX      @DPTR,A
    486            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC       A
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   12....       LCALL     ?Subroutine24 & 0xFFFF
    487            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_26:
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   AA82         MOV       R2,DPL
   \   00001F   AB83         MOV       R3,DPH
   \   000021   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000024   7416         MOV       A,#0x16
   \   000026   12....       LCALL     ?XSTACK_DISP0_8
   \   000029   12....       LCALL     ?Subroutine48 & 0xFFFF
    488          
    489            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_50:
   \   00002C   700A         JNZ       ??ZDSecMgrExtAddrStore_0
    490            {
    491              // return successful results
    492              *ami   = entry.index;
   \   00002E   740B         MOV       A,#0xb
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   12....       LCALL     ?Subroutine17 & 0xFFFF
    493              status = ZSuccess;
    494            }
   \                     ??CrossCallReturnLabel_120:
   \   000036   8008         SJMP      ??CrossCallReturnLabel_29
    495            else
    496            {
    497              // return failed results
    498              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   000038   740B         MOV       A,#0xb
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   12....       LCALL     ?Subroutine25 & 0xFFFF
    499              status = ZNwkUnknownDevice;
    500            }
    501          
    502            return status;
   \                     ??CrossCallReturnLabel_29:
   \   000040   80..         SJMP      ?Subroutine7
    503          }
    504          
    505          /******************************************************************************
    506           * @fn          ZDSecMgrExtAddrLookup
    507           *
    508           * @brief       Lookup index for specified EXT address.
    509           *
    510           * @param       extAddr - [in] EXT address
    511           * @param       ami     - [out] Address Manager index
    512           *
    513           * @return      ZStatus_t
    514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    515          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    516          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    517            ZStatus_t      status;
    518            AddrMgrEntry_t entry;
    519          
    520          
    521            // lookup entry
    522            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7402         MOV       A,#0x2
   \   000016   F0           MOVX      @DPTR,A
    523            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV       A,R2
   \   000018   FC           MOV       R4,A
   \   000019   EB           MOV       A,R3
   \   00001A   FD           MOV       R5,A
   \   00001B   7403         MOV       A,#0x3
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   AA82         MOV       R2,DPL
   \   000022   AB83         MOV       R3,DPH
   \   000024   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    524          
    525            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000027                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000027   AA..         MOV       R2,?XSP + 0
   \   000029   AB..         MOV       R3,?XSP + 1
   \   00002B   12....       LCALL     `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00002E   E9           MOV       A,R1
   \   00002F   6401         XRL       A,#0x1
   \   000031   700A         JNZ       ??ZDSecMgrExtAddrLookup_0
    526            {
    527              // return successful results
    528              *ami   = entry.index;
   \   000033   740B         MOV       A,#0xb
   \   000035   12....       LCALL     ?XSTACK_DISP0_8
   \   000038   12....       LCALL     ?Subroutine17 & 0xFFFF
    529              status = ZSuccess;
    530            }
   \                     ??CrossCallReturnLabel_121:
   \   00003B   8008         SJMP      ??CrossCallReturnLabel_30
    531            else
    532            {
    533              // return failed results
    534              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   00003D   740B         MOV       A,#0xb
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine25 & 0xFFFF
    535              status = ZNwkUnknownDevice;
    536            }
    537          
    538            return status;
   \                     ??CrossCallReturnLabel_30:
   \   000045                REQUIRE ?Subroutine7
   \   000045                ; // Fall through to label ?Subroutine7
    539          }
    540          
    541          /******************************************************************************
    542           * @fn          ZDSecMgrMasterKeyLookup
    543           *
    544           * @brief       Lookup MASTER key for specified address index.
    545           *
    546           * @param       ami - [in] Address Manager index
    547           * @param       pKeyNvId - [out] MASTER key NV ID
    548           *
    549           * @return      ZStatus_t
    550           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    551          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId )
   \                     ZDSecMgrMasterKeyLookup:
    552          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V6,R2
   \   00000C   8B..         MOV       ?V7,R3
   \   00000E   8C..         MOV       ?V2,R4
   \   000010   8D..         MOV       ?V3,R5
    553            uint16 index;
    554            ZDSecMgrMasterKeyData_t masterKeyData;
    555          
    556            
    557            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   75..00       MOV       ?V0,#0x0
   \   000015   75..00       MOV       ?V1,#0x0
    558            {  
    559              // Read entry index of the Master key table from NV
    560              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    561                            sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000018   12....       LCALL     ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   00001B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001E   75..12       MOV       ?V4,#0x12
   \   000021   75..00       MOV       ?V5,#0x0
   \   000024   78..         MOV       R0,#?V4
   \   000026   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000029   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   00002C   12....       LCALL     ?DEALLOC_XSTACK8
    562              
    563              if ( masterKeyData.ami == ami )
   \   00002F   85..82       MOV       DPL,?XSP + 0
   \   000032   85..83       MOV       DPH,?XSP + 1
   \   000035   E0           MOVX      A,@DPTR
   \   000036   65..         XRL       A,?V6
   \   000038   7004         JNZ       ??ZDSecMgrMasterKeyLookup_1
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   65..         XRL       A,?V7
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   00003E   701C         JNZ       ??ZDSecMgrMasterKeyLookup_2
    564              {
    565                // return successful results
    566                *pKeyNvId   = ZCD_NV_MASTER_KEY_DATA_START + index;
   \   000040   85..82       MOV       DPL,?V2
   \   000043   85..83       MOV       DPH,?V3
   \   000046   EE           MOV       A,R6
   \   000047   F0           MOVX      @DPTR,A
   \   000048   A3           INC       DPTR
   \   000049   EF           MOV       A,R7
   \   00004A   F0           MOVX      @DPTR,A
    567                
    568                // clear copy of key in RAM
    569                osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   00004B                ; Setup parameters for call to function osal_memset
   \   00004B   7C12         MOV       R4,#0x12
   \   00004D   7D00         MOV       R5,#0x0
   \   00004F   7900         MOV       R1,#0x0
   \   000051   AA..         MOV       R2,?XSP + 0
   \   000053   AB..         MOV       R3,?XSP + 1
   \   000055   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    570                
    571                return ZSuccess;
   \   000058   7900         MOV       R1,#0x0
   \   00005A   8023         SJMP      ??ZDSecMgrMasterKeyLookup_3
    572              }
    573            }
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   00005C   05..         INC       ?V0
   \   00005E   EE           MOV       A,R6
   \   00005F   7002         JNZ       ??ZDSecMgrMasterKeyLookup_4
   \   000061   05..         INC       ?V1
   \                     ??ZDSecMgrMasterKeyLookup_4:
   \   000063   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000066   40B0         JC        ??ZDSecMgrMasterKeyLookup_0
    574            
    575            *pKeyNvId = SEC_NO_KEY_NV_ID;
   \   000068   85..82       MOV       DPL,?V2
   \   00006B   85..83       MOV       DPH,?V3
   \   00006E   E4           CLR       A
   \   00006F   F0           MOVX      @DPTR,A
   \   000070   A3           INC       DPTR
   \   000071   F0           MOVX      @DPTR,A
    576          
    577            // clear copy of key in RAM
    578            osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   000072                ; Setup parameters for call to function osal_memset
   \   000072   7C12         MOV       R4,#0x12
   \   000074   FD           MOV       R5,A
   \   000075   F9           MOV       R1,A
   \   000076   AA..         MOV       R2,?XSP + 0
   \   000078   AB..         MOV       R3,?XSP + 1
   \   00007A   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    579          
    580            return ZNwkUnknownDevice;
   \   00007D   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   00007F   02....       LJMP      ?Subroutine2 & 0xFFFF
    581          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   7C00         MOV       R4,#0x0
   \   000002   7D00         MOV       R5,#0x0
   \   000004   EE           MOV       A,R6
   \   000005   FA           MOV       R2,A
   \   000006   EF           MOV       A,R7
   \   000007   FB           MOV       R3,A
   \   000008                REQUIRE ??Subroutine91_0
   \   000008                ; // Fall through to label ??Subroutine91_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine91_0:
   \   000000   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000003   7404         MOV       A,#0x4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL     ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000003   88..         MOV       ?V4,R0
   \   000005   89..         MOV       ?V5,R1
   \   000007   78..         MOV       R0,#?V4
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7412         MOV       A,#0x12
   \   000002                REQUIRE ??Subroutine130_0
   \   000002                ; // Fall through to label ??Subroutine130_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine130_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine131_0
   \   000003                ; // Fall through to label ??Subroutine131_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine131_0:
   \   000000   7F08         MOV       R7,#0x8
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    582          
    583          /******************************************************************************
    584           * @fn          ZDSecMgrMasterKeyStore
    585           *
    586           * @brief       Store MASTER key for specified address index.
    587           *
    588           * @param       ami - [in] Address Manager index
    589           * @param       key - [in] valid key to store
    590           *
    591           * @return      ZStatus_t
    592           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    593          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    594          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V6,R2
   \   00000C   8B..         MOV       ?V7,R3
   \   00000E   8C..         MOV       ?V2,R4
   \   000010   8D..         MOV       ?V3,R5
    595            uint16    index;
    596            ZDSecMgrMasterKeyData_t   masterKeyData;
    597            
    598          
    599            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   75..00       MOV       ?V0,#0x0
   \   000015   75..00       MOV       ?V1,#0x0
    600            {
    601              // Read entry index of the Master key table from NV
    602              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    603                             sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000018   12....       LCALL     ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   00001B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001E   75..12       MOV       ?V4,#0x12
   \   000021   75..00       MOV       ?V5,#0x0
   \   000024   78..         MOV       R0,#?V4
   \   000026   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000029   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   00002C   12....       LCALL     ?DEALLOC_XSTACK8
    604          
    605              if ( masterKeyData.ami == INVALID_NODE_ADDR )
   \   00002F   85..82       MOV       DPL,?XSP + 0
   \   000032   85..83       MOV       DPH,?XSP + 1
   \   000035   E0           MOVX      A,@DPTR
   \   000036   64FE         XRL       A,#0xfe
   \   000038   7003         JNZ       ??ZDSecMgrMasterKeyStore_1
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   F4           CPL       A
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   00003D   7073         JNZ       ??ZDSecMgrMasterKeyStore_2
    606              {
    607                // store EXT address index
    608                masterKeyData.ami = ami;
   \   00003F   85..82       MOV       DPL,?XSP + 0
   \   000042   85..83       MOV       DPH,?XSP + 1
   \   000045   E5..         MOV       A,?V6
   \   000047   F0           MOVX      @DPTR,A
   \   000048   A3           INC       DPTR
   \   000049   E5..         MOV       A,?V7
   \   00004B   F0           MOVX      @DPTR,A
    609          
    610                if ( key != NULL )
   \   00004C   E5..         MOV       A,?V2
   \   00004E   45..         ORL       A,?V3
   \   000050   601F         JZ        ??ZDSecMgrMasterKeyStore_3
    611                {
    612                  osal_memcpy( masterKeyData.key, key,  SEC_KEY_LEN );
   \   000052                ; Setup parameters for call to function osal_memcpy
   \   000052   85....       MOV       ?V0,?V2
   \   000055   85....       MOV       ?V1,?V3
   \   000058   75..00       MOV       ?V2,#0x0
   \   00005B   78..         MOV       R0,#?V0
   \   00005D   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000060   7C10         MOV       R4,#0x10
   \   000062   7D00         MOV       R5,#0x0
   \   000064   7405         MOV       A,#0x5
   \   000066   12....       LCALL     ?XSTACK_DISP0_8
   \   000069   12....       LCALL     ?Subroutine67 & 0xFFFF
    613                }
   \                     ??CrossCallReturnLabel_261:
   \   00006C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006F   8012         SJMP      ??ZDSecMgrMasterKeyStore_4
    614                else
    615                {
    616                  osal_memset( masterKeyData.key, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   000071                ; Setup parameters for call to function osal_memset
   \   000071   7C10         MOV       R4,#0x10
   \   000073   7D00         MOV       R5,#0x0
   \   000075   7900         MOV       R1,#0x0
   \   000077   7402         MOV       A,#0x2
   \   000079   12....       LCALL     ?XSTACK_DISP0_8
   \   00007C   AA82         MOV       R2,DPL
   \   00007E   AB83         MOV       R3,DPH
   \   000080   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    617                }
    618          
    619                // set new values in NV      
    620                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    621                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   000083                ; Setup parameters for call to function osal_nv_write
   \   000083   A8..         MOV       R0,?XSP + 0
   \   000085   A9..         MOV       R1,?XSP + 1
   \   000087   88..         MOV       ?V0,R0
   \   000089   89..         MOV       ?V1,R1
   \   00008B   78..         MOV       R0,#?V0
   \   00008D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000090   75..12       MOV       ?V0,#0x12
   \   000093   75..00       MOV       ?V1,#0x0
   \   000096   78..         MOV       R0,#?V0
   \   000098   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00009B   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   00009E   12....       LCALL     ?DEALLOC_XSTACK8
    622                 
    623                // clear copy of key in RAM
    624                osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   0000A1                ; Setup parameters for call to function osal_memset
   \   0000A1   7C12         MOV       R4,#0x12
   \   0000A3   7D00         MOV       R5,#0x0
   \   0000A5   7900         MOV       R1,#0x0
   \   0000A7   AA..         MOV       R2,?XSP + 0
   \   0000A9   AB..         MOV       R3,?XSP + 1
   \   0000AB   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    625          
    626                // return successful results
    627                return ZSuccess;
   \   0000AE   7900         MOV       R1,#0x0
   \   0000B0   801E         SJMP      ??ZDSecMgrMasterKeyStore_5
    628              }
    629            }
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   0000B2   05..         INC       ?V0
   \   0000B4   EE           MOV       A,R6
   \   0000B5   7002         JNZ       ??ZDSecMgrMasterKeyStore_6
   \   0000B7   05..         INC       ?V1
   \                     ??ZDSecMgrMasterKeyStore_6:
   \   0000B9   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   0000BC   5003         JNC       $+5
   \   0000BE   02....       LJMP      ??ZDSecMgrMasterKeyStore_0 & 0xFFFF
    630            
    631            // clear copy of key in RAM
    632            osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   0000C1                ; Setup parameters for call to function osal_memset
   \   0000C1   7C12         MOV       R4,#0x12
   \   0000C3   7D00         MOV       R5,#0x0
   \   0000C5   7900         MOV       R1,#0x0
   \   0000C7   AA..         MOV       R2,?XSP + 0
   \   0000C9   AB..         MOV       R3,?XSP + 1
   \   0000CB   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    633            
    634            return ZNwkUnknownDevice;
   \   0000CE   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   0000D0   02....       LJMP      ?Subroutine2 & 0xFFFF
    635          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   AA82         MOV       R2,DPL
   \   000002   AB83         MOV       R3,DPH
   \   000004                REQUIRE ??Subroutine121_0
   \   000004                ; // Fall through to label ??Subroutine121_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine121_0:
   \   000000   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000003   7403         MOV       A,#0x3
   \   000005   22           RET
    636          
    637          /******************************************************************************
    638           * @fn          ZDSecMgrEntryInit
    639           *
    640           * @brief       Initialize entry sub module
    641           *
    642           * @param       state - device initialization state
    643           *
    644           * @return      none
    645           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    646          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    647          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    648            if (ZDSecMgrEntries == NULL)
   \   000004   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000007   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   00000A   7033         JNZ       ??ZDSecMgrEntryInit_0
    649            {
    650              uint16 index;
    651          
    652              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   00000C                ; Setup parameters for call to function osal_mem_alloc
   \   00000C   7A0F         MOV       R2,#0xf
   \   00000E   7B00         MOV       R3,#0x0
   \   000010   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000013   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000016   12....       LCALL     ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000019   F9           MOV       R1,A
   \   00001A   EA           MOV       A,R2
   \   00001B   49           ORL       A,R1
   \   00001C   6021         JZ        ??ZDSecMgrEntryInit_0
    653              {
    654                return;
    655              }
    656          
    657              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   00001E   7800         MOV       R0,#0x0
   \   000020   7900         MOV       R1,#0x0
    658              {
    659                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_1:
   \   000022   12....       LCALL     ?Subroutine66 & 0xFFFF
    660                
    661                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
    662              }
   \                     ??CrossCallReturnLabel_77:
   \   000025   8A82         MOV       DPL,R2
   \   000027   F583         MOV       DPH,A
   \   000029   74FE         MOV       A,#-0x2
   \   00002B   F0           MOVX      @DPTR,A
   \   00002C   A3           INC       DPTR
   \   00002D   04           INC       A
   \   00002E   12....       LCALL     ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000031   E4           CLR       A
   \   000032   F0           MOVX      @DPTR,A
   \   000033   A3           INC       DPTR
   \   000034   F0           MOVX      @DPTR,A
   \   000035   08           INC       R0
   \   000036   E8           MOV       A,R0
   \   000037   7001         JNZ       ??ZDSecMgrEntryInit_2
   \   000039   09           INC       R1
   \                     ??ZDSecMgrEntryInit_2:
   \   00003A   12....       LCALL     ?Subroutine36 & 0xFFFF
    663            }
   \                     ??CrossCallReturnLabel_133:
   \   00003D   40E3         JC        ??ZDSecMgrEntryInit_1
    664          
    665          #if defined NV_RESTORE
    666            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    667            {
    668              ZDSecMgrRestoreFromNV();
    669            }
    670          #else
    671            (void)state;
    672          #endif
    673          }
   \                     ??ZDSecMgrEntryInit_0:
   \   00003F   02....       LJMP      ??Subroutine105_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   E8           MOV       A,R0
   \   000001   FA           MOV       R2,A
   \   000002   E9           MOV       A,R1
   \   000003   FB           MOV       R3,A
   \   000004   EA           MOV       A,R2
   \   000005   75F005       MOV       B,#0x5
   \   000008   A4           MUL       AB
   \   000009   FA           MOV       R2,A
   \   00000A   ACF0         MOV       R4,B
   \   00000C   75F005       MOV       B,#0x5
   \   00000F   EB           MOV       A,R3
   \   000010   A4           MUL       AB
   \   000011   2C           ADD       A,R4
   \   000012   FB           MOV       R3,A
   \   000013   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000016   E0           MOVX      A,@DPTR
   \   000017   2A           ADD       A,R2
   \   000018   FA           MOV       R2,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   3B           ADDC      A,R3
   \   00001C   FB           MOV       R3,A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   C3           CLR       C
   \   000001                REQUIRE ??Subroutine92_0
   \   000001                ; // Fall through to label ??Subroutine92_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine92_0:
   \   000000   9403         SUBB      A,#0x3
   \   000002   E9           MOV       A,R1
   \   000003   9400         SUBB      A,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000   12....       LCALL     ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000003   E8           MOV       A,R0
   \   000004   49           ORL       A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine118_0:
   \   000000   12....       LCALL     ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000003   F9           MOV       R1,A
   \   000004   22           RET
    674          
    675          /******************************************************************************
    676           * @fn          ZDSecMgrEntryLookup
    677           *
    678           * @brief       Lookup entry index using specified NWK address.
    679           *
    680           * @param       nwkAddr - [in] NWK address
    681           * @param       entry   - [out] valid entry
    682           *
    683           * @return      ZStatus_t
    684           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    685          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    686          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    687            ZStatus_t      status;
    688            uint16         index;
    689            AddrMgrEntry_t addrMgrEntry;
    690          
    691          
    692            // initialize results
    693            *entry = NULL;
   \   00000E   8C82         MOV       DPL,R4
   \   000010   F583         MOV       DPH,A
   \   000012   12....       LCALL     ?Subroutine16 & 0xFFFF
    694            status = ZNwkUnknownDevice;
    695          
    696            // verify data is available
    697            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_9:
   \   000015   6047         JZ        ??ZDSecMgrEntryLookup_0
    698            {
    699              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000017   85..82       MOV       DPL,?XSP + 0
   \   00001A   85..83       MOV       DPH,?XSP + 1
   \   00001D   7402         MOV       A,#0x2
   \   00001F   F0           MOVX      @DPTR,A
    700              addrMgrEntry.nwkAddr = nwkAddr;
   \   000020   14           DEC       A
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   12....       LCALL     ?Subroutine13 & 0xFFFF
    701          
    702              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_173:
   \   000027   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00002A   E9           MOV       A,R1
   \   00002B   6401         XRL       A,#0x1
   \   00002D   702F         JNZ       ??ZDSecMgrEntryLookup_0
    703              {
    704                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00002F   7800         MOV       R0,#0x0
   \   000031   7900         MOV       R1,#0x0
    705                {
    706                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_1:
   \   000033   12....       LCALL     ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000036   740B         MOV       A,#0xb
   \   000038   12....       LCALL     ?XSTACK_DISP0_8
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   FC           MOV       R4,A
   \   00003D   A3           INC       DPTR
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   FD           MOV       R5,A
   \   000040   8A82         MOV       DPL,R2
   \   000042   8B83         MOV       DPH,R3
   \   000044   E0           MOVX      A,@DPTR
   \   000045   6C           XRL       A,R4
   \   000046   7003         JNZ       ??ZDSecMgrEntryLookup_2
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   6D           XRL       A,R5
   \                     ??ZDSecMgrEntryLookup_2:
   \   00004B   7007         JNZ       ??ZDSecMgrEntryLookup_3
    707                  {
    708                    // return successful results
    709                    *entry = &ZDSecMgrEntries[index];
   \   00004D   12....       LCALL     ?Subroutine31 & 0xFFFF
    710                    status = ZSuccess;
    711          
    712                    // break from loop
    713                    return status;
   \                     ??CrossCallReturnLabel_191:
   \   000050   7900         MOV       R1,#0x0
   \   000052   800C         SJMP      ??ZDSecMgrEntryLookup_4
    714                  }
    715                }
   \                     ??ZDSecMgrEntryLookup_3:
   \   000054   08           INC       R0
   \   000055   E8           MOV       A,R0
   \   000056   7001         JNZ       ??ZDSecMgrEntryLookup_5
   \   000058   09           INC       R1
   \                     ??ZDSecMgrEntryLookup_5:
   \   000059   12....       LCALL     ?Subroutine36 & 0xFFFF
    716              }
    717            }
   \                     ??CrossCallReturnLabel_134:
   \   00005C   40D5         JC        ??ZDSecMgrEntryLookup_1
    718          
    719            return status;
   \                     ??ZDSecMgrEntryLookup_0:
   \   00005E   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrEntryLookup_4:
   \   000060   02....       LJMP      ?Subroutine7 & 0xFFFF
    720          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   F0           MOVX      @DPTR,A
   \   000004   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000007   12....       LCALL     ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   00000A   E8           MOV       A,R0
   \   00000B   49           ORL       A,R1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004                REQUIRE ??Subroutine106_0
   \   000004                ; // Fall through to label ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   000001                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001   AA..         MOV       R2,?XSP + 0
   \   000003   AB..         MOV       R3,?XSP + 1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine107_0
   \   000004                ; // Fall through to label ??Subroutine107_0
    721          
    722          /******************************************************************************
    723           * @fn          ZDSecMgrEntryLookupAMI
    724           *
    725           * @brief       Lookup entry using specified address index
    726           *
    727           * @param       ami   - [in] Address Manager index
    728           * @param       entry - [out] valid entry
    729           *
    730           * @return      ZStatus_t
    731           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    732          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    733          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    734            ZStatus_t status;
    735            uint16    index;
    736          
    737          
    738            // initialize results
    739            *entry = NULL;
   \   000009   8C82         MOV       DPL,R4
   \   00000B   8D83         MOV       DPH,R5
   \   00000D   12....       LCALL     ?Subroutine16 & 0xFFFF
    740            status = ZNwkUnknownDevice;
    741          
    742            // verify data is available
    743            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_10:
   \   000010   6038         JZ        ??ZDSecMgrEntryLookupAMI_0
    744            {
    745              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000012   7800         MOV       R0,#0x0
   \   000014   7900         MOV       R1,#0x0
    746              {
    747                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000016   E8           MOV       A,R0
   \   000017   FA           MOV       R2,A
   \   000018   E9           MOV       A,R1
   \   000019   FB           MOV       R3,A
   \   00001A   EA           MOV       A,R2
   \   00001B   75F005       MOV       B,#0x5
   \   00001E   A4           MUL       AB
   \   00001F   FA           MOV       R2,A
   \   000020   85F0..       MOV       ?V0,B
   \   000023   75F005       MOV       B,#0x5
   \   000026   EB           MOV       A,R3
   \   000027   A4           MUL       AB
   \   000028   25..         ADD       A,?V0
   \   00002A   12....       LCALL     ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   00002D   6E           XRL       A,R6
   \   00002E   7003         JNZ       ??ZDSecMgrEntryLookupAMI_2
   \   000030   A3           INC       DPTR
   \   000031   E0           MOVX      A,@DPTR
   \   000032   6F           XRL       A,R7
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000033   700B         JNZ       ??ZDSecMgrEntryLookupAMI_3
    748                {
    749                  // return successful results
    750                  *entry = &ZDSecMgrEntries[index];
   \   000035   8C82         MOV       DPL,R4
   \   000037   8D83         MOV       DPH,R5
   \   000039   12....       LCALL     ??Subroutine107_0 & 0xFFFF
    751                  status = ZSuccess;
    752          
    753                  // break from loop
    754                  return status;
   \                     ??CrossCallReturnLabel_184:
   \   00003C   7900         MOV       R1,#0x0
   \   00003E   800C         SJMP      ??ZDSecMgrEntryLookupAMI_4
    755                }
    756              }
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000040   08           INC       R0
   \   000041   E8           MOV       A,R0
   \   000042   7001         JNZ       ??ZDSecMgrEntryLookupAMI_5
   \   000044   09           INC       R1
   \                     ??ZDSecMgrEntryLookupAMI_5:
   \   000045   12....       LCALL     ?Subroutine36 & 0xFFFF
    757            }
   \                     ??CrossCallReturnLabel_135:
   \   000048   40CC         JC        ??ZDSecMgrEntryLookupAMI_1
    758          
    759            return status;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   00004A   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   00004C   02....       LJMP      ??Subroutine101_0 & 0xFFFF
    760          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   FB           MOV       R3,A
   \   000001   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000004   12....       LCALL     ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000007   E0           MOVX      A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2A           ADD       A,R2
   \   000002   FA           MOV       R2,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   3B           ADDC      A,R3
   \   000006   FB           MOV       R3,A
   \   000007   8A82         MOV       DPL,R2
   \   000009   F583         MOV       DPH,A
   \   00000B   22           RET
    761          
    762          /******************************************************************************
    763           * @fn          ZDSecMgrEntryLookupExt
    764           *
    765           * @brief       Lookup entry index using specified EXT address.
    766           *
    767           * @param       extAddr - [in] EXT address
    768           * @param       entry   - [out] valid entry
    769           *
    770           * @return      ZStatus_t
    771           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    772          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    773          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    774            ZStatus_t status;
    775            uint16    ami;
    776          
    777          
    778            // initialize results
    779            *entry = NULL;
   \   00000E   8C82         MOV       DPL,R4
   \   000010   F583         MOV       DPH,A
   \   000012   E4           CLR       A
   \   000013   F0           MOVX      @DPTR,A
   \   000014   A3           INC       DPTR
   \   000015   F0           MOVX      @DPTR,A
    780            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV       ?V0,#-0x38
    781          
    782            // lookup address index
    783            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000019   AC..         MOV       R4,?XSP + 0
   \   00001B   AD..         MOV       R5,?XSP + 1
   \   00001D   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000020   E9           MOV       A,R1
   \   000021   7010         JNZ       ??ZDSecMgrEntryLookupExt_0
    784            {
    785              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000023                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000023   EE           MOV       A,R6
   \   000024   FC           MOV       R4,A
   \   000025   EF           MOV       A,R7
   \   000026   FD           MOV       R5,A
   \   000027   85..82       MOV       DPL,?XSP + 0
   \   00002A   85..83       MOV       DPH,?XSP + 1
   \   00002D   12....       LCALL     ?Subroutine58 & 0xFFFF
    786            }
   \                     ??CrossCallReturnLabel_69:
   \   000030   E9           MOV       A,R1
   \   000031   F5..         MOV       ?V0,A
    787          
    788            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000033   02....       LJMP      ?Subroutine1 & 0xFFFF
    789          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   A9..         MOV       R1,?V0
   \   000002                REQUIRE ??Subroutine99_0
   \   000002                ; // Fall through to label ??Subroutine99_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine99_0:
   \   000000   7402         MOV       A,#0x2
   \   000002                REQUIRE ??Subroutine100_0
   \   000002                ; // Fall through to label ??Subroutine100_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine128_0:
   \   000000   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000003   FB           MOV       R3,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   12....       LCALL     ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   000003   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000006   22           RET
    790          
    791          /******************************************************************************
    792           * @fn          ZDSecMgrEntryLookupExtGetIndex
    793           *
    794           * @brief       Lookup entry index using specified EXT address.
    795           *
    796           * @param       extAddr - [in] EXT address
    797           * @param       entryIndex - [out] valid index to the entry table
    798           *
    799           * @return      ZStatus_t
    800           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    801          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    802          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    803            ZStatus_t status;
    804            uint16    ami;
    805            uint16    index;
    806          
    807            // initialize results
    808            status = ZNwkUnknownDevice;
    809          
    810            // lookup address index
    811            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   704E         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_0
    812            {  
    813              // verify data is available
    814              if ( ZDSecMgrEntries != NULL )
   \   000018   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00001B   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   00001E   6046         JZ        ??ZDSecMgrEntryLookupExtGetIndex_0
    815              {
    816                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000020   7800         MOV       R0,#0x0
   \   000022   7900         MOV       R1,#0x0
    817                {
    818                  if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   000024   E8           MOV       A,R0
   \   000025   FA           MOV       R2,A
   \   000026   E9           MOV       A,R1
   \   000027   FB           MOV       R3,A
   \   000028   EA           MOV       A,R2
   \   000029   75F005       MOV       B,#0x5
   \   00002C   A4           MUL       AB
   \   00002D   FA           MOV       R2,A
   \   00002E   ACF0         MOV       R4,B
   \   000030   75F005       MOV       B,#0x5
   \   000033   EB           MOV       A,R3
   \   000034   A4           MUL       AB
   \   000035   2C           ADD       A,R4
   \   000036   12....       LCALL     ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000039   FC           MOV       R4,A
   \   00003A   A3           INC       DPTR
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   FD           MOV       R5,A
   \   00003D   85..82       MOV       DPL,?XSP + 0
   \   000040   85..83       MOV       DPH,?XSP + 1
   \   000043   E0           MOVX      A,@DPTR
   \   000044   6C           XRL       A,R4
   \   000045   7003         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_2
   \   000047   A3           INC       DPTR
   \   000048   E0           MOVX      A,@DPTR
   \   000049   6D           XRL       A,R5
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   00004A   7010         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_3
    819                  {
    820                    // return successful results
    821                    *entry = &ZDSecMgrEntries[index];
   \   00004C   12....       LCALL     ?Subroutine31 & 0xFFFF
    822                    *entryIndex = index;
   \                     ??CrossCallReturnLabel_192:
   \   00004F   740B         MOV       A,#0xb
   \   000051   12....       LCALL     ?XSTACK_DISP0_8
   \   000054   12....       LCALL     ?Subroutine56 & 0xFFFF
    823                    status = ZSuccess;
    824                    
    825                    return status;
    826                  }
    827                }
   \                     ??CrossCallReturnLabel_64:
   \   000057   12....       LCALL     ??Subroutine90_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   00005A   800C         SJMP      ??ZDSecMgrEntryLookupExtGetIndex_4
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   00005C   08           INC       R0
   \   00005D   E8           MOV       A,R0
   \   00005E   7001         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_5
   \   000060   09           INC       R1
   \                     ??ZDSecMgrEntryLookupExtGetIndex_5:
   \   000061   12....       LCALL     ?Subroutine36 & 0xFFFF
    828              }
    829            }
   \                     ??CrossCallReturnLabel_136:
   \   000064   40BE         JC        ??ZDSecMgrEntryLookupExtGetIndex_1
    830          
    831            return status;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   000066   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrEntryLookupExtGetIndex_4:
   \   000068   02....       LJMP      ??Subroutine99_0 & 0xFFFF
    832          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   000003   F583         MOV       DPH,A
   \   000005   8A82         MOV       DPL,R2
   \   000007   22           RET
    833          
    834          /******************************************************************************
    835           * @fn          ZDSecMgrEntryFree
    836           *
    837           * @brief       Free entry.
    838           *
    839           * @param       entry - [in] valid entry
    840           *
    841           * @return      ZStatus_t
    842           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    843          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    844          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
    845            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
    846            
    847            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A18         MOV       R2,#0x18
   \   00000B   7B00         MOV       R3,#0x0
   \   00000D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000010   8A..         MOV       ?V2,R2
   \   000012   8B..         MOV       ?V3,R3
    848          
    849            if (pApsLinkKey != NULL)
   \   000014   EA           MOV       A,R2
   \   000015   4B           ORL       A,R3
   \   000016   6042         JZ        ??ZDSecMgrEntryFree_0
    850            {
    851              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000018                ; Setup parameters for call to function osal_memset
   \   000018   7C18         MOV       R4,#0x18
   \   00001A   7D00         MOV       R5,#0x0
   \   00001C   7900         MOV       R1,#0x0
   \   00001E   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    852          
    853              // Clear the APS Link key in NV
    854              osal_nv_write( entry->keyNvId, 0,
    855                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   000021   E5..         MOV       A,?V0
   \   000023   2402         ADD       A,#0x2
   \   000025   FE           MOV       R6,A
   \   000026   E4           CLR       A
   \   000027   35..         ADDC      A,?V1
   \   000029   FF           MOV       R7,A
   \   00002A                ; Setup parameters for call to function osal_nv_write
   \   00002A   78..         MOV       R0,#?V2
   \   00002C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002F   75..18       MOV       ?V4,#0x18
   \   000032   75..00       MOV       ?V5,#0x0
   \   000035   78..         MOV       R0,#?V4
   \   000037   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003A   7C00         MOV       R4,#0x0
   \   00003C   7D00         MOV       R5,#0x0
   \   00003E   8E82         MOV       DPL,R6
   \   000040   8F83         MOV       DPH,R7
   \   000042   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_306:
   \   000045   12....       LCALL     ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000048   12....       LCALL     ?DEALLOC_XSTACK8
    856          
    857              // set entry to invalid Key
    858              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   00004B   8E82         MOV       DPL,R6
   \   00004D   8F83         MOV       DPH,R7
   \   00004F   E4           CLR       A
   \   000050   F0           MOVX      @DPTR,A
   \   000051   A3           INC       DPTR
   \   000052   F0           MOVX      @DPTR,A
    859              
    860              osal_mem_free(pApsLinkKey);
   \   000053                ; Setup parameters for call to function osal_mem_free
   \   000053   AA..         MOV       R2,?V2
   \   000055   AB..         MOV       R3,?V3
   \   000057   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    861            }
    862          
    863            // marking the entry as INVALID_NODE_ADDR
    864            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_0:
   \   00005A   85..82       MOV       DPL,?V0
   \   00005D   85..83       MOV       DPH,?V1
   \   000060   74FE         MOV       A,#-0x2
   \   000062   F0           MOVX      @DPTR,A
   \   000063   A3           INC       DPTR
   \   000064   04           INC       A
   \   000065   F0           MOVX      @DPTR,A
    865          }
   \   000066   02....       LJMP      ??Subroutine116_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine116_0:
   \   000000   7F06         MOV       R7,#0x6
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    866          
    867          /******************************************************************************
    868           * @fn          ZDSecMgrEntryNew
    869           *
    870           * @brief       Get a new entry.
    871           *
    872           * @param       entry - [out] valid entry
    873           *
    874           * @return      ZStatus_t
    875           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    876          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    877          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    878            ZStatus_t status;
    879            uint16    index;
    880          
    881          
    882            // initialize results
    883            *entry = NULL;
   \   000009   8A82         MOV       DPL,R2
   \   00000B   F583         MOV       DPH,A
   \   00000D   E4           CLR       A
   \   00000E   F0           MOVX      @DPTR,A
   \   00000F   A3           INC       DPTR
   \   000010   F0           MOVX      @DPTR,A
    884            status = ZNwkUnknownDevice;
   \   000011   75..C8       MOV       ?V0,#-0x38
    885          
    886            // verify data is available
    887            if ( ZDSecMgrEntries != NULL )
   \   000014   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000017   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   00001A   605E         JZ        ??ZDSecMgrEntryNew_0
    888            {
    889              // find available entry
    890              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00001C   7A00         MOV       R2,#0x0
   \   00001E   7B00         MOV       R3,#0x0
    891              {
    892                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_1:
   \   000020   EA           MOV       A,R2
   \   000021   F8           MOV       R0,A
   \   000022   EB           MOV       A,R3
   \   000023   F9           MOV       R1,A
   \   000024   E8           MOV       A,R0
   \   000025   75F005       MOV       B,#0x5
   \   000028   A4           MUL       AB
   \   000029   F8           MOV       R0,A
   \   00002A   ACF0         MOV       R4,B
   \   00002C   75F005       MOV       B,#0x5
   \   00002F   E9           MOV       A,R1
   \   000030   A4           MUL       AB
   \   000031   2C           ADD       A,R4
   \   000032   F9           MOV       R1,A
   \   000033   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000036   E0           MOVX      A,@DPTR
   \   000037   28           ADD       A,R0
   \   000038   FC           MOV       R4,A
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   39           ADDC      A,R1
   \   00003C   FD           MOV       R5,A
   \   00003D   8C82         MOV       DPL,R4
   \   00003F   F583         MOV       DPH,A
   \   000041   E0           MOVX      A,@DPTR
   \   000042   64FE         XRL       A,#0xfe
   \   000044   7003         JNZ       ??ZDSecMgrEntryNew_2
   \   000046   A3           INC       DPTR
   \   000047   E0           MOVX      A,@DPTR
   \   000048   F4           CPL       A
   \                     ??ZDSecMgrEntryNew_2:
   \   000049   7022         JNZ       ??ZDSecMgrEntryNew_3
    893                {
    894                  // return successful result
    895                  *entry = &ZDSecMgrEntries[index];
   \   00004B   8E82         MOV       DPL,R6
   \   00004D   8F83         MOV       DPH,R7
   \   00004F   EC           MOV       A,R4
   \   000050   F0           MOVX      @DPTR,A
   \   000051   A3           INC       DPTR
   \   000052   ED           MOV       A,R5
   \   000053   F0           MOVX      @DPTR,A
    896                  status = ZSuccess;
   \   000054   75..00       MOV       ?V0,#0x0
    897          
    898                  // Set the authentication option to default
    899                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   000057   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   28           ADD       A,R0
   \   00005C   FA           MOV       R2,A
   \   00005D   A3           INC       DPTR
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   39           ADDC      A,R1
   \   000060   8A82         MOV       DPL,R2
   \   000062   F583         MOV       DPH,A
   \   000064   A3           INC       DPTR
   \   000065   A3           INC       DPTR
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   E4           CLR       A
   \   000069   F0           MOVX      @DPTR,A
    900          
    901                  // break from loop
    902                  index = ZDSECMGR_ENTRY_MAX;
   \   00006A   7A03         MOV       R2,#0x3
   \   00006C   FB           MOV       R3,A
    903                }
    904              }
   \                     ??ZDSecMgrEntryNew_3:
   \   00006D   0A           INC       R2
   \   00006E   EA           MOV       A,R2
   \   00006F   7001         JNZ       ??ZDSecMgrEntryNew_4
   \   000071   0B           INC       R3
   \                     ??ZDSecMgrEntryNew_4:
   \   000072   C3           CLR       C
   \   000073   9403         SUBB      A,#0x3
   \   000075   EB           MOV       A,R3
   \   000076   9400         SUBB      A,#0x0
   \   000078   40A6         JC        ??ZDSecMgrEntryNew_1
    905            }
    906          
    907            return status;
   \                     ??ZDSecMgrEntryNew_0:
   \   00007A   A9..         MOV       R1,?V0
   \   00007C   02....       LJMP      ??Subroutine115_0 & 0xFFFF
    908          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine115_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    909          
    910          /******************************************************************************
    911           * @fn          ZDSecMgrCtrlInit
    912           *
    913           * @brief       Initialize control sub module
    914           *
    915           * @param       none
    916           *
    917           * @return      none
    918           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    919          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    920          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    921            uint16 size;
    922            uint16 index;
    923          
    924            // allocate entry data
    925            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    926          
    927            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV       R2,#0x15
   \   000006   7B00         MOV       R3,#0x0
   \   000008   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000B   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   00000E   12....       LCALL     ??Subroutine107_0 & 0xFFFF
    928          
    929            // initialize data
    930            if ( ZDSecMgrCtrlData != NULL )
   \                     ??CrossCallReturnLabel_185:
   \   000011   F9           MOV       R1,A
   \   000012   EA           MOV       A,R2
   \   000013   49           ORL       A,R1
   \   000014   6035         JZ        ??ZDSecMgrCtrlInit_0
    931            {
    932              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000016   7800         MOV       R0,#0x0
   \   000018   7900         MOV       R1,#0x0
    933              {
    934                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_1:
   \   00001A   E8           MOV       A,R0
   \   00001B   FA           MOV       R2,A
   \   00001C   E9           MOV       A,R1
   \   00001D   FB           MOV       R3,A
   \   00001E   EA           MOV       A,R2
   \   00001F   75F007       MOV       B,#0x7
   \   000022   A4           MUL       AB
   \   000023   FA           MOV       R2,A
   \   000024   ACF0         MOV       R4,B
   \   000026   75F007       MOV       B,#0x7
   \   000029   EB           MOV       A,R3
   \   00002A   A4           MUL       AB
   \   00002B   2C           ADD       A,R4
   \   00002C   FB           MOV       R3,A
   \   00002D   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000030   E0           MOVX      A,@DPTR
   \   000031   2A           ADD       A,R2
   \   000032   FC           MOV       R4,A
   \   000033   A3           INC       DPTR
   \   000034   E0           MOVX      A,@DPTR
   \   000035   3B           ADDC      A,R3
   \   000036   8C82         MOV       DPL,R4
   \   000038   F583         MOV       DPH,A
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   E4           CLR       A
   \   000040   F0           MOVX      @DPTR,A
    935              }
   \   000041   08           INC       R0
   \   000042   E8           MOV       A,R0
   \   000043   7001         JNZ       ??ZDSecMgrCtrlInit_2
   \   000045   09           INC       R1
   \                     ??ZDSecMgrCtrlInit_2:
   \   000046   12....       LCALL     ?Subroutine36 & 0xFFFF
    936            }
   \                     ??CrossCallReturnLabel_137:
   \   000049   40CF         JC        ??ZDSecMgrCtrlInit_1
    937          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   00004B   02....       LJMP      ??Subroutine105_0 & 0xFFFF
    938          
    939          /******************************************************************************
    940           * @fn          ZDSecMgrCtrlRelease
    941           *
    942           * @brief       Release control data.
    943           *
    944           * @param       ctrl - [in] valid control data
    945           *
    946           * @return      none
    947           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    948          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    949          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    950            // should always be enough entry control data
    951            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   E4           CLR       A
   \   00000E   F0           MOVX      @DPTR,A
    952          }
   \   00000F   02....       LJMP      ??Subroutine105_0 & 0xFFFF
    953          
    954          /******************************************************************************
    955           * @fn          ZDSecMgrCtrlLookup
    956           *
    957           * @brief       Lookup control data.
    958           *
    959           * @param       entry - [in] valid entry data
    960           * @param       ctrl  - [out] control data - NULL if not found
    961           *
    962           * @return      none
    963           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    964          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    965          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    966            uint16 index;
    967          
    968          
    969            // initialize search results
    970            *ctrl = NULL;
   \   000009   8C82         MOV       DPL,R4
   \   00000B   8D83         MOV       DPH,R5
   \   00000D   E4           CLR       A
   \   00000E   F0           MOVX      @DPTR,A
   \   00000F   A3           INC       DPTR
   \   000010   F0           MOVX      @DPTR,A
    971          
    972            // verify data is available
    973            if ( ZDSecMgrCtrlData != NULL )
   \   000011   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000014   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000017   6047         JZ        ??ZDSecMgrCtrlLookup_0
    974            {
    975              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7800         MOV       R0,#0x0
   \   00001B   7900         MOV       R1,#0x0
    976              {
    977                // make sure control data is in use
    978                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_1:
   \   00001D   E8           MOV       A,R0
   \   00001E   FA           MOV       R2,A
   \   00001F   E9           MOV       A,R1
   \   000020   FB           MOV       R3,A
   \   000021   EA           MOV       A,R2
   \   000022   75F007       MOV       B,#0x7
   \   000025   A4           MUL       AB
   \   000026   FA           MOV       R2,A
   \   000027   85F0..       MOV       ?V0,B
   \   00002A   75F007       MOV       B,#0x7
   \   00002D   EB           MOV       A,R3
   \   00002E   A4           MUL       AB
   \   00002F   25..         ADD       A,?V0
   \   000031   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000034   6020         JZ        ??ZDSecMgrCtrlLookup_2
    979                {
    980                  // check for entry match
    981                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000036   8A82         MOV       DPL,R2
   \   000038   8B83         MOV       DPH,R3
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   F5..         MOV       ?V0,A
   \   00003D   A3           INC       DPTR
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   F5..         MOV       ?V1,A
   \   000041   EE           MOV       A,R6
   \   000042   65..         XRL       A,?V0
   \   000044   7003         JNZ       ??ZDSecMgrCtrlLookup_3
   \   000046   EF           MOV       A,R7
   \   000047   65..         XRL       A,?V1
   \                     ??ZDSecMgrCtrlLookup_3:
   \   000049   700B         JNZ       ??ZDSecMgrCtrlLookup_2
    982                  {
    983                    // return this control data
    984                    *ctrl = &ZDSecMgrCtrlData[index];
   \   00004B   8C82         MOV       DPL,R4
   \   00004D   8D83         MOV       DPH,R5
   \   00004F   12....       LCALL     ??Subroutine107_0 & 0xFFFF
    985          
    986                    // break from loop
    987                    index = ZDSECMGR_CTRL_MAX;
   \                     ??CrossCallReturnLabel_186:
   \   000052   7803         MOV       R0,#0x3
   \   000054   7900         MOV       R1,#0x0
    988                  }
    989                }
    990              }
   \                     ??ZDSecMgrCtrlLookup_2:
   \   000056   08           INC       R0
   \   000057   E8           MOV       A,R0
   \   000058   7001         JNZ       ??ZDSecMgrCtrlLookup_4
   \   00005A   09           INC       R1
   \                     ??ZDSecMgrCtrlLookup_4:
   \   00005B   12....       LCALL     ?Subroutine36 & 0xFFFF
    991            }
   \                     ??CrossCallReturnLabel_138:
   \   00005E   40BD         JC        ??ZDSecMgrCtrlLookup_1
    992          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   000060   02....       LJMP      ??Subroutine115_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   FB           MOV       R3,A
   \   000001   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000004   12....       LCALL     ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   22           RET
    993          
    994          /******************************************************************************
    995           * @fn          ZDSecMgrCtrlSet
    996           *
    997           * @brief       Set control data.
    998           *
    999           * @param       device - [in] valid device data
   1000           * @param       entry  - [in] valid entry data
   1001           * @param       ctrl   - [in] valid control data
   1002           *
   1003           * @return      none
   1004           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1005          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
   1006                                ZDSecMgrEntry_t*  entry,
   1007                                ZDSecMgrCtrl_t*   ctrl )
   1008          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV       A,#0x9
   \   000007   12....       LCALL     ?XSTACK_DISP0_8
   \   00000A   12....       LCALL     ??Subroutine120_0 & 0xFFFF
   1009            // set control date
   1010            ctrl->parentAddr = device->parentAddr;
   \                     ??CrossCallReturnLabel_238:
   \   00000D   8A82         MOV       DPL,R2
   \   00000F   8B83         MOV       DPH,R3
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FE           MOV       R6,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   FF           MOV       R7,A
   \   00001A   8882         MOV       DPL,R0
   \   00001C   8983         MOV       DPH,R1
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   EE           MOV       A,R6
   \   000021   F0           MOVX      @DPTR,A
   \   000022   A3           INC       DPTR
   \   000023   EF           MOV       A,R7
   \   000024   12....       LCALL     ?Subroutine22 & 0xFFFF
   1011            ctrl->secure     = device->secure;
   \                     ??CrossCallReturnLabel_21:
   \   000027   E0           MOVX      A,@DPTR
   \   000028   8882         MOV       DPL,R0
   \   00002A   8983         MOV       DPH,R1
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   12....       LCALL     ?Subroutine75 & 0xFFFF
   1012            ctrl->entry      = entry;
   \                     ??CrossCallReturnLabel_97:
   \   000033   EC           MOV       A,R4
   \   000034   F0           MOVX      @DPTR,A
   \   000035   A3           INC       DPTR
   \   000036   ED           MOV       A,R5
   \   000037   12....       LCALL     ?Subroutine23 & 0xFFFF
   1013            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \                     ??CrossCallReturnLabel_23:
   \   00003A   7401         MOV       A,#0x1
   \   00003C   12....       LCALL     ?Subroutine23 & 0xFFFF
   1014            ctrl->cntr       = 0;
   \                     ??CrossCallReturnLabel_24:
   \   00003F   A3           INC       DPTR
   \   000040   E4           CLR       A
   \   000041   12....       LCALL     ?Subroutine22 & 0xFFFF
   1015          
   1016            // set device pointer
   1017            device->ctrl = ctrl;
   \                     ??CrossCallReturnLabel_22:
   \   000044   12....       LCALL     ?Subroutine34 & 0xFFFF
   1018          }
   \                     ??CrossCallReturnLabel_226:
   \   000047   02....       LJMP      ??Subroutine101_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL     ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL     ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function AssocGetWithExt
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine119_0
   \   000002                ; // Fall through to label ??Subroutine119_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine119_0:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine120_0:
   \   000000   12....       LCALL     ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   000003   22           RET
   1019          
   1020          /******************************************************************************
   1021           * @fn          ZDSecMgrCtrlAdd
   1022           *
   1023           * @brief       Add control data.
   1024           *
   1025           * @param       device - [in] valid device data
   1026           * @param       entry  - [in] valid entry data
   1027           *
   1028           * @return      ZStatus_t
   1029           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1030          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1031          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   1032            ZStatus_t status;
   1033            uint16    index;
   1034          
   1035          
   1036            // initialize results
   1037            status = ZNwkUnknownDevice;
   \   00000D   7CC8         MOV       R4,#-0x38
   1038          
   1039            // verify data is available
   1040            if ( ZDSecMgrCtrlData != NULL )
   \   00000F   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000012   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000015   6044         JZ        ??ZDSecMgrCtrlAdd_0
   1041            {
   1042              // look for an empty slot
   1043              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000017   7800         MOV       R0,#0x0
   \   000019   7900         MOV       R1,#0x0
   1044              {
   1045                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_1:
   \   00001B   E8           MOV       A,R0
   \   00001C   FA           MOV       R2,A
   \   00001D   E9           MOV       A,R1
   \   00001E   FB           MOV       R3,A
   \   00001F   EA           MOV       A,R2
   \   000020   75F007       MOV       B,#0x7
   \   000023   A4           MUL       AB
   \   000024   FA           MOV       R2,A
   \   000025   ADF0         MOV       R5,B
   \   000027   75F007       MOV       B,#0x7
   \   00002A   EB           MOV       A,R3
   \   00002B   A4           MUL       AB
   \   00002C   2D           ADD       A,R5
   \   00002D   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000030   701F         JNZ       ??ZDSecMgrCtrlAdd_2
   1046                {
   1047                  // return successful results
   1048                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   000032                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000032   8A..         MOV       ?V2,R2
   \   000034   8B..         MOV       ?V3,R3
   \   000036   78..         MOV       R0,#?V2
   \   000038   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003B   EE           MOV       A,R6
   \   00003C   FC           MOV       R4,A
   \   00003D   EF           MOV       A,R7
   \   00003E   FD           MOV       R5,A
   \   00003F   AA..         MOV       R2,?V0
   \   000041   AB..         MOV       R3,?V1
   \   000043   12....       LCALL     `??ZDSecMgrCtrlSet::?relay`; Banked call to: ZDSecMgrCtrlSet
   \   000046   7402         MOV       A,#0x2
   \   000048   12....       LCALL     ?DEALLOC_XSTACK8
   1049          
   1050                  status = ZSuccess;
   \   00004B   7C00         MOV       R4,#0x0
   1051          
   1052                  // break from loop
   1053                  index = ZDSECMGR_CTRL_MAX;
   \   00004D   7803         MOV       R0,#0x3
   \   00004F   7900         MOV       R1,#0x0
   1054                }
   1055              }
   \                     ??ZDSecMgrCtrlAdd_2:
   \   000051   08           INC       R0
   \   000052   E8           MOV       A,R0
   \   000053   7001         JNZ       ??ZDSecMgrCtrlAdd_3
   \   000055   09           INC       R1
   \                     ??ZDSecMgrCtrlAdd_3:
   \   000056   12....       LCALL     ?Subroutine36 & 0xFFFF
   1056            }
   \                     ??CrossCallReturnLabel_139:
   \   000059   40C0         JC        ??ZDSecMgrCtrlAdd_1
   1057          
   1058            return status;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   00005B   EC           MOV       A,R4
   \   00005C   F9           MOV       R1,A
   \   00005D   02....       LJMP      ??Subroutine110_0 & 0xFFFF
   1059          }
   1060          
   1061          /******************************************************************************
   1062           * @fn          ZDSecMgrCtrlTerm
   1063           *
   1064           * @brief       Terminate device control.
   1065           *
   1066           * @param       entry - [in] valid entry data
   1067           *
   1068           * @return      none
   1069           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1070          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1071          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV       A,#-0x2
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   1072            ZDSecMgrCtrl_t* ctrl;
   1073          
   1074            // remove device from control data
   1075            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   AC..         MOV       R4,?XSP + 0
   \   00000B   AD..         MOV       R5,?XSP + 1
   \   00000D   12....       LCALL     ??Subroutine111_0 & 0xFFFF
   1076          
   1077            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_198:
   \   000010   6010         JZ        ??ZDSecMgrCtrlTerm_0
   1078            {
   1079              ZDSecMgrCtrlRelease ( ctrl );
   \   000012   85..82       MOV       DPL,?XSP + 0
   \   000015   85..83       MOV       DPH,?XSP + 1
   \   000018   12....       LCALL     ??Subroutine95_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   E4           CLR       A
   \   000021   F0           MOVX      @DPTR,A
   1080            }
   1081          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   000022   7402         MOV       A,#0x2
   \   000024   80..         SJMP      ??Subroutine93_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine93_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   02....       LJMP      ??Subroutine105_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000   12....       LCALL     `??ZDSecMgrCtrlLookup::?relay`; Banked call to: ZDSecMgrCtrlLookup
   \   000003                REQUIRE ??Subroutine112_0
   \   000003                ; // Fall through to label ??Subroutine112_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine113_0
   \   000006                ; // Fall through to label ??Subroutine113_0
   1082          
   1083          /******************************************************************************
   1084           * @fn          ZDSecMgrCtrlReset
   1085           *
   1086           * @brief       Reset control data.
   1087           *
   1088           * @param       device - [in] valid device data
   1089           * @param       entry  - [in] valid entry data
   1090           *
   1091           * @return      ZStatus_t
   1092           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1093          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1094          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   1095            ZStatus_t       status;
   1096            ZDSecMgrCtrl_t* ctrl;
   1097          
   1098          
   1099            // initialize results
   1100            status = ZNwkUnknownDevice;
   1101          
   1102            // look for a match for the entry
   1103            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   AC..         MOV       R4,?XSP + 0
   \   000014   AD..         MOV       R5,?XSP + 1
   \   000016   EE           MOV       A,R6
   \   000017   FA           MOV       R2,A
   \   000018   EF           MOV       A,R7
   \   000019   12....       LCALL     ?Subroutine41 & 0xFFFF
   1104          
   1105            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_196:
   \   00001C   601D         JZ        ??ZDSecMgrCtrlReset_0
   1106            {
   1107              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   00001E                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   00001E   85..82       MOV       DPL,?XSP + 0
   \   000021   85..83       MOV       DPH,?XSP + 1
   \   000024   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000027   EE           MOV       A,R6
   \   000028   FC           MOV       R4,A
   \   000029   EF           MOV       A,R7
   \   00002A   FD           MOV       R5,A
   \   00002B   AA..         MOV       R2,?V0
   \   00002D   AB..         MOV       R3,?V1
   \   00002F   12....       LCALL     `??ZDSecMgrCtrlSet::?relay`; Banked call to: ZDSecMgrCtrlSet
   \   000032   7402         MOV       A,#0x2
   \   000034   12....       LCALL     ?DEALLOC_XSTACK8
   1108          
   1109              status = ZSuccess;
   \   000037   7900         MOV       R1,#0x0
   \   000039   800D         SJMP      ??ZDSecMgrCtrlReset_1
   1110            }
   1111            else
   1112            {
   1113              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   00003B                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   00003B   EE           MOV       A,R6
   \   00003C   FC           MOV       R4,A
   \   00003D   EF           MOV       A,R7
   \   00003E   FD           MOV       R5,A
   \   00003F   AA..         MOV       R2,?V0
   \   000041   AB..         MOV       R3,?V1
   \   000043   12....       LCALL     `??ZDSecMgrCtrlAdd::?relay`; Banked call to: ZDSecMgrCtrlAdd
   \   000046   E9           MOV       A,R1
   \   000047   F9           MOV       R1,A
   1114            }
   1115          
   1116            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   000048   02....       LJMP      ?Subroutine5 & 0xFFFF
   1117          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   FB           MOV       R3,A
   \   000001                REQUIRE ??Subroutine111_0
   \   000001                ; // Fall through to label ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7402         MOV       A,#0x2
   \   000002                REQUIRE ??Subroutine114_0
   \   000002                ; // Fall through to label ??Subroutine114_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine114_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine115_0
   \   000003                ; // Fall through to label ??Subroutine115_0
   1118          
   1119          /******************************************************************************
   1120           * @fn          ZDSecMgrMasterKeyLoad
   1121           *
   1122           * @brief       Load the MASTER key for device with specified EXT
   1123           *              address.
   1124           *
   1125           * @param       extAddr - [in] EXT address of device
   1126           * @param       key     - [in] MASTER key shared with device
   1127           *
   1128           * @return      ZStatus_t
   1129           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1130          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1131          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8C..         MOV       ?V0,R4
   \   00000C   8D..         MOV       ?V1,R5
   1132            ZStatus_t status;
   1133            uint16 ami;
   1134            uint16 keyNvId;
   1135          
   1136          
   1137            // set status based on policy
   1138            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   FE           MOV       R6,A
   1139          
   1140            if ( status == ZSuccess )
   \   000017   7037         JNZ       ??ZDSecMgrMasterKeyLoad_0
   1141            {
   1142              // get the address NV ID
   1143              if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000019   7402         MOV       A,#0x2
   \   00001B   12....       LCALL     ?XSTACK_DISP102_8
   \   00001E   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000021   7024         JNZ       ??ZDSecMgrMasterKeyLoad_1
   1144              {
   1145                // overwrite old key in NV
   1146                osal_nv_write( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   1147                               SEC_KEY_LEN, key );
   \   000023                ; Setup parameters for call to function osal_nv_write
   \   000023   78..         MOV       R0,#?V0
   \   000025   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000028   75..10       MOV       ?V0,#0x10
   \   00002B   75..00       MOV       ?V1,#0x0
   \   00002E   78..         MOV       R0,#?V0
   \   000030   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000033   7C02         MOV       R4,#0x2
   \   000035   7D00         MOV       R5,#0x0
   \   000037   7406         MOV       A,#0x6
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   12....       LCALL     ?Subroutine87 & 0xFFFF
   1148              }
   \                     ??CrossCallReturnLabel_307:
   \   00003F   12....       LCALL     ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   000042   12....       LCALL     ?DEALLOC_XSTACK8
   \   000045   8009         SJMP      ??ZDSecMgrMasterKeyLoad_0
   1149              else
   1150              {
   1151                // store new key -- NULL will zero key
   1152                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   000047                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000047   AC..         MOV       R4,?V0
   \   000049   AD..         MOV       R5,?V1
   \   00004B   12....       LCALL     ?Subroutine59 & 0xFFFF
   1153              }
   1154            }
   \                     ??CrossCallReturnLabel_71:
   \   00004E   E9           MOV       A,R1
   \   00004F   FE           MOV       R6,A
   1155          
   1156            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000050   EE           MOV       A,R6
   \   000051   F9           MOV       R1,A
   \   000052                REQUIRE ?Subroutine10
   \   000052                ; // Fall through to label ?Subroutine10
   1157          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   7404         MOV       A,#0x4
   \   000002   02....       LJMP      ??Subroutine114_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine103_0
   \   000006                ; // Fall through to label ??Subroutine103_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine103_0:
   \   000000   12....       LCALL     ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000003   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   000006   E9           MOV       A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   12....       LCALL     ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   000003   12....       LCALL     `??ZDSecMgrMasterKeyStore::?relay`; Banked call to: ZDSecMgrMasterKeyStore
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine128_0
   \   000006                ; // Fall through to label ??Subroutine128_0
   1158          
   1159          /******************************************************************************
   1160           * @fn          ZDSecMgrAppKeyGet
   1161           *
   1162           * @brief       get an APP key - option APP(MASTER or LINK) key
   1163           *
   1164           * @param       initNwkAddr - [in] NWK address of initiator device
   1165           * @param       initExtAddr - [in] EXT address of initiator device
   1166           * @param       partNwkAddr - [in] NWK address of partner device
   1167           * @param       partExtAddr - [in] EXT address of partner device
   1168           * @param       key         - [out] APP(MASTER or LINK) key
   1169           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1170           *
   1171           * @return      ZStatus_t
   1172           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1173          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1174                                                           // to KEY_TYPE_APP_LINK since
   1175                                                           // only specific requirement
   1176                                                           // right now comes from SE profile
   1177          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1178          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1179                                       uint8*  initExtAddr,
   1180                                       uint16  partNwkAddr,
   1181                                       uint8*  partExtAddr,
   1182                                       uint8** key,
   1183                                       uint8*  keyType )
   1184          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1185            // Intentionally unreferenced parameters
   1186            (void)initNwkAddr;
   1187            (void)initExtAddr;
   1188            (void)partNwkAddr;
   1189            (void)partExtAddr;
   1190            
   1191            //---------------------------------------------------------------------------
   1192            // note:
   1193            // should use a robust mechanism to generate keys, for example
   1194            // combine EXT addresses and call a hash function
   1195            //---------------------------------------------------------------------------
   1196            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000004                ; Setup parameters for call to function SSP_GetTrueRand
   \   000004   7404         MOV       A,#0x4
   \   000006   12....       LCALL     ?XSTACK_DISP0_8
   \   000009   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   00000C   FA           MOV       R2,A
   \   00000D   A3           INC       DPTR
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   FB           MOV       R3,A
   \   000010   7910         MOV       R1,#0x10
   \   000012   12....       LCALL     `??SSP_GetTrueRand::?relay`; Banked call to: SSP_GetTrueRand
   1197          
   1198            *keyType = ZDSecMgrAppKeyType;
   \   000015   90....       MOV       DPTR,#ZDSecMgrAppKeyType
   \   000018   E0           MOVX      A,@DPTR
   \   000019   C0E0         PUSH      A
   \   00001B   7406         MOV       A,#0x6
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000023   D0E0         POP       A
   \   000025   F0           MOVX      @DPTR,A
   1199          
   1200            return ZSuccess;
   \   000026   7900         MOV       R1,#0x0
   \   000028   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   1201          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   E0           MOVX      A,@DPTR
   \   000001                REQUIRE ??Subroutine94_0
   \   000001                ; // Fall through to label ??Subroutine94_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine94_0:
   \   000000   F8           MOV       R0,A
   \   000001                REQUIRE ??Subroutine95_0
   \   000001                ; // Fall through to label ??Subroutine95_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine95_0:
   \   000000   A3           INC       DPTR
   \   000001   E0           MOVX      A,@DPTR
   \   000002   F583         MOV       DPH,A
   \   000004   8882         MOV       DPL,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL     ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   22           RET
   1202          
   1203          /******************************************************************************
   1204           * @fn          ZDSecMgrAppKeyReq
   1205           *
   1206           * @brief       Process request for APP key between two devices.
   1207           *
   1208           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1209           *
   1210           * @return      none
   1211           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1212          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1213          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV       A,#-0x27
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1214            APSME_TransportKeyReq_t req;
   1215            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1216            uint16                  partNwkAddr;
   1217            uint8                   key[SEC_KEY_LEN];
   1218          
   1219          
   1220            // validate initiator and partner
   1221            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1222                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E   EA           MOV       A,R2
   \   00000F   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000012                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000012   AC..         MOV       R4,?XSP + 0
   \   000014   AD..         MOV       R5,?XSP + 1
   \   000016   AA..         MOV       R2,?V0
   \   000018   FB           MOV       R3,A
   \   000019   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   00001C   E9           MOV       A,R1
   \   00001D   6401         XRL       A,#0x1
   \   00001F   6003         JZ        $+5
   \   000021   02....       LJMP      ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000024   EE           MOV       A,R6
   \   000025   2402         ADD       A,#0x2
   \   000027   FE           MOV       R6,A
   \   000028   5001         JNC       ??ZDSecMgrAppKeyReq_1
   \   00002A   0F           INC       R7
   \                     ??ZDSecMgrAppKeyReq_1:
   \   00002B                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002B   740F         MOV       A,#0xf
   \   00002D   12....       LCALL     ?XSTACK_DISP102_8
   \   000030   12....       LCALL     ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000033   12....       LCALL     `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   000036   E9           MOV       A,R1
   \   000037   6401         XRL       A,#0x1
   \   000039   6003         JZ        $+5
   \   00003B   02....       LJMP      ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1223            {
   1224              // point the key to some memory
   1225              req.key = key;
   \   00003E   7417         MOV       A,#0x17
   \   000040   12....       LCALL     ?XSTACK_DISP100_8
   \   000043   7406         MOV       A,#0x6
   \   000045   12....       LCALL     ?XSTACK_DISP0_8
   \   000048   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   1226          
   1227              // get an APP key - option APP (MASTER or LINK) key
   1228              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1229                                      initExtAddr,
   1230                                      partNwkAddr,
   1231                                      ind->partExtAddr,
   1232                                      &req.key,
   1233                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_215:
   \   00004B                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   00004B   7404         MOV       A,#0x4
   \   00004D   12....       LCALL     ?XSTACK_DISP0_8
   \   000050   8582..       MOV       ?V2,DPL
   \   000053   8583..       MOV       ?V3,DPH
   \   000056   78..         MOV       R0,#?V2
   \   000058   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005B   7408         MOV       A,#0x8
   \   00005D   12....       LCALL     ?XSTACK_DISP0_8
   \   000060   8582..       MOV       ?V2,DPL
   \   000063   8583..       MOV       ?V3,DPH
   \   000066   78..         MOV       R0,#?V2
   \   000068   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006B   78..         MOV       R0,#?V0
   \   00006D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000070   7406         MOV       A,#0x6
   \   000072   12....       LCALL     ?XSTACK_DISP0_8
   \   000075   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000078   7417         MOV       A,#0x17
   \   00007A   12....       LCALL     ?XSTACK_DISP102_8
   \   00007D   12....       LCALL     ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   000080   12....       LCALL     `??ZDSecMgrAppKeyGet::?relay`; Banked call to: ZDSecMgrAppKeyGet
   \   000083   7408         MOV       A,#0x8
   \   000085   12....       LCALL     ?DEALLOC_XSTACK8
   \   000088   E9           MOV       A,R1
   \   000089   7076         JNZ       ??ZDSecMgrAppKeyReq_0
   1234              {
   1235                // always secure
   1236                req.nwkSecure = TRUE;
   \   00008B   740C         MOV       A,#0xc
   \   00008D   12....       LCALL     ?XSTACK_DISP0_8
   \   000090   7401         MOV       A,#0x1
   \   000092   F0           MOVX      @DPTR,A
   1237                req.apsSecure = TRUE;
   \   000093   740B         MOV       A,#0xb
   \   000095   12....       LCALL     ?XSTACK_DISP0_8
   \   000098   7401         MOV       A,#0x1
   \   00009A   F0           MOVX      @DPTR,A
   1238                req.tunnel    = NULL;
   \   00009B   740D         MOV       A,#0xd
   \   00009D   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A0   E4           CLR       A
   \   0000A1   F0           MOVX      @DPTR,A
   \   0000A2   A3           INC       DPTR
   \   0000A3   12....       LCALL     ?Subroutine32 & 0xFFFF
   1239          
   1240                // send key to initiator device
   1241                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_33:
   \   0000A6   F9           MOV       R1,A
   \   0000A7   7402         MOV       A,#0x2
   \   0000A9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AC   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   1242                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_216:
   \   0000AF   7408         MOV       A,#0x8
   \   0000B1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B4   E5..         MOV       A,?V0
   \   0000B6   F0           MOVX      @DPTR,A
   \   0000B7   A3           INC       DPTR
   \   0000B8   E5..         MOV       A,?V1
   \   0000BA   F0           MOVX      @DPTR,A
   1243                req.initiator = TRUE;
   \   0000BB   740A         MOV       A,#0xa
   \   0000BD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C0   7401         MOV       A,#0x1
   \   0000C2   F0           MOVX      @DPTR,A
   1244                APSME_TransportKeyReq( &req );
   \   0000C3                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000C3   04           INC       A
   \   0000C4   12....       LCALL     ?XSTACK_DISP101_8
   \   0000C7   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   1245          
   1246                // send key to partner device
   1247                req.dstAddr   = partNwkAddr;
   \   0000CA   85..82       MOV       DPL,?XSP + 0
   \   0000CD   85..83       MOV       DPH,?XSP + 1
   \   0000D0   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0000D3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D6   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   1248                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_217:
   \   0000D9   740F         MOV       A,#0xf
   \   0000DB   12....       LCALL     ?XSTACK_DISP100_8
   \   0000DE   7408         MOV       A,#0x8
   \   0000E0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E3   12....       LCALL     ?Subroutine18 & 0xFFFF
   1249                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_11:
   \   0000E6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E9   E4           CLR       A
   \   0000EA   F0           MOVX      @DPTR,A
   1250          
   1251                APSME_TransportKeyReq( &req );
   \   0000EB                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000EB   7402         MOV       A,#0x2
   \   0000ED   12....       LCALL     ?XSTACK_DISP101_8
   \   0000F0   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   1252                
   1253                // clear copy of key in RAM
   1254                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   0000F3                ; Setup parameters for call to function osal_memset
   \   0000F3   7C10         MOV       R4,#0x10
   \   0000F5   7D00         MOV       R5,#0x0
   \   0000F7   7900         MOV       R1,#0x0
   \   0000F9   7417         MOV       A,#0x17
   \   0000FB   12....       LCALL     ?XSTACK_DISP101_8
   \   0000FE   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1255          
   1256              }
   1257            }
   1258          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   000101   7427         MOV       A,#0x27
   \   000103   02....       LJMP      ??Subroutine109_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL     ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   12....       LCALL     ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine104_0
   \   000004                ; // Fall through to label ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000   12....       LCALL     ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003   740A         MOV       A,#0xa
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   2405         ADD       A,#0x5
   \   000002   F5..         MOV       ?V0,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   F5..         MOV       ?V1,A
   \   000008   22           RET
   1259          
   1260          /******************************************************************************
   1261           * @fn          ZDSecMgrEstablishKey
   1262           *
   1263           * @brief       Start SKKE with device joining network.
   1264           *
   1265           * @param       device - [in] ZDSecMgrDevice_t, device info
   1266           *
   1267           * @return      ZStatus_t
   1268           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1269          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1270          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1271            ZStatus_t               status;
   1272            APSME_EstablishKeyReq_t req;
   1273          
   1274          
   1275            req.respExtAddr = device->extAddr;
   \   00000E   8A82         MOV       DPL,R2
   \   000010   F583         MOV       DPH,A
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   1276            req.method      = APSME_SKKE_METHOD;
   \                     ??CrossCallReturnLabel_218:
   \   00001D   7404         MOV       A,#0x4
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   E4           CLR       A
   \   000023   12....       LCALL     ?Subroutine14 & 0xFFFF
   1277          
   1278            if ( device->parentAddr == NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_5:
   \   000026   7002         JNZ       ??ZDSecMgrEstablishKey_0
   \   000028   EB           MOV       A,R3
   \   000029   69           XRL       A,R1
   \                     ??ZDSecMgrEstablishKey_0:
   \   00002A   7017         JNZ       ??ZDSecMgrEstablishKey_1
   1279            {
   1280              req.dstAddr   = device->nwkAddr;
   \   00002C   8E82         MOV       DPL,R6
   \   00002E   8F83         MOV       DPH,R7
   \   000030   12....       LCALL     ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000033   12....       LCALL     ?Subroutine27 & 0xFFFF
   1281              //devtag.0604.todo - remove obsolete
   1282              req.apsSecure = FALSE;
   \                     ??CrossCallReturnLabel_144:
   \   000036   12....       LCALL     ?XSTACK_DISP0_8
   \   000039   E4           CLR       A
   \   00003A   F0           MOVX      @DPTR,A
   1283              req.nwkSecure = FALSE;
   \   00003B   7406         MOV       A,#0x6
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   E4           CLR       A
   \   000041   8010         SJMP      ??ZDSecMgrEstablishKey_2
   1284            }
   1285            else
   1286            {
   1287              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000043   12....       LCALL     ?Subroutine27 & 0xFFFF
   1288              //devtag.0604.todo - remove obsolete
   1289              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_145:
   \   000046   12....       LCALL     ?XSTACK_DISP0_8
   \   000049   7401         MOV       A,#0x1
   \   00004B   F0           MOVX      @DPTR,A
   1290              req.nwkSecure = TRUE;
   \   00004C   7406         MOV       A,#0x6
   \   00004E   12....       LCALL     ?XSTACK_DISP0_8
   \   000051   7401         MOV       A,#0x1
   1291            }
   \                     ??ZDSecMgrEstablishKey_2:
   \   000053   12....       LCALL     ??Subroutine106_0 & 0xFFFF
   1292          
   1293            status = APSME_EstablishKeyReq( &req );
   1294          
   1295            return status;
   \                     ??CrossCallReturnLabel_175:
   \   000056   12....       LCALL     `??APSME_EstablishKeyReq::?relay`; Banked call to: APSME_EstablishKeyReq
   \   000059   7407         MOV       A,#0x7
   \   00005B   02....       LJMP      ??Subroutine114_0 & 0xFFFF
   1296          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine96_0
   \   000006                ; // Fall through to label ??Subroutine96_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine96_0:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000003                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   000003   7405         MOV       A,#0x5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function NLME_GetShortAddr
   \   000001                ; Setup parameters for call to function NLME_GetShortAddr
   \   000001   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000004   8E82         MOV       DPL,R6
   \   000006   8F83         MOV       DPH,R7
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   12....       LCALL     ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   00000D   EA           MOV       A,R2
   \   00000E   68           XRL       A,R0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine118_0
   \   000002                ; // Fall through to label ??Subroutine118_0
   1297          
   1298          /******************************************************************************
   1299           * @fn          ZDSecMgrSendMasterKey
   1300           *
   1301           * @brief       Send MASTER key to device joining network.
   1302           *
   1303           * @param       device - [in] ZDSecMgrDevice_t, device info
   1304           *
   1305           * @return      ZStatus_t
   1306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1307          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1308          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV       A,#-0x1f
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1309            ZStatus_t status;
   1310            APSME_TransportKeyReq_t req;
   1311            uint16 keyNvId;
   1312            uint8 masterKey[SEC_KEY_LEN];
   1313          
   1314          
   1315            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7404         MOV       A,#0x4
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   E4           CLR       A
   \   000014   12....       LCALL     ?Subroutine19 & 0xFFFF
   1316            req.extAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_15:
   \   000017   7408         MOV       A,#0x8
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ??Subroutine108_0 & 0xFFFF
   1317            req.tunnel  = NULL;
   \                     ??CrossCallReturnLabel_195:
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   12....       LCALL     ?Subroutine21 & 0xFFFF
   1318          
   1319            if ( ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &keyNvId ) == ZSuccess )
   \                     ??CrossCallReturnLabel_19:
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000030   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000033   12....       LCALL     ??Subroutine103_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000036   702A         JNZ       ??ZDSecMgrSendMasterKey_0
   1320            {
   1321              osal_nv_read( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   1322                            SEC_KEY_LEN, masterKey );
   \   000038                ; Setup parameters for call to function osal_nv_read
   \   000038   740F         MOV       A,#0xf
   \   00003A   12....       LCALL     ?XSTACK_DISP100_8
   \   00003D   88..         MOV       ?V0,R0
   \   00003F   89..         MOV       ?V1,R1
   \   000041   78..         MOV       R0,#?V0
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000046   75..10       MOV       ?V0,#0x10
   \   000049   75..00       MOV       ?V1,#0x0
   \   00004C   78..         MOV       R0,#?V0
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000051   7C02         MOV       R4,#0x2
   \   000053   7D00         MOV       R5,#0x0
   \   000055   7404         MOV       A,#0x4
   \   000057   12....       LCALL     ?XSTACK_DISP0_8
   \   00005A   12....       LCALL     ?Subroutine47 & 0xFFFF
   1323            }
   \                     ??CrossCallReturnLabel_46:
   \   00005D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000060   800E         SJMP      ??ZDSecMgrSendMasterKey_1
   1324            else
   1325            {
   1326              // in case read from NV fails
   1327              osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \                     ??ZDSecMgrSendMasterKey_0:
   \   000062                ; Setup parameters for call to function osal_memset
   \   000062   7C10         MOV       R4,#0x10
   \   000064   7D00         MOV       R5,#0x0
   \   000066   7900         MOV       R1,#0x0
   \   000068   740F         MOV       A,#0xf
   \   00006A   12....       LCALL     ?XSTACK_DISP101_8
   \   00006D   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1328            }
   1329          
   1330            req.key = masterKey;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   000070   740F         MOV       A,#0xf
   \   000072   12....       LCALL     ?XSTACK_DISP100_8
   \   000075   7406         MOV       A,#0x6
   \   000077   12....       LCALL     ?XSTACK_DISP0_8
   \   00007A   E8           MOV       A,R0
   \   00007B   F0           MOVX      @DPTR,A
   \   00007C   A3           INC       DPTR
   \   00007D   E9           MOV       A,R1
   \   00007E   12....       LCALL     ?Subroutine14 & 0xFFFF
   1331          
   1332            //check if using secure hop to to parent
   1333            if ( device->parentAddr != NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_6:
   \   000081   7002         JNZ       ??ZDSecMgrSendMasterKey_2
   \   000083   EB           MOV       A,R3
   \   000084   69           XRL       A,R1
   \                     ??ZDSecMgrSendMasterKey_2:
   \   000085   6019         JZ        ??ZDSecMgrSendMasterKey_3
   1334            {
   1335              //send to parent with security
   1336              req.dstAddr   = device->parentAddr;
   \   000087   7402         MOV       A,#0x2
   \   000089   12....       LCALL     ?XSTACK_DISP0_8
   \   00008C   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   1337              req.nwkSecure = TRUE;
   \                     ??CrossCallReturnLabel_219:
   \   00008F   740C         MOV       A,#0xc
   \   000091   12....       LCALL     ?XSTACK_DISP0_8
   \   000094   7401         MOV       A,#0x1
   \   000096   F0           MOVX      @DPTR,A
   1338              req.apsSecure = TRUE;
   \   000097   740B         MOV       A,#0xb
   \   000099   12....       LCALL     ?XSTACK_DISP0_8
   \   00009C   7401         MOV       A,#0x1
   \   00009E   801A         SJMP      ??ZDSecMgrSendMasterKey_4
   1339            }
   1340            else
   1341            {
   1342              //direct with no security
   1343              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_3:
   \   0000A0   8E82         MOV       DPL,R6
   \   0000A2   8F83         MOV       DPH,R7
   \   0000A4   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   0000A7   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AA   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   1344              req.nwkSecure = FALSE;
   \                     ??CrossCallReturnLabel_220:
   \   0000AD   740C         MOV       A,#0xc
   \   0000AF   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B2   E4           CLR       A
   \   0000B3   F0           MOVX      @DPTR,A
   1345              req.apsSecure = FALSE;
   \   0000B4   740B         MOV       A,#0xb
   \   0000B6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B9   E4           CLR       A
   \                     ??ZDSecMgrSendMasterKey_4:
   \   0000BA   F0           MOVX      @DPTR,A
   1346            }
   1347          
   1348            status = APSME_TransportKeyReq( &req );
   \   0000BB                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000BB   7402         MOV       A,#0x2
   \   0000BD   12....       LCALL     ?XSTACK_DISP101_8
   \   0000C0   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   0000C3   E9           MOV       A,R1
   \   0000C4   FE           MOV       R6,A
   1349          
   1350            // clear copy of key in RAM
   1351            osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \   0000C5                ; Setup parameters for call to function osal_memset
   \   0000C5   7C10         MOV       R4,#0x10
   \   0000C7   7D00         MOV       R5,#0x0
   \   0000C9   7900         MOV       R1,#0x0
   \   0000CB   740F         MOV       A,#0xf
   \   0000CD   12....       LCALL     ?XSTACK_DISP101_8
   \   0000D0   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1352          
   1353            return status;
   \   0000D3   EE           MOV       A,R6
   \   0000D4   F9           MOV       R1,A
   \   0000D5   741F         MOV       A,#0x1f
   \   0000D7   02....       LJMP      ??Subroutine114_0 & 0xFFFF
   1354          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL     ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000003   12....       LCALL     ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   F0           MOVX      @DPTR,A
   \   000004                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000004                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000004   AC..         MOV       R4,?XSP + 0
   \   000006   AD..         MOV       R5,?XSP + 1
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000003   740D         MOV       A,#0xd
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   12....       LCALL     ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   000003   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000006   7404         MOV       A,#0x4
   \   000008   22           RET
   1355          
   1356          /******************************************************************************
   1357           * @fn          ZDSecMgrSendNwkKey
   1358           *
   1359           * @brief       Send NWK key to device joining network.
   1360           *
   1361           * @param       device - [in] ZDSecMgrDevice_t, device info
   1362           *
   1363           * @return      ZStatus_t
   1364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1365          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1366          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV       A,#-0x1e
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1367            ZStatus_t status;
   1368            APSME_TransportKeyReq_t req;
   1369            APSDE_FrameTunnel_t tunnel;
   1370            nwkKeyDesc tmpKey;
   1371              
   1372            req.dstAddr   = device->nwkAddr;
   \   00000E   8A82         MOV       DPL,R2
   \   000010   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000013   E8           MOV       A,R0
   \   000014   F0           MOVX      @DPTR,A
   \   000015   A3           INC       DPTR
   \   000016   E9           MOV       A,R1
   \   000017   12....       LCALL     ?Subroutine19 & 0xFFFF
   1373            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_16:
   \   00001A   7406         MOV       A,#0x6
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   12....       LCALL     ??Subroutine117_0 & 0xFFFF
   1374          
   1375            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1376              req.keyType   = KEY_TYPE_NWK_HIGH;
   1377            else
   1378              req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_214:
   \   000022   12....       LCALL     ?XSTACK_DISP0_8
   \   000025   7401         MOV       A,#0x1
   \   000027   F0           MOVX      @DPTR,A
   1379          
   1380            // get the Active Key into a local variable 
   1381            if( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
   1382                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   000028                ; Setup parameters for call to function NLME_ReadNwkKeyInfo
   \   000028   75..3A       MOV       ?V0,#0x3a
   \   00002B   75..00       MOV       ?V1,#0x0
   \   00002E   78..         MOV       R0,#?V0
   \   000030   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000033   740F         MOV       A,#0xf
   \   000035   12....       LCALL     ?XSTACK_DISP100_8
   \   000038   88..         MOV       ?V0,R0
   \   00003A   89..         MOV       ?V1,R1
   \   00003C   78..         MOV       R0,#?V0
   \   00003E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000041   7C11         MOV       R4,#0x11
   \   000043   7D00         MOV       R5,#0x0
   \   000045   7A00         MOV       R2,#0x0
   \   000047   7B00         MOV       R3,#0x0
   \   000049   12....       LCALL     `??NLME_ReadNwkKeyInfo::?relay`; Banked call to: NLME_ReadNwkKeyInfo
   \   00004C   7404         MOV       A,#0x4
   \   00004E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000051   E9           MOV       A,R1
   \   000052   600E         JZ        ??ZDSecMgrSendNwkKey_0
   1383            {
   1384              // set key data to all 0s if NV read fails
   1385              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   000054                ; Setup parameters for call to function osal_memset
   \   000054   7C11         MOV       R4,#0x11
   \   000056   7D00         MOV       R5,#0x0
   \   000058   7900         MOV       R1,#0x0
   \   00005A   740D         MOV       A,#0xd
   \   00005C   12....       LCALL     ?XSTACK_DISP101_8
   \   00005F   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1386            }
   1387            
   1388            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1389                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1390            {
   1391              // set values
   1392              req.keySeqNum = tmpKey.keySeqNum;
   1393              req.key       = tmpKey.key;
   1394          
   1395              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1396              //key isn't used to secure the frame at the APS layer -- since the receiving
   1397              //device may not have a NWK key yet
   1398              req.apsSecure = TRUE;
   1399          
   1400              // check if using secure hop to to parent
   1401              if ( device->parentAddr == NLME_GetShortAddr() )
   1402              {
   1403                req.nwkSecure = FALSE;
   1404                req.tunnel    = NULL;
   1405              }
   1406              else
   1407              {
   1408                req.nwkSecure   = TRUE;
   1409                req.tunnel      = &tunnel;
   1410                req.tunnel->tna = device->parentAddr;
   1411                req.tunnel->dea = device->extAddr;
   1412              }
   1413            }
   1414            else
   1415            {
   1416              // default values
   1417              //devtag.0604.verify
   1418              req.nwkSecure = TRUE;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   000062   740A         MOV       A,#0xa
   \   000064   12....       LCALL     ?XSTACK_DISP0_8
   \   000067   7401         MOV       A,#0x1
   \   000069   F0           MOVX      @DPTR,A
   1419              req.apsSecure = FALSE;
   \   00006A   7409         MOV       A,#0x9
   \   00006C   12....       LCALL     ?XSTACK_DISP0_8
   \   00006F   E4           CLR       A
   \   000070   F0           MOVX      @DPTR,A
   1420              req.tunnel    = NULL;
   \   000071   740B         MOV       A,#0xb
   \   000073   12....       LCALL     ?XSTACK_DISP0_8
   \   000076   E4           CLR       A
   \   000077   F0           MOVX      @DPTR,A
   \   000078   A3           INC       DPTR
   \   000079   F0           MOVX      @DPTR,A
   1421          
   1422              if ( device->parentAddr != NLME_GetShortAddr() )
   \   00007A                ; Setup parameters for call to function NLME_GetShortAddr
   \   00007A   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00007D   8A..         MOV       ?V0,R2
   \   00007F   8B..         MOV       ?V1,R3
   \   000081   A8..         MOV       R0,?V0
   \   000083   A9..         MOV       R1,?V1
   \   000085   EE           MOV       A,R6
   \   000086   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000089   85..82       MOV       DPL,?V0
   \   00008C   F583         MOV       DPH,A
   \   00008E   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   000091   E8           MOV       A,R0
   \   000092   6A           XRL       A,R2
   \   000093   7002         JNZ       ??ZDSecMgrSendNwkKey_1
   \   000095   E9           MOV       A,R1
   \   000096   6B           XRL       A,R3
   \                     ??ZDSecMgrSendNwkKey_1:
   \   000097   6009         JZ        ??CrossCallReturnLabel_187
   1423              {
   1424                req.dstAddr = device->parentAddr;
   \   000099   85..82       MOV       DPL,?XSP + 0
   \   00009C   85..83       MOV       DPH,?XSP + 1
   \   00009F   12....       LCALL     ??Subroutine107_0 & 0xFFFF
   1425              }
   1426          
   1427              // special cases
   1428              //devtag.0604.todo - modify to preconfig flag
   1429              if ( device->secure == FALSE )
   \                     ??CrossCallReturnLabel_187:
   \   0000A2   8E82         MOV       DPL,R6
   \   0000A4   8F83         MOV       DPH,R7
   \   0000A6   A3           INC       DPTR
   \   0000A7   A3           INC       DPTR
   \   0000A8   A3           INC       DPTR
   \   0000A9   A3           INC       DPTR
   \   0000AA   A3           INC       DPTR
   \   0000AB   A3           INC       DPTR
   \   0000AC   E0           MOVX      A,@DPTR
   \   0000AD   703C         JNZ       ??ZDSecMgrSendNwkKey_2
   1430              {
   1431                req.keySeqNum = tmpKey.keySeqNum;
   \   0000AF   740D         MOV       A,#0xd
   \   0000B1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B4   E0           MOVX      A,@DPTR
   \   0000B5   C0E0         PUSH      A
   \   0000B7   7403         MOV       A,#0x3
   \   0000B9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BC   D0E0         POP       A
   \   0000BE   F0           MOVX      @DPTR,A
   1432                req.key       = tmpKey.key;
   \   0000BF   740E         MOV       A,#0xe
   \   0000C1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C4   A882         MOV       R0,DPL
   \   0000C6   A983         MOV       R1,DPH
   \   0000C8   7404         MOV       A,#0x4
   \   0000CA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CD   12....       LCALL     ?Subroutine33 & 0xFFFF
   1433          
   1434                // check if using secure hop to to parent
   1435                if ( device->parentAddr == NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_35:
   \   0000D0   8A..         MOV       ?V2,R2
   \   0000D2   8B..         MOV       ?V3,R3
   \   0000D4   A8..         MOV       R0,?V2
   \   0000D6   A9..         MOV       R1,?V3
   \   0000D8   85..82       MOV       DPL,?V0
   \   0000DB   85..83       MOV       DPH,?V1
   \   0000DE   E0           MOVX      A,@DPTR
   \   0000DF   68           XRL       A,R0
   \   0000E0   7003         JNZ       ??ZDSecMgrSendNwkKey_3
   \   0000E2   A3           INC       DPTR
   \   0000E3   E0           MOVX      A,@DPTR
   \   0000E4   69           XRL       A,R1
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000E5   7014         JNZ       ??ZDSecMgrSendNwkKey_4
   1436                {
   1437                  req.nwkSecure = FALSE;
   \   0000E7   740A         MOV       A,#0xa
   \   0000E9   800B         SJMP      ??ZDSecMgrSendNwkKey_5
   1438                }
   1439              }
   1440              else
   1441              {
   1442                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000EB   7404         MOV       A,#0x4
   \   0000ED   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F0   E4           CLR       A
   \   0000F1   F0           MOVX      @DPTR,A
   \   0000F2   A3           INC       DPTR
   \   0000F3   F0           MOVX      @DPTR,A
   1443                req.keySeqNum = 0;
   \   0000F4   7403         MOV       A,#0x3
   \                     ??ZDSecMgrSendNwkKey_5:
   \   0000F6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F9   E4           CLR       A
   \   0000FA   F0           MOVX      @DPTR,A
   1444              }
   1445            }
   1446          
   1447            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000FB                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000FB   AA..         MOV       R2,?XSP + 0
   \   0000FD   AB..         MOV       R3,?XSP + 1
   \   0000FF   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   000102   E9           MOV       A,R1
   \   000103   FE           MOV       R6,A
   1448          
   1449            // clear copy of key in RAM before return
   1450            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   000104                ; Setup parameters for call to function osal_memset
   \   000104   7C11         MOV       R4,#0x11
   \   000106   7D00         MOV       R5,#0x0
   \   000108   7900         MOV       R1,#0x0
   \   00010A   740D         MOV       A,#0xd
   \   00010C   12....       LCALL     ?XSTACK_DISP101_8
   \   00010F   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1451          
   1452            return status;
   \   000112   EE           MOV       A,R6
   \   000113   F9           MOV       R1,A
   \   000114   741E         MOV       A,#0x1e
   \   000116   02....       LJMP      ??Subroutine109_0 & 0xFFFF
   1453          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   F583         MOV       DPH,A
   \   000002                REQUIRE ??Subroutine97_0
   \   000002                ; // Fall through to label ??Subroutine97_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine97_0:
   \   000000   12....       LCALL     ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   12....       LCALL     ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000003   F9           MOV       R1,A
   \   000004   85..82       MOV       DPL,?XSP + 0
   \   000007   85..83       MOV       DPH,?XSP + 1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000003                ; Setup parameters for call to function NLME_GetShortAddr
   \   000003                ; Setup parameters for call to function NLME_GetShortAddr
   \   000003   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine117_0:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   2404         ADD       A,#0x4
   \   000002   F5..         MOV       ?V0,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   F5..         MOV       ?V1,A
   \   000008   22           RET
   1454          
   1455          /******************************************************************************
   1456           * @fn          ZDSecMgrDeviceEntryRemove
   1457           *
   1458           * @brief       Remove device entry.
   1459           *
   1460           * @param       entry - [in] valid entry
   1461           *
   1462           * @return      none
   1463           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1464          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1465          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1466            // terminate device control
   1467            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1468            {
   1469              ZDSecMgrCtrlTerm( entry );
   1470            }
   1471          
   1472            // remove device from entry data
   1473            ZDSecMgrEntryFree( entry );
   \   000004                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000004   12....       LCALL     `??ZDSecMgrEntryFree::?relay`; Banked call to: ZDSecMgrEntryFree
   1474          
   1475            // remove EXT address
   1476            //ZDSecMgrExtAddrRelease( aiOld );
   1477          }
   \   000007   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   1478          
   1479          /******************************************************************************
   1480           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1481           *
   1482           * @brief       Remove device entry by its ext address.
   1483           *
   1484           * @param       pAddr - pointer to the extended address
   1485           *
   1486           * @return      ZStatus_t
   1487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1488          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1489          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1490            ZDSecMgrEntry_t *pEntry;
   1491            uint8           retValue;
   1492            
   1493            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000A                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000A   AC..         MOV       R4,?XSP + 0
   \   00000C   AD..         MOV       R5,?XSP + 1
   \   00000E   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000011   E9           MOV       A,R1
   \   000012   FE           MOV       R6,A
   1494            
   1495            if( retValue == ZSuccess )
   \   000013   7003         JNZ       ??CrossCallReturnLabel_73
   1496            {
   1497              ZDSecMgrDeviceEntryRemove( pEntry );
   \   000015                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000015   12....       LCALL     ?Subroutine60 & 0xFFFF
   1498            }
   1499            
   1500            return retValue;
   \                     ??CrossCallReturnLabel_73:
   \   000018   EE           MOV       A,R6
   \   000019   F9           MOV       R1,A
   \   00001A   02....       LJMP      ??Subroutine99_0 & 0xFFFF
   1501          }
   1502          
   1503          /******************************************************************************
   1504           * @fn          ZDSecMgrDeviceEntryAdd
   1505           *
   1506           * @brief       Add entry.
   1507           *
   1508           * @param       device - [in] ZDSecMgrDevice_t, device info
   1509           * @param       ami    - [in] Address Manager index
   1510           *
   1511           * @return      ZStatus_t
   1512           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1513          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1514          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   1515            AddrMgrEntry_t entry;
   1516          
   1517            // get the ami data
   1518            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7402         MOV       A,#0x2
   \   000016   F0           MOVX      @DPTR,A
   1519            entry.index = ami;
   \   000017   740B         MOV       A,#0xb
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ?Subroutine13 & 0xFFFF
   1520          
   1521            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_174:
   \   00001F   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   1522          
   1523            // check if NWK address is same
   1524            if ( entry.nwkAddr != nwkAddr )
   \   000022   7401         MOV       A,#0x1
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   E0           MOVX      A,@DPTR
   \   000028   6E           XRL       A,R6
   \   000029   7003         JNZ       ??ZDSecMgrAddrMgrUpdate_0
   \   00002B   A3           INC       DPTR
   \   00002C   E0           MOVX      A,@DPTR
   \   00002D   6F           XRL       A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00002E   600F         JZ        ??ZDSecMgrAddrMgrUpdate_1
   1525            {
   1526              // update NWK address
   1527              entry.nwkAddr = nwkAddr;
   \   000030   7401         MOV       A,#0x1
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   EE           MOV       A,R6
   \   000036   F0           MOVX      @DPTR,A
   \   000037   A3           INC       DPTR
   \   000038   EF           MOV       A,R7
   \   000039   12....       LCALL     ??Subroutine106_0 & 0xFFFF
   1528          
   1529              AddrMgrEntryUpdate( &entry );
   1530            }
   \                     ??CrossCallReturnLabel_176:
   \   00003C   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   1531          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   00003F   02....       LJMP      ?Subroutine7 & 0xFFFF
   1532          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1533          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1534          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   1535            ZStatus_t        status;
   1536            ZDSecMgrEntry_t* entry;
   1537          
   1538          
   1539            // initialize as unknown until completion
   1540            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV       ?V0,#-0x38
   1541          
   1542            device->ctrl = NULL;
   \   000015   8A82         MOV       DPL,R2
   \   000017   8B83         MOV       DPH,R3
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   12....       LCALL     ?Subroutine21 & 0xFFFF
   1543          
   1544            // make sure not already registered
   1545            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_20:
   \   000024   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   000027   12....       LCALL     `??ZDSecMgrEntryLookup::?relay`; Banked call to: ZDSecMgrEntryLookup
   \   00002A   E9           MOV       A,R1
   \   00002B   7024         JNZ       ??ZDSecMgrDeviceEntryAdd_0
   1546            {
   1547              // verify that address index is same
   1548              if ( entry->ami != ami )
   \   00002D   85..82       MOV       DPL,?XSP + 0
   \   000030   85..83       MOV       DPH,?XSP + 1
   \   000033   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000036   6E           XRL       A,R6
   \   000037   7003         JNZ       ??ZDSecMgrDeviceEntryAdd_1
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   6F           XRL       A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   00003C   6024         JZ        ??CrossCallReturnLabel_60
   1549              {
   1550                // remove conflicting entry
   1551                ZDSecMgrDeviceEntryRemove( entry );
   \   00003E                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   00003E   12....       LCALL     ?Subroutine60 & 0xFFFF
   1552          
   1553                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   1554                {
   1555                  // update NWK address
   1556                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1557                }
   1558              }
   1559            }
   \                     ??CrossCallReturnLabel_74:
   \   000041                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000041   AC..         MOV       R4,?XSP + 0
   \   000043   AD..         MOV       R5,?XSP + 1
   \   000045   EE           MOV       A,R6
   \   000046   FA           MOV       R2,A
   \   000047   EF           MOV       A,R7
   \   000048   FB           MOV       R3,A
   \   000049   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   00004C   E9           MOV       A,R1
   \   00004D   7013         JNZ       ??CrossCallReturnLabel_60
   \   00004F   800E         SJMP      ??ZDSecMgrDeviceEntryAdd_2
   1560            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   000051                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000051   AC..         MOV       R4,?XSP + 0
   \   000053   AD..         MOV       R5,?XSP + 1
   \   000055   EE           MOV       A,R6
   \   000056   FA           MOV       R2,A
   \   000057   EF           MOV       A,R7
   \   000058   FB           MOV       R3,A
   \   000059   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   00005C   E9           MOV       A,R1
   \   00005D   7003         JNZ       ??CrossCallReturnLabel_60
   1561            {
   1562              // update NWK address
   1563              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   00005F                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   00005F   12....       LCALL     ?Subroutine54 & 0xFFFF
   1564            }
   1565          
   1566            // check if a new entry needs to be created
   1567            if ( entry == NULL )
   \                     ??CrossCallReturnLabel_60:
   \   000062   12....       LCALL     ??Subroutine112_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000065   701B         JNZ       ??CrossCallReturnLabel_61
   1568            {
   1569              // get new entry
   1570              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000067                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000067   AA..         MOV       R2,?XSP + 0
   \   000069   AB..         MOV       R3,?XSP + 1
   \   00006B   12....       LCALL     `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   00006E   E9           MOV       A,R1
   \   00006F   7014         JNZ       ??ZDSecMgrDeviceEntryAdd_3
   1571              {
   1572                // reset entry lkd
   1573          
   1574                // finish setting up entry
   1575                entry->ami = ami;
   \   000071   85..82       MOV       DPL,?XSP + 0
   \   000074   85..83       MOV       DPH,?XSP + 1
   \   000077   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   00007A   EE           MOV       A,R6
   \   00007B   F0           MOVX      @DPTR,A
   \   00007C   A3           INC       DPTR
   \   00007D   EF           MOV       A,R7
   \   00007E   F0           MOVX      @DPTR,A
   1576          
   1577                // update NWK address
   1578                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   00007F                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   00007F   12....       LCALL     ?Subroutine54 & 0xFFFF
   1579          
   1580                // enter new device into device control
   1581                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1582                {
   1583                  status = ZDSecMgrCtrlAdd( device, entry );
   1584                }
   1585                else
   1586                {
   1587                  status = ZSuccess;
   1588                }
   1589              }
   1590            }
   1591            else
   1592            {
   1593              // reset entry lkd
   1594          
   1595              // reset entry in entry control
   1596              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1597              {
   1598                status = ZDSecMgrCtrlReset( device, entry );
   1599              }
   1600              else
   1601              {
   1602                status = ZSuccess;
   \                     ??CrossCallReturnLabel_61:
   \   000082   75..00       MOV       ?V0,#0x0
   1603              }
   1604            }
   1605          
   1606            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000085   A9..         MOV       R1,?V0
   \   000087   7402         MOV       A,#0x2
   \   000089   02....       LJMP      ??Subroutine109_0 & 0xFFFF
   1607          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006   12....       LCALL     ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000009   12....       LCALL     `??ZDSecMgrAddrMgrUpdate::?relay`; Banked call to: ZDSecMgrAddrMgrUpdate
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   EE           MOV       A,R6
   \   000006   FA           MOV       R2,A
   \   000007   EF           MOV       A,R7
   \   000008   FB           MOV       R3,A
   \   000009   22           RET
   1608          
   1609          /******************************************************************************
   1610           * @fn          ZDSecMgrDeviceCtrlHandler
   1611           *
   1612           * @brief       Device control handler.
   1613           *
   1614           * @param       device - [in] ZDSecMgrDevice_t, device info
   1615           *
   1616           * @return      none
   1617           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1618          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1619          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1620            uint8 state;
   1621            uint8 cntr;
   1622          
   1623          
   1624            state = device->ctrl->state;
   \   000005   EA           MOV       A,R2
   \   000006   2408         ADD       A,#0x8
   \   000008   FE           MOV       R6,A
   \   000009   E4           CLR       A
   \   00000A   3B           ADDC      A,R3
   \   00000B   FF           MOV       R7,A
   \   00000C   8E82         MOV       DPL,R6
   \   00000E   F583         MOV       DPH,A
   \   000010   12....       LCALL     ??Subroutine98_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F5..         MOV       ?V0,A
   1625            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1626          
   1627            switch ( state )
   \   000016   24FE         ADD       A,#-0x2
   \   000018   600C         JZ        ??ZDSecMgrDeviceCtrlHandler_0
   \   00001A   14           DEC       A
   \   00001B   6014         JZ        ??ZDSecMgrDeviceCtrlHandler_1
   \   00001D   14           DEC       A
   \   00001E   6022         JZ        ??ZDSecMgrDeviceCtrlHandler_2
   \   000020   24FD         ADD       A,#-0x3
   \   000022   6018         JZ        ??ZDSecMgrDeviceCtrlHandler_3
   \   000024   8038         SJMP      ??ZDSecMgrDeviceCtrlHandler_4
   1628            {
   1629              case ZDSECMGR_CTRL_TK_MASTER:
   1630                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   000026                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   000026   12....       LCALL     `??ZDSecMgrSendMasterKey::?relay`; Banked call to: ZDSecMgrSendMasterKey
   \   000029   E9           MOV       A,R1
   \   00002A   7016         JNZ       ??ZDSecMgrDeviceCtrlHandler_2
   1631                {
   1632                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   00002C   75..03       MOV       ?V0,#0x3
   1633                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   00002F   8011         SJMP      ??ZDSecMgrDeviceCtrlHandler_2
   1634                }
   1635                break;
   1636          
   1637              case ZDSECMGR_CTRL_SKKE_INIT:
   1638                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   000031                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   000031   12....       LCALL     `??ZDSecMgrEstablishKey::?relay`; Banked call to: ZDSecMgrEstablishKey
   \   000034   E9           MOV       A,R1
   \   000035   700B         JNZ       ??ZDSecMgrDeviceCtrlHandler_2
   1639                {
   1640                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000037   75..04       MOV       ?V0,#0x4
   \   00003A   8006         SJMP      ??ZDSecMgrDeviceCtrlHandler_2
   1641                }
   1642                break;
   1643          
   1644              case ZDSECMGR_CTRL_SKKE_WAIT:
   1645                // continue to wait for SKA control timeout
   1646                break;
   1647          
   1648              case ZDSECMGR_CTRL_TK_NWK:
   1649                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   00003C                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00003C   12....       LCALL     `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   00003F   E9           MOV       A,R1
   \   000040   601C         JZ        ??ZDSecMgrDeviceCtrlHandler_4
   1650                {
   1651                  state = ZDSECMGR_CTRL_NONE;
   1652                }
   1653                break;
   1654          
   1655              default:
   1656                state = ZDSECMGR_CTRL_NONE;
   1657                break;
   1658            }
   1659          
   1660            if ( state != ZDSECMGR_CTRL_NONE )
   1661            {
   1662              device->ctrl->state = state;
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   000042   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   000045   E5..         MOV       A,?V0
   \   000047   12....       LCALL     ?Subroutine32 & 0xFFFF
   1663              device->ctrl->cntr  = cntr;
   \                     ??CrossCallReturnLabel_34:
   \   00004A   12....       LCALL     ?Subroutine70 & 0xFFFF
   1664          
   1665              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \                     ??CrossCallReturnLabel_88:
   \   00004D                ; Setup parameters for call to function osal_start_timerEx
   \   00004D   7C64         MOV       R4,#0x64
   \   00004F   7D00         MOV       R5,#0x0
   \   000051   7A00         MOV       R2,#0x0
   \   000053   FB           MOV       R3,A
   \   000054   90....       MOV       DPTR,#ZDAppTaskID
   \   000057   E0           MOVX      A,@DPTR
   \   000058   F9           MOV       R1,A
   \   000059   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00005C   8005         SJMP      ??ZDSecMgrDeviceCtrlHandler_5
   1666            }
   1667            else
   1668            {
   1669              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   00005E   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000061   E4           CLR       A
   \   000062   F0           MOVX      @DPTR,A
   1670            }
   1671          }
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   000063   02....       LJMP      ??Subroutine101_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine98_0
   \   000004                ; // Fall through to label ??Subroutine98_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine98_0:
   \   000000   12....       LCALL     ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   C8           XCH       A,R0
   \   000001   2406         ADD       A,#0x6
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   38           ADDC      A,R0
   \   000007   F583         MOV       DPH,A
   \   000009   7401         MOV       A,#0x1
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   12....       LCALL     ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   22           RET
   1672          
   1673          /******************************************************************************
   1674           * @fn          ZDSecMgrDeviceCtrlSetup
   1675           *
   1676           * @brief       Setup device control.
   1677           *
   1678           * @param       device - [in] ZDSecMgrDevice_t, device info
   1679           *
   1680           * @return      ZStatus_t
   1681           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1682          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1683          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1684            if ( device->ctrl != NULL )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000013   6022         JZ        ??ZDSecMgrDeviceCtrlSetup_0
   1685            {
   1686              if ( device->secure == FALSE )
   \   000015   E8           MOV       A,R0
   \   000016   2405         ADD       A,#0x5
   \   000018   F8           MOV       R0,A
   \   000019   5001         JNC       ??ZDSecMgrDeviceCtrlSetup_1
   \   00001B   09           INC       R1
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   00001C   8A82         MOV       DPL,R2
   \   00001E   8B83         MOV       DPH,R3
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   A3           INC       DPTR
   \   000026   E0           MOVX      A,@DPTR
   \   000027   8882         MOV       DPL,R0
   \   000029   8983         MOV       DPH,R1
   \   00002B   7004         JNZ       ??ZDSecMgrDeviceCtrlSetup_2
   1687              {
   1688                // send the master key data to the joining device
   1689                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002D   7402         MOV       A,#0x2
   \   00002F   8002         SJMP      ??ZDSecMgrDeviceCtrlSetup_3
   1690              }
   1691              else
   1692              {
   1693                // start SKKE
   1694                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   000031   7403         MOV       A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_3:
   \   000033   F0           MOVX      @DPTR,A
   1695              }
   1696          
   1697              ZDSecMgrDeviceCtrlHandler( device );
   \   000034                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000034   12....       LCALL     `??ZDSecMgrDeviceCtrlHandler::?relay`; Banked call to: ZDSecMgrDeviceCtrlHandler
   1698            }
   1699          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   000037   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   1700          
   1701          /******************************************************************************
   1702           * @fn          ZDSecMgrDeviceCtrlUpdate
   1703           *
   1704           * @brief       Update control data.
   1705           *
   1706           * @param       extAddr - [in] EXT address
   1707           * @param       state   - [in] new control state
   1708           *
   1709           * @return      none
   1710           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1711          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1712          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   1713            ZDSecMgrEntry_t* entry;
   1714            ZDSecMgrCtrl_t*  ctrl;
   1715          
   1716          
   1717            // lookup device entry data
   1718            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV       A,#0x2
   \   00000E   12....       LCALL     ?XSTACK_DISP102_8
   \   000011   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   1719          
   1720            if ( entry != NULL )
   \   000014   7402         MOV       A,#0x2
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   00001C   6045         JZ        ??CrossCallReturnLabel_89
   1721            {
   1722              // lookup device control data
   1723              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   00001E                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   00001E   AC..         MOV       R4,?XSP + 0
   \   000020   AD..         MOV       R5,?XSP + 1
   \   000022   7402         MOV       A,#0x2
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   00002A   12....       LCALL     ?Subroutine41 & 0xFFFF
   1724          
   1725              // make sure control data is valid
   1726              if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_197:
   \   00002D   6034         JZ        ??CrossCallReturnLabel_89
   1727              {
   1728                // possible state transitions
   1729                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   00002F   85..82       MOV       DPL,?XSP + 0
   \   000032   85..83       MOV       DPH,?XSP + 1
   \   000035   E0           MOVX      A,@DPTR
   \   000036   2405         ADD       A,#0x5
   \   000038   F8           MOV       R0,A
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   3400         ADDC      A,#0x0
   \   00003D   8882         MOV       DPL,R0
   \   00003F   F583         MOV       DPH,A
   \   000041   E0           MOVX      A,@DPTR
   \   000042   6404         XRL       A,#0x4
   \   000044   701D         JNZ       ??CrossCallReturnLabel_89
   1730                {
   1731                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   000046   7405         MOV       A,#0x5
   \   000048   6E           XRL       A,R6
   \   000049   7004         JNZ       ??ZDSecMgrDeviceCtrlUpdate_0
   1732                  {
   1733                    // send the network key
   1734                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   00004B   7407         MOV       A,#0x7
   \   00004D   8007         SJMP      ??ZDSecMgrDeviceCtrlUpdate_1
   1735                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1736                  }
   1737                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   00004F   7406         MOV       A,#0x6
   \   000051   6E           XRL       A,R6
   \   000052   700F         JNZ       ??CrossCallReturnLabel_89
   1738                  {
   1739                    // force default timeout in order to cleanup control logic
   1740                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   000054   7406         MOV       A,#0x6
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   000056   F0           MOVX      @DPTR,A
   1741                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   000057   85..82       MOV       DPL,?XSP + 0
   \   00005A   85..83       MOV       DPH,?XSP + 1
   \   00005D   12....       LCALL     ?Subroutine86 & 0xFFFF
   1742                  }
   1743                }
   1744                // timer should be active
   1745              }
   1746            }
   \                     ??CrossCallReturnLabel_255:
   \   000060   12....       LCALL     ?Subroutine70 & 0xFFFF
   1747          }
   \                     ??CrossCallReturnLabel_89:
   \   000063                REQUIRE ?Subroutine8
   \   000063                ; // Fall through to label ?Subroutine8

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7404         MOV       A,#0x4
   \   000002   80..         SJMP      ??Subroutine100_0
   1748          
   1749          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1750          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1751          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1752            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1753            {
   1754              if ( initiator == TRUE )
   1755              {
   1756                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1757              }
   1758            }
   1759          }
   \   000000   02....       LJMP      ?BRET
   1760          
   1761          /******************************************************************************
   1762           * @fn          ZDSecMgrDeviceRemove
   1763           *
   1764           * @brief       Remove device from network.
   1765           *
   1766           * @param       device - [in] ZDSecMgrDevice_t, device info
   1767           *
   1768           * @return      none
   1769           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1770          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1771          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1772            APSME_RemoveDeviceReq_t remDevReq;
   1773            NLME_LeaveReq_t         leaveReq;
   1774            associated_devices_t*   assoc;
   1775          
   1776          
   1777            // check if parent, remove the device
   1778            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000011   8A..         MOV       ?V0,R2
   \   000013   8B..         MOV       ?V1,R3
   \   000015   8E82         MOV       DPL,R6
   \   000017   8F83         MOV       DPH,R7
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000020   EE           MOV       A,R6
   \   000021   2402         ADD       A,#0x2
   \   000023   F8           MOV       R0,A
   \   000024   E4           CLR       A
   \   000025   3F           ADDC      A,R7
   \   000026   F9           MOV       R1,A
   \   000027   E5..         MOV       A,?V0
   \   000029   6A           XRL       A,R2
   \   00002A   7003         JNZ       ??ZDSecMgrDeviceRemove_0
   \   00002C   E5..         MOV       A,?V1
   \   00002E   6B           XRL       A,R3
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00002F   7056         JNZ       ??ZDSecMgrDeviceRemove_1
   1779            {
   1780              // this is the parent of the device
   1781              leaveReq.extAddr        = device->extAddr;
   \   000031   8882         MOV       DPL,R0
   \   000033   8983         MOV       DPH,R1
   \   000035   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000038   12....       LCALL     ?Subroutine26 & 0xFFFF
   1782              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_155:
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   E4           CLR       A
   \   00003F   F0           MOVX      @DPTR,A
   1783              leaveReq.rejoin         = FALSE;
   \   000040   7403         MOV       A,#0x3
   \   000042   12....       LCALL     ?XSTACK_DISP0_8
   \   000045   E4           CLR       A
   \   000046   12....       LCALL     ?Subroutine75 & 0xFFFF
   1784          
   1785              // find child association
   1786              assoc = AssocGetWithExt( device->extAddr );
   \                     ??CrossCallReturnLabel_99:
   \   000049   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   00004C   8B..         MOV       ?V1,R3
   \   00004E   A9..         MOV       R1,?V1
   1787          
   1788              if ( ( assoc != NULL                            ) &&
   1789                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1790                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   000050   EA           MOV       A,R2
   \   000051   49           ORL       A,R1
   \   000052   604E         JZ        ??ZDSecMgrDeviceRemove_2
   \   000054   8A82         MOV       DPL,R2
   \   000056   8B83         MOV       DPH,R3
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   6043         JZ        ??ZDSecMgrDeviceRemove_2
   \   00005F   C3           CLR       C
   \   000060   9405         SUBB      A,#0x5
   \   000062   503E         JNC       ??ZDSecMgrDeviceRemove_2
   1791              {
   1792                // check if associated device is authenticated
   1793                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   000064   8A82         MOV       DPL,R2
   \   000066   8B83         MOV       DPH,R3
   \   000068   A3           INC       DPTR
   \   000069   A3           INC       DPTR
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   A3           INC       DPTR
   \   00006D   E0           MOVX      A,@DPTR
   \   00006E   A2E3         MOV       C,0xE0 /* A   */.3
   \   000070   7404         MOV       A,#0x4
   \   000072   5006         JNC       ??ZDSecMgrDeviceRemove_3
   1794                {
   1795                  leaveReq.silent = FALSE;
   \   000074   12....       LCALL     ?XSTACK_DISP0_8
   \   000077   E4           CLR       A
   \   000078   8005         SJMP      ??ZDSecMgrDeviceRemove_4
   1796                }
   1797                else
   1798                {
   1799                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   00007A   12....       LCALL     ?XSTACK_DISP0_8
   \   00007D   7401         MOV       A,#0x1
   1800                }
   1801          
   1802                NLME_LeaveReq( &leaveReq );
   1803              }
   1804            }
   \                     ??ZDSecMgrDeviceRemove_4:
   \   00007F   12....       LCALL     ??Subroutine106_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   000082   12....       LCALL     `??NLME_LeaveReq::?relay`; Banked call to: NLME_LeaveReq
   \   000085   801B         SJMP      ??ZDSecMgrDeviceRemove_2
   1805            else
   1806            {
   1807              // this is not the parent of the device
   1808              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   000087   7405         MOV       A,#0x5
   \   000089   12....       LCALL     ?XSTACK_DISP0_8
   \   00008C   EA           MOV       A,R2
   \   00008D   F0           MOVX      @DPTR,A
   \   00008E   A3           INC       DPTR
   \   00008F   EB           MOV       A,R3
   \   000090   12....       LCALL     ?Subroutine30 & 0xFFFF
   1809              remDevReq.childExtAddr = device->extAddr;
   1810          
   1811              APSME_RemoveDeviceReq( &remDevReq );
   1812            }
   \                     ??CrossCallReturnLabel_31:
   \   000093   F9           MOV       R1,A
   \   000094   7407         MOV       A,#0x7
   \   000096   12....       LCALL     ?XSTACK_DISP0_8
   \   000099   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   00009C   12....       LCALL     ?XSTACK_DISP101_8
   \   00009F   12....       LCALL     `??APSME_RemoveDeviceReq::?relay`; Banked call to: APSME_RemoveDeviceReq
   1813          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   0000A2   7409         MOV       A,#0x9
   \   0000A4   02....       LJMP      ??Subroutine114_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine102_0
   \   000006                ; // Fall through to label ??Subroutine102_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine102_0:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   7402         MOV       A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL     ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000003   12....       LCALL     ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   12....       LCALL     ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000003   12....       LCALL     `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   000006   22           RET
   1814          
   1815          /******************************************************************************
   1816           * @fn          ZDSecMgrDeviceValidateSKKE
   1817           *
   1818           * @brief       Decide whether device is allowed for SKKE.
   1819           *
   1820           * @param       device - [in] ZDSecMgrDevice_t, device info
   1821           *
   1822           * @return      ZStatus_t
   1823           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1824          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1825          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1826            ZStatus_t status;
   1827            uint16 ami;
   1828            uint16 keyNvId;
   1829          
   1830          
   1831            // get EXT address
   1832            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   8A82         MOV       DPL,R2
   \   000014   F583         MOV       DPH,A
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   00001B   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   00001E   E9           MOV       A,R1
   \   00001F   F9           MOV       R1,A
   1833          
   1834            if ( status == ZSuccess )
   \   000020   700F         JNZ       ??ZDSecMgrDeviceValidateSKKE_0
   1835            {
   1836              // get MASTER key
   1837              status = ZDSecMgrMasterKeyLookup( ami, &keyNvId );
   \   000022                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000022   7402         MOV       A,#0x2
   \   000024   12....       LCALL     ?XSTACK_DISP102_8
   \   000027   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   00002A   F9           MOV       R1,A
   1838          
   1839              if ( status == ZSuccess )
   \   00002B   7004         JNZ       ??ZDSecMgrDeviceValidateSKKE_0
   1840              {
   1841                status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00002D                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00002D   12....       LCALL     ?Subroutine55 & 0xFFFF
   1842              }
   1843            }
   \                     ??CrossCallReturnLabel_62:
   \   000030   F9           MOV       R1,A
   1844          
   1845            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   000031   02....       LJMP      ?Subroutine8 & 0xFFFF
   1846          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   12....       LCALL     ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000009   12....       LCALL     `??ZDSecMgrDeviceEntryAdd::?relay`; Banked call to: ZDSecMgrDeviceEntryAdd
   \   00000C   E9           MOV       A,R1
   \   00000D   22           RET
   1847          
   1848          /******************************************************************************
   1849           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1850           *
   1851           * @brief       Decide whether device is allowed.
   1852           *
   1853           * @param       device - [in] ZDSecMgrDevice_t, device info
   1854           *
   1855           * @return      ZStatus_t
   1856           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1857          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1858          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1859          
   1860            ZStatus_t status;
   1861            status = ZSuccess;
   \   000004   7900         MOV       R1,#0x0
   1862          
   1863            (void)device;  // Intentionally unreferenced parameter
   1864            
   1865            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1866            // the trust center to reject any newly joining devices by sending
   1867            // Remove-device to the parents.
   1868            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV       DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   7002         JNZ       ??ZDSecMgrDeviceValidateRM_0
   1869            {
   1870              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV       R1,#-0x38
   1871            }
   1872          
   1873          
   1874          
   1875          #if 0  // Taken out because the following functionality is only used for test
   1876                 // purpose. A more efficient (above) way is used. It can be put
   1877                 // back in if customers request for a white/black list feature.
   1878                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1879          
   1880            // The following code processes the device black list (stored device list)
   1881            // If the joining device is not part of the forbidden device list
   1882            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1883            // will send Remove-device and ban the device from joining.
   1884          
   1885            uint8     index;
   1886            uint8*    restricted;
   1887          
   1888            // Look through the stored device list - used for restricted devices
   1889            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1890            {
   1891              restricted = ZDSecMgrStoredDeviceList[index];
   1892          
   1893              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1894              {
   1895                // return as unknown device in regards to validation
   1896                status = ZNwkUnknownDevice;
   1897          
   1898                // break from loop
   1899                index = ZDSECMGR_STORED_DEVICES;
   1900              }
   1901            }
   1902          
   1903          #endif
   1904          
   1905            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   1906          }
   1907          
   1908          /******************************************************************************
   1909           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1910           *
   1911           * @brief       Decide whether device is allowed.
   1912           *
   1913           * @param       device - [in] ZDSecMgrDevice_t, device info
   1914           *
   1915           * @return      ZStatus_t
   1916           */
   1917          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1918          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1919          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1920            ZStatus_t status;
   1921            uint16    ami;
   1922            uint8     key[SEC_KEY_LEN];
   1923          
   1924          
   1925            // implement EXT address and MASTER key policy here -- the total number of
   1926            // Security Manager entries should never exceed the number of EXT addresses
   1927            // and MASTER keys available
   1928            
   1929            // set status based on policy
   1930            //status = ZNwkUnknownDevice;
   1931            
   1932            // set status based on policy
   1933            status = ZSuccess; // ZNwkUnknownDevice;
   1934            
   1935            // get key based on policy
   1936            osal_memcpy( key, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   00000E                ; Setup parameters for call to function osal_memcpy
   \   00000E   75....       MOV       ?V0,#ZDSecMgrTCMasterKey & 0xff
   \   000011   75....       MOV       ?V1,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   000014   75..80       MOV       ?V2,#-0x80
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00001C   7C10         MOV       R4,#0x10
   \   00001E   7D00         MOV       R5,#0x0
   \   000020   7405         MOV       A,#0x5
   \   000022   12....       LCALL     ?XSTACK_DISP101_8
   \   000025   12....       LCALL     ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000028   12....       LCALL     ?DEALLOC_XSTACK8
   1937            
   1938            // if policy, store new EXT address
   1939            status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00002B   EE           MOV       A,R6
   \   00002C   2402         ADD       A,#0x2
   \   00002E   F5..         MOV       ?V0,A
   \   000030   E4           CLR       A
   \   000031   3F           ADDC      A,R7
   \   000032   F5..         MOV       ?V1,A
   \   000034                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000034   A8..         MOV       R0,?XSP + 0
   \   000036   A9..         MOV       R1,?XSP + 1
   \   000038   88..         MOV       ?V2,R0
   \   00003A   89..         MOV       ?V3,R1
   \   00003C   78..         MOV       R0,#?V2
   \   00003E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000041   85..82       MOV       DPL,?V0
   \   000044   85..83       MOV       DPH,?V1
   \   000047   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   00004A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00004D   E9           MOV       A,R1
   \   00004E   F5..         MOV       ?V2,A
   1940            
   1941            // set the key
   1942            ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   000050                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   000050   7402         MOV       A,#0x2
   \   000052   12....       LCALL     ?XSTACK_DISP102_8
   \   000055   85..82       MOV       DPL,?V0
   \   000058   85..83       MOV       DPH,?V1
   \   00005B   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   00005E   12....       LCALL     `??ZDSecMgrMasterKeyLoad::?relay`; Banked call to: ZDSecMgrMasterKeyLoad
   1943            
   1944            // if EXT address and MASTER key available -- add device
   1945            if ( status == ZSuccess )
   \   000061   E5..         MOV       A,?V2
   \   000063   7005         JNZ       ??ZDSecMgrDeviceValidateCM_0
   1946            {
   1947              // add device to internal data - with control
   1948              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000065                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000065   12....       LCALL     ?Subroutine55 & 0xFFFF
   1949            }
   \                     ??CrossCallReturnLabel_63:
   \   000068   F5..         MOV       ?V2,A
   1950          
   1951            // remove copy of key in RAM  
   1952            osal_memset( key, 0x00, SEC_KEY_LEN );
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   00006A                ; Setup parameters for call to function osal_memset
   \   00006A   7C10         MOV       R4,#0x10
   \   00006C   7D00         MOV       R5,#0x0
   \   00006E   7900         MOV       R1,#0x0
   \   000070   7402         MOV       A,#0x2
   \   000072   12....       LCALL     ?XSTACK_DISP101_8
   \   000075   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1953          
   1954            return status;
   \   000078   A9..         MOV       R1,?V2
   \   00007A   02....       LJMP      ?Subroutine0 & 0xFFFF
   1955          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   8E82         MOV       DPL,R6
   \   000007   8F83         MOV       DPH,R7
   \   000009   12....       LCALL     ??Subroutine128_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   00000C   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   00000F   7402         MOV       A,#0x2
   \   000011   22           RET
   1956          
   1957          /******************************************************************************
   1958           * @fn          ZDSecMgrDeviceValidate
   1959           *
   1960           * @brief       Decide whether device is allowed.
   1961           *
   1962           * @param       device - [in] ZDSecMgrDevice_t, device info
   1963           *
   1964           * @return      ZStatus_t
   1965           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1966          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1967          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1968            ZStatus_t status;
   1969          
   1970          
   1971            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6401         XRL       A,#0x1
   \   00000A   7020         JNZ       ??ZDSecMgrDeviceValidate_0
   1972            {
   1973              // device may be joining with a secure flag but it is ultimately the Trust
   1974              // Center that decides -- check if expected pre configured device --
   1975              // override settings
   1976              if ( zgPreConfigKeys == TRUE )
   \   00000C   EA           MOV       A,R2
   \   00000D   2406         ADD       A,#0x6
   \   00000F   F8           MOV       R0,A
   \   000010   E4           CLR       A
   \   000011   3B           ADDC      A,R3
   \   000012   F9           MOV       R1,A
   \   000013   90....       MOV       DPTR,#zgPreConfigKeys
   \   000016   E0           MOVX      A,@DPTR
   \   000017   6401         XRL       A,#0x1
   \   000019   8882         MOV       DPL,R0
   \   00001B   8983         MOV       DPH,R1
   \   00001D   7004         JNZ       ??ZDSecMgrDeviceValidate_1
   1977              {
   1978                device->secure = TRUE;
   \   00001F   7401         MOV       A,#0x1
   \   000021   8001         SJMP      ??ZDSecMgrDeviceValidate_2
   1979              }
   1980              else
   1981              {
   1982                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000023   E4           CLR       A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000024   F0           MOVX      @DPTR,A
   1983              }
   1984          
   1985              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1986              {
   1987                status = ZDSecMgrDeviceValidateCM( device );
   1988              }
   1989              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1990              {
   1991                status = ZDSecMgrDeviceValidateRM( device );
   \   000025                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000025   12....       LCALL     `??ZDSecMgrDeviceValidateRM::?relay`; Banked call to: ZDSecMgrDeviceValidateRM
   \   000028   E9           MOV       A,R1
   \   000029   F9           MOV       R1,A
   \   00002A   8002         SJMP      ??ZDSecMgrDeviceValidate_3
   1992              }
   1993            }
   1994            else
   1995            {
   1996              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00002C   79C8         MOV       R1,#-0x38
   1997            }
   1998          
   1999            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002E   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   2000          }
   2001          
   2002          /******************************************************************************
   2003           * @fn          ZDSecMgrDeviceJoin
   2004           *
   2005           * @brief       Try to join this device.
   2006           *
   2007           * @param       device - [in] ZDSecMgrDevice_t, device info
   2008           *
   2009           * @return      ZStatus_t
   2010           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2011          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2012          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2013            ZStatus_t status;
   2014            uint16    ami;
   2015          
   2016            // attempt to validate device
   2017            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   12....       LCALL     `??ZDSecMgrDeviceValidate::?relay`; Banked call to: ZDSecMgrDeviceValidate
   \   000011   E9           MOV       A,R1
   \   000012   F5..         MOV       ?V0,A
   2018          
   2019            if ( status == ZSuccess )
   \   000014   7025         JNZ       ??ZDSecMgrDeviceJoin_0
   2020            {
   2021              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2022              {
   2023                ZDSecMgrDeviceCtrlSetup( device );
   2024              }
   2025              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2026              {
   2027                // Add the device to the address manager
   2028                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000016                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000016   A8..         MOV       R0,?XSP + 0
   \   000018   A9..         MOV       R1,?XSP + 1
   \   00001A   88..         MOV       ?V0,R0
   \   00001C   89..         MOV       ?V1,R1
   \   00001E   78..         MOV       R0,#?V0
   \   000020   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000023   8E82         MOV       DPL,R6
   \   000025   8F83         MOV       DPH,R7
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   00002C   12....       LCALL     ?DEALLOC_XSTACK8
   2029                //send the nwk key data to the joining device
   2030                status = ZDSecMgrSendNwkKey( device );
   \   00002F                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00002F   EE           MOV       A,R6
   \   000030   FA           MOV       R2,A
   \   000031   EF           MOV       A,R7
   \   000032   FB           MOV       R3,A
   \   000033   12....       LCALL     `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   000036   E9           MOV       A,R1
   \   000037   F5..         MOV       ?V0,A
   \   000039   8007         SJMP      ??ZDSecMgrDeviceJoin_1
   2031              }
   2032            }
   2033            else
   2034            {
   2035              // not allowed, remove the device
   2036              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   00003B                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00003B   EE           MOV       A,R6
   \   00003C   FA           MOV       R2,A
   \   00003D   EF           MOV       A,R7
   \   00003E   FB           MOV       R3,A
   \   00003F   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2037            }
   2038          
   2039            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000042   A9..         MOV       R1,?V0
   \   000044   02....       LJMP      ?Subroutine5 & 0xFFFF
   2040          }
   2041          
   2042          /******************************************************************************
   2043           * @fn          ZDSecMgrDeviceJoinDirect
   2044           *
   2045           * @brief       Try to join this device as a direct child.
   2046           *
   2047           * @param       device - [in] ZDSecMgrDevice_t, device info
   2048           *
   2049           * @return      ZStatus_t
   2050           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2051          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2052          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   2053            ZStatus_t status;
   2054          
   2055            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL     `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   \   00000C   E9           MOV       A,R1
   \   00000D   F5..         MOV       ?V0,A
   2056          
   2057            if ( status == ZSuccess )
   \   00000F   7009         JNZ       ??ZDSecMgrDeviceJoinDirect_0
   2058            {
   2059              // set association status to authenticated
   2060              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   12....       LCALL     ?Subroutine62 & 0xFFFF
   2061            }
   \                     ??CrossCallReturnLabel_172:
   \   000014   12....       LCALL     `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   000017   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2062          
   2063            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001A   A9..         MOV       R1,?V0
   \   00001C   02....       LJMP      ??Subroutine101_0 & 0xFFFF
   2064          }
   2065          
   2066          /******************************************************************************
   2067           * @fn          ZDSecMgrDeviceJoinFwd
   2068           *
   2069           * @brief       Forward join to Trust Center.
   2070           *
   2071           * @param       device - [in] ZDSecMgrDevice_t, device info
   2072           *
   2073           * @return      ZStatus_t
   2074           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2075          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2076          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV       A,#-0x8
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   2077            ZStatus_t               status;
   2078            APSME_UpdateDeviceReq_t req;
   2079          
   2080          
   2081            // forward any joining device to the Trust Center -- the Trust Center will
   2082            // decide if the device is allowed to join
   2083            status = ZSuccess;
   2084          
   2085            // forward authorization to the Trust Center
   2086            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   E4           CLR       A
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   F0           MOVX      @DPTR,A
   2087            req.devAddr    = device->nwkAddr;
   \   000013   8A82         MOV       DPL,R2
   \   000015   8B83         MOV       DPH,R3
   \   000017   12....       LCALL     ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   12....       LCALL     ?Subroutine15 & 0xFFFF
   2088            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_7:
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   2089          
   2090            // set security status, option for router to reject if policy set
   2091            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_221:
   \   000026   EA           MOV       A,R2
   \   000027   2407         ADD       A,#0x7
   \   000029   F582         MOV       DPL,A
   \   00002B   E4           CLR       A
   \   00002C   3B           ADDC      A,R3
   \   00002D   F583         MOV       DPH,A
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   A2E7         MOV       C,0xE0 /* A   */.7
   \   000032   502E         JNC       ??ZDSecMgrDeviceJoinFwd_0
   2092            {
   2093              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000034   A2E6         MOV       C,0xE0 /* A   */.6
   \   000036   5021         JNC       ??ZDSecMgrDeviceJoinFwd_1
   2094              {
   2095                if ( device->secure == TRUE )
   \   000038   8A82         MOV       DPL,R2
   \   00003A   8B83         MOV       DPH,R3
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   E0           MOVX      A,@DPTR
   \   000043   6401         XRL       A,#0x1
   \   000045   7009         JNZ       ??ZDSecMgrDeviceJoinFwd_2
   2096                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000047   7406         MOV       A,#0x6
   \   000049   12....       LCALL     ?XSTACK_DISP0_8
   \   00004C   7404         MOV       A,#0x4
   \   00004E   803D         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2097                else
   2098                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   000050   7406         MOV       A,#0x6
   \   000052   12....       LCALL     ?XSTACK_DISP0_8
   \   000055   7407         MOV       A,#0x7
   \   000057   8034         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2099              }
   2100              else
   2101                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000059   7406         MOV       A,#0x6
   \   00005B   12....       LCALL     ?XSTACK_DISP0_8
   \   00005E   7405         MOV       A,#0x5
   \   000060   802B         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2102            }
   2103            else
   2104            {
   2105              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000062   A2E6         MOV       C,0xE0 /* A   */.6
   \   000064   5020         JNC       ??ZDSecMgrDeviceJoinFwd_4
   2106              {
   2107                if ( device->secure == TRUE )
   \   000066   8A82         MOV       DPL,R2
   \   000068   8B83         MOV       DPH,R3
   \   00006A   A3           INC       DPTR
   \   00006B   A3           INC       DPTR
   \   00006C   A3           INC       DPTR
   \   00006D   A3           INC       DPTR
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   E0           MOVX      A,@DPTR
   \   000071   6401         XRL       A,#0x1
   \   000073   7008         JNZ       ??ZDSecMgrDeviceJoinFwd_5
   2108                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   000075   7406         MOV       A,#0x6
   \   000077   12....       LCALL     ?XSTACK_DISP0_8
   \   00007A   E4           CLR       A
   \   00007B   8010         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2109                else
   2110                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   00007D   7406         MOV       A,#0x6
   \   00007F   12....       LCALL     ?XSTACK_DISP0_8
   \   000082   7403         MOV       A,#0x3
   \   000084   8007         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2111              }
   2112              else
   2113                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000086   7406         MOV       A,#0x6
   \   000088   12....       LCALL     ?XSTACK_DISP0_8
   \   00008B   7401         MOV       A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   00008D   F0           MOVX      @DPTR,A
   2114            }
   2115          
   2116            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2117              req.apsSecure = TRUE;
   2118            else
   2119              req.apsSecure = FALSE;
   \   00008E   7407         MOV       A,#0x7
   \   000090   12....       LCALL     ?XSTACK_DISP0_8
   \   000093   E4           CLR       A
   \   000094   12....       LCALL     ??Subroutine106_0 & 0xFFFF
   2120          
   2121            // send and APSME_UPDATE_DEVICE request to the trust center
   2122            status = APSME_UpdateDeviceReq( &req );
   2123          
   2124            return status;
   \                     ??CrossCallReturnLabel_178:
   \   000097   12....       LCALL     `??APSME_UpdateDeviceReq::?relay`; Banked call to: APSME_UpdateDeviceReq
   \   00009A   7408         MOV       A,#0x8
   \   00009C   02....       LJMP      ??Subroutine93_0 & 0xFFFF
   2125          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000003   8A82         MOV       DPL,R2
   \   000005   8B83         MOV       DPH,R3
   \   000007   12....       LCALL     ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   00000A   7404         MOV       A,#0x4
   \   00000C   22           RET
   2126          
   2127          /******************************************************************************
   2128           * @fn          ZDSecMgrDeviceNew
   2129           *
   2130           * @brief       Process a new device.
   2131           *
   2132           * @param       device - [in] ZDSecMgrDevice_t, device info
   2133           *
   2134           * @return      ZStatus_t
   2135           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2136          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2137          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2138            ZStatus_t status;
   2139          
   2140            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2141            {
   2142              // try to join this device
   2143              status = ZDSecMgrDeviceJoinDirect( joiner );
   2144            }
   2145            else
   2146            {
   2147              status = ZDSecMgrDeviceJoinFwd( joiner );
   2148            }
   2149          
   2150            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000004   12....       LCALL     `??ZDSecMgrDeviceJoinFwd::?relay`; Banked call to: ZDSecMgrDeviceJoinFwd
   \   000007   80..         SJMP      ??Subroutine105_0
   2151          }
   2152          
   2153          /******************************************************************************
   2154           * @fn          ZDSecMgrAssocDeviceAuth
   2155           *
   2156           * @brief       Set associated device status to authenticated
   2157           *
   2158           * @param       assoc - [in, out] associated_devices_t
   2159           *
   2160           * @return      none
   2161           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2162          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2163          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2164            if ( assoc != NULL )
   \   000004   EA           MOV       A,R2
   \   000005   4B           ORL       A,R3
   \   000006   600D         JZ        ??ZDSecMgrAssocDeviceAuth_0
   2165            {
   2166              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   D2E3         SETB      0xE0 /* A   */.3
   \   000014   F0           MOVX      @DPTR,A
   2167            }
   2168          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   80..         SJMP      ??Subroutine105_0
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrAuthInitiate
   2172           *
   2173           * @brief       Initiate entity authentication
   2174           *
   2175           * @param       responder - [in] responder EXT address
   2176           *
   2177           * @return      none
   2178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2179          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2180          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2181            APSME_AuthenticateReq_t req;
   2182          
   2183          
   2184            // make sure NWK address is available
   2185            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000015   E9           MOV       A,R1
   \   000016   601F         JZ        ??ZDSecMgrAuthInitiate_0
   2186            {
   2187              // set request fields
   2188              req.extAddr   = responder;
   \   000018   7402         MOV       A,#0x2
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   EE           MOV       A,R6
   \   00001E   F0           MOVX      @DPTR,A
   \   00001F   A3           INC       DPTR
   \   000020   EF           MOV       A,R7
   \   000021   F0           MOVX      @DPTR,A
   2189              req.action    = APSME_EA_INITIATE;
   \   000022   7406         MOV       A,#0x6
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   E4           CLR       A
   \   000028   F0           MOVX      @DPTR,A
   2190              req.challenge = NULL;
   \   000029   7404         MOV       A,#0x4
   \   00002B   12....       LCALL     ?XSTACK_DISP0_8
   \   00002E   E4           CLR       A
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   A3           INC       DPTR
   \   000031   12....       LCALL     ??Subroutine106_0 & 0xFFFF
   2191          
   2192              // start EA processing
   2193              APSME_AuthenticateReq( &req );
   2194            }
   \                     ??CrossCallReturnLabel_179:
   \   000034   12....       LCALL     `??APSME_AuthenticateReq::?relay`; Banked call to: APSME_AuthenticateReq
   2195          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   000037   7407         MOV       A,#0x7
   \   000039   02....       LJMP      ??Subroutine100_0 & 0xFFFF
   2196          
   2197          /******************************************************************************
   2198           * @fn          ZDSecMgrAuthNwkKey
   2199           *
   2200           * @brief       Handle next step in authentication process
   2201           *
   2202           * @param       none
   2203           *
   2204           * @return      none
   2205           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2206          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2207          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2208            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV       DPTR,#devState
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6405         XRL       A,#0x5
   \   00000A   700C         JNZ       ??ZDSecMgrAuthNwkKey_0
   2209            {
   2210              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2211              {
   2212                uint8 parent[Z_EXTADDR_LEN];
   2213          
   2214                // get parent's EXT address
   2215                NLME_GetCoordExtAddr( parent );
   2216          
   2217                // begin entity authentication with parent
   2218                ZDSecMgrAuthInitiate( parent );
   2219              }
   2220              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2221              {
   2222                // inform ZDO that device has been authenticated
   2223                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV       R2,#-0x80
   \   00000E   7B00         MOV       R3,#0x0
   \   000010   90....       MOV       DPTR,#ZDAppTaskID
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F9           MOV       R1,A
   \   000015   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   2224              }
   2225            }
   2226          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   2227          
   2228          /******************************************************************************
   2229           * PUBLIC FUNCTIONS
   2230           */
   2231          /******************************************************************************
   2232           * @fn          ZDSecMgrInit
   2233           *
   2234           * @brief       Initialize ZigBee Device Security Manager.
   2235           *
   2236           * @param       state - device initialization state
   2237           *
   2238           * @return      none
   2239           */
   2240          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2241          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2242          void ZDSecMgrAddrMgrCB( uint8           update,
   2243                                  AddrMgrEntry_t* newEntry,
   2244                                  AddrMgrEntry_t* oldEntry )
   2245          {
   2246            (void)update;
   2247            (void)newEntry;
   2248            (void)oldEntry;
   2249          }
   2250          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2251          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL     `??APSME_SecurityNM::?relay`; Banked call to: APSME_SecurityNM
   \   000007                REQUIRE ??Subroutine105_0
   \   000007                ; // Fall through to label ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2252          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   \   000000   02....       LJMP      ?Subroutine3 & 0xFFFF
   2253          {
   2254            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2255                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2256            {
   2257              // initialize sub modules
   2258              ZDSecMgrEntryInit(state);
   2259          
   2260              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2261              {
   2262                ZDSecMgrCtrlInit();
   2263              }
   2264          
   2265              // register with Address Manager
   2266              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2267              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2268              #endif
   2269            }
   2270          
   2271            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2272            {
   2273              // configure SKA slot data
   2274              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2275            }
   2276            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2277            {
   2278              APSME_TCAddrSetup( zgTrustCenterAddr );    
   2279            }
   2280          
   2281            if ( ZG_SECURE_ENABLED )
   2282            {
   2283              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2284              {
   2285                // setup joining permissions
   2286                ZDSecMgrPermitJoiningEnabled = TRUE;
   2287                ZDSecMgrPermitJoiningTimed   = FALSE;
   2288              }
   2289            }
   2290          
   2291            
   2292            // configure security based on security mode and type of device
   2293            ZDSecMgrConfig();
   2294          }
   2295          
   2296          /******************************************************************************
   2297           * @fn          ZDSecMgrConfig
   2298           *
   2299           * @brief       Configure ZigBee Device Security Manager.
   2300           *
   2301           * @param       none
   2302           *
   2303           * @return      none
   2304           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2305          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   \   000000   02....       LJMP      ?Subroutine3 & 0xFFFF
   2306          {
   2307            if ( ZG_SECURE_ENABLED )
   2308            {
   2309              SSP_Init();
   2310          
   2311              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2312                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2313              {
   2314                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2315                {
   2316                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2317                  APSME_SecurityCM_CD();
   2318                }
   2319                else if ( ZSTACK_ROUTER_BUILD )
   2320                {
   2321                  // COMMERCIAL MODE - ROUTER DEVICE
   2322                  APSME_SecurityCM_RD();
   2323                }
   2324                else
   2325                {
   2326                  // COMMERCIAL MODE - END DEVICE
   2327                  APSME_SecurityCM_ED();
   2328                }
   2329              }
   2330              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2331              {
   2332                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2333                {
   2334                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2335                  APSME_SecurityRM_CD();
   2336                }
   2337                else if ( ZSTACK_ROUTER_BUILD )
   2338                {
   2339                  // RESIDENTIAL MODE - ROUTER DEVICE
   2340                  APSME_SecurityRM_RD();
   2341                }
   2342                else
   2343                {
   2344                  // RESIDENTIAL MODE - END DEVICE
   2345                  APSME_SecurityRM_ED();
   2346                }
   2347              }
   2348            }
   2349            else
   2350            {
   2351              // NO SECURITY
   2352              APSME_SecurityNM();
   2353            }
   2354          }
   2355          
   2356          /******************************************************************************
   2357           * @fn          ZDSecMgrPermitJoining
   2358           *
   2359           * @brief       Process request to change joining permissions.
   2360           *
   2361           * @param       duration - [in] timed duration for join in seconds
   2362           *                         - 0x00 not allowed
   2363           *                         - 0xFF allowed without timeout
   2364           *
   2365           * @return      uint8 - success(TRUE:FALSE)
   2366           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2367          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2368          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   \   000005   F8           MOV       R0,A
   2369            uint8 accept;
   2370          
   2371          
   2372            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR       A
   \   00000A   F0           MOVX      @DPTR,A
   2373          
   2374            if ( duration > 0 )
   \   00000B   E9           MOV       A,R1
   \   00000C   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   600F         JZ        ??ZDSecMgrPermitJoining_0
   2375            {
   2376              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV       A,#0x1
   \   000013   F0           MOVX      @DPTR,A
   2377          
   2378              if ( duration != 0xFF )
   \   000014   74FF         MOV       A,#-0x1
   \   000016   68           XRL       A,R0
   \   000017   6009         JZ        ??ZDSecMgrPermitJoining_1
   2379              {
   2380                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   7401         MOV       A,#0x1
   \   00001E   8001         SJMP      ??ZDSecMgrPermitJoining_2
   2381              }
   2382            }
   2383            else
   2384            {
   2385              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR       A
   \                     ??ZDSecMgrPermitJoining_2:
   \   000021   F0           MOVX      @DPTR,A
   2386            }
   2387          
   2388            accept = TRUE;
   2389          
   2390            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000022   7901         MOV       R1,#0x1
   \   000024   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   2391          }
   2392          
   2393          /******************************************************************************
   2394           * @fn          ZDSecMgrPermitJoiningTimeout
   2395           *
   2396           * @brief       Process permit joining timeout
   2397           *
   2398           * @param       none
   2399           *
   2400           * @return      none
   2401           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2402          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2403          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2404            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6401         XRL       A,#0x1
   \   00000A   7009         JNZ       ??ZDSecMgrPermitJoiningTimeout_0
   2405            {
   2406              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR       A
   \   000010   F0           MOVX      @DPTR,A
   2407              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX      @DPTR,A
   2408            }
   2409          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   2410          
   2411          /******************************************************************************
   2412           * @fn          ZDSecMgrNewDeviceEvent
   2413           *
   2414           * @brief       Process a the new device event, if found reset new device
   2415           *              event/timer.
   2416           *
   2417           * @param       none
   2418           *
   2419           * @return      uint8 - found(TRUE:FALSE)
   2420           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2421          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2422          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV       A,#-0x17
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2423            uint8                 found;
   2424            ZDSecMgrDevice_t      device;
   2425            AddrMgrEntry_t        addrEntry;
   2426            associated_devices_t* assoc;
   2427            ZStatus_t             status;
   2428          
   2429            // initialize return results
   2430            found = FALSE;
   \   00000A   75..00       MOV       ?V0,#0x0
   2431          
   2432            // look for device in the security init state
   2433            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV       R1,#0x4
   \   00000F   12....       LCALL     `??AssocMatchDeviceStatus::?relay`; Banked call to: AssocMatchDeviceStatus
   \   000012   8A..         MOV       ?V2,R2
   \   000014   8B..         MOV       ?V3,R3
   \   000016   AE..         MOV       R6,?V2
   \   000018   AF..         MOV       R7,?V3
   2434          
   2435            if ( assoc != NULL )
   \   00001A   EA           MOV       A,R2
   \   00001B   4F           ORL       A,R7
   \   00001C   7003         JNZ       $+5
   \   00001E   02....       LJMP      ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2436            {
   2437              // device found
   2438              found = TRUE;
   \   000021   75..01       MOV       ?V0,#0x1
   2439          
   2440              // check for preconfigured security
   2441              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV       DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX      A,@DPTR
   \   000028   6401         XRL       A,#0x1
   \   00002A   7003         JNZ       ??ZDSecMgrNewDeviceEvent_1
   2442              {
   2443                // set association status to authenticated
   2444                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2445              }
   2446          
   2447              // set up device info
   2448              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002F   740A         MOV       A,#0xa
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E4           CLR       A
   \   000035   F0           MOVX      @DPTR,A
   2449              addrEntry.index = assoc->addrIdx;
   \   000036   8E82         MOV       DPL,R6
   \   000038   8F83         MOV       DPH,R7
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   12....       LCALL     ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   00003F   7415         MOV       A,#0x15
   \   000041   12....       LCALL     ?XSTACK_DISP0_8
   \   000044   12....       LCALL     ?Subroutine18 & 0xFFFF
   2450              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_12:
   \   000047   12....       LCALL     ?XSTACK_DISP101_8
   \   00004A   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   2451          
   2452              device.nwkAddr    = assoc->shortAddr;
   \   00004D   8E82         MOV       DPL,R6
   \   00004F   8F83         MOV       DPH,R7
   \   000051   12....       LCALL     ?Subroutine28 & 0xFFFF
   2453              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_193:
   \   000054   12....       LCALL     ?XSTACK_DISP0_8
   \   000057   A882         MOV       R0,DPL
   \   000059   A983         MOV       R1,DPH
   \   00005B   7402         MOV       A,#0x2
   \   00005D   12....       LCALL     ?XSTACK_DISP0_8
   \   000060   12....       LCALL     ?Subroutine33 & 0xFFFF
   2454              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_36:
   \   000063   7404         MOV       A,#0x4
   \   000065   12....       LCALL     ?XSTACK_DISP0_8
   \   000068   12....       LCALL     ??Subroutine107_0 & 0xFFFF
   2455              device.secure     = FALSE;
   \                     ??CrossCallReturnLabel_188:
   \   00006B   7406         MOV       A,#0x6
   \   00006D   12....       LCALL     ?XSTACK_DISP0_8
   \   000070   E4           CLR       A
   \   000071   F0           MOVX      @DPTR,A
   2456              device.devStatus  = assoc->devStatus;
   \   000072   EE           MOV       A,R6
   \   000073   2405         ADD       A,#0x5
   \   000075   FE           MOV       R6,A
   \   000076   5001         JNC       ??ZDSecMgrNewDeviceEvent_2
   \   000078   0F           INC       R7
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   000079   F582         MOV       DPL,A
   \   00007B   8F83         MOV       DPH,R7
   \   00007D   E0           MOVX      A,@DPTR
   \   00007E   C0E0         PUSH      A
   \   000080   7407         MOV       A,#0x7
   \   000082   12....       LCALL     ?XSTACK_DISP0_8
   \   000085   D0E0         POP       A
   \   000087   12....       LCALL     ??Subroutine106_0 & 0xFFFF
   2457          
   2458              // process new device
   2459              status = ZDSecMgrDeviceNew( &device );
   \                     ??CrossCallReturnLabel_180:
   \   00008A   12....       LCALL     `??ZDSecMgrDeviceNew::?relay`; Banked call to: ZDSecMgrDeviceNew
   \   00008D   E9           MOV       A,R1
   \   00008E   F8           MOV       R0,A
   2460          
   2461              if ( status == ZSuccess )
   \   00008F   700A         JNZ       ??ZDSecMgrNewDeviceEvent_3
   2462              {
   2463                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   000091   8E82         MOV       DPL,R6
   \   000093   8F83         MOV       DPH,R7
   \   000095   E0           MOVX      A,@DPTR
   \   000096   C2E2         CLR       0xE0 /* A   */.2
   \   000098   F0           MOVX      @DPTR,A
   \   000099   8011         SJMP      ??ZDSecMgrNewDeviceEvent_0
   2464              }
   2465              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_3:
   \   00009B   74C8         MOV       A,#-0x38
   \   00009D   68           XRL       A,R0
   \   00009E   700C         JNZ       ??ZDSecMgrNewDeviceEvent_0
   2466              {
   2467                AssocRemove( addrEntry.extAddr );
   \   0000A0                ; Setup parameters for call to function AssocRemove
   \   0000A0   740D         MOV       A,#0xd
   \   0000A2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A5   AA82         MOV       R2,DPL
   \   0000A7   AB83         MOV       R3,DPH
   \   0000A9   12....       LCALL     `??AssocRemove::?relay`; Banked call to: AssocRemove
   2468              }
   2469            }
   2470          
   2471            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000AC   A9..         MOV       R1,?V0
   \   0000AE   7417         MOV       A,#0x17
   \   0000B0   80..         SJMP      ??Subroutine109_0
   2472          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL     ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000003                REQUIRE ??Subroutine108_0
   \   000003                ; // Fall through to label ??Subroutine108_0
   2473          
   2474          /******************************************************************************
   2475           * @fn          ZDSecMgrEvent
   2476           *
   2477           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2478           *
   2479           * @param       none
   2480           *
   2481           * @return      none
   2482           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2483          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2484          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV       A,#-0x17
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2485            uint8            action;
   2486            uint8            restart;
   2487            uint16           index;
   2488            AddrMgrEntry_t   entry;
   2489            ZDSecMgrDevice_t device;
   2490          
   2491          
   2492            // verify data is available
   2493            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   00000D   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000010   7003         JNZ       $+5
   \   000012   02....       LJMP      ??ZDSecMgrEvent_0 & 0xFFFF
   2494            {
   2495              action  = FALSE;
   \   000015   75..00       MOV       ?V1,#0x0
   2496              restart = FALSE;
   \   000018   75..00       MOV       ?V0,#0x0
   2497          
   2498              // update all the counters
   2499              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001B   7E00         MOV       R6,#0x0
   \   00001D   7F00         MOV       R7,#0x0
   2500              {
   2501                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrEvent_1:
   \   00001F   EE           MOV       A,R6
   \   000020   F8           MOV       R0,A
   \   000021   EF           MOV       A,R7
   \   000022   F9           MOV       R1,A
   \   000023   E8           MOV       A,R0
   \   000024   75F007       MOV       B,#0x7
   \   000027   A4           MUL       AB
   \   000028   F8           MOV       R0,A
   \   000029   AAF0         MOV       R2,B
   \   00002B   75F007       MOV       B,#0x7
   \   00002E   E9           MOV       A,R1
   \   00002F   A4           MUL       AB
   \   000030   2A           ADD       A,R2
   \   000031   F9           MOV       R1,A
   \   000032   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000035   E0           MOVX      A,@DPTR
   \   000036   28           ADD       A,R0
   \   000037   FA           MOV       R2,A
   \   000038   A3           INC       DPTR
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   39           ADDC      A,R1
   \   00003B   FB           MOV       R3,A
   \   00003C   8A82         MOV       DPL,R2
   \   00003E   F583         MOV       DPH,A
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   A3           INC       DPTR
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   7003         JNZ       $+5
   \   000048   02....       LJMP      ??ZDSecMgrEvent_2 & 0xFFFF
   2502                {
   2503                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   00004B   EA           MOV       A,R2
   \   00004C   2406         ADD       A,#0x6
   \   00004E   F582         MOV       DPL,A
   \   000050   E4           CLR       A
   \   000051   3B           ADDC      A,R3
   \   000052   F583         MOV       DPH,A
   \   000054   E0           MOVX      A,@DPTR
   \   000055   6002         JZ        ??ZDSecMgrEvent_3
   2504                  {
   2505                    ZDSecMgrCtrlData[index].cntr--;
   \   000057   14           DEC       A
   \   000058   F0           MOVX      @DPTR,A
   2506                  }
   2507          
   2508                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_3:
   \   000059   E5..         MOV       A,?V1
   \   00005B   A2E0         MOV       C,0xE0 /* A   */.0
   \   00005D   407F         JC        ??ZDSecMgrEvent_4
   \   00005F   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000062   E0           MOVX      A,@DPTR
   \   000063   28           ADD       A,R0
   \   000064   F8           MOV       R0,A
   \   000065   A3           INC       DPTR
   \   000066   E0           MOVX      A,@DPTR
   \   000067   39           ADDC      A,R1
   \   000068   F9           MOV       R1,A
   \   000069   8882         MOV       DPL,R0
   \   00006B   F583         MOV       DPH,A
   \   00006D   A3           INC       DPTR
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   A3           INC       DPTR
   \   000071   A3           INC       DPTR
   \   000072   A3           INC       DPTR
   \   000073   E0           MOVX      A,@DPTR
   \   000074   7068         JNZ       ??ZDSecMgrEvent_4
   2509                  {
   2510                    action = TRUE;
   \   000076   75..01       MOV       ?V1,#0x1
   2511          
   2512                    // update from control data
   2513                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   \   000079   8882         MOV       DPL,R0
   \   00007B   8983         MOV       DPH,R1
   \   00007D   A3           INC       DPTR
   \   00007E   A3           INC       DPTR
   \   00007F   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000082   7404         MOV       A,#0x4
   \   000084   12....       LCALL     ?XSTACK_DISP0_8
   \   000087   12....       LCALL     ??Subroutine107_0 & 0xFFFF
   2514                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \                     ??CrossCallReturnLabel_189:
   \   00008A   8882         MOV       DPL,R0
   \   00008C   8983         MOV       DPH,R1
   \   00008E   A3           INC       DPTR
   \   00008F   A3           INC       DPTR
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   E0           MOVX      A,@DPTR
   \   000093   C0E0         PUSH      A
   \   000095   7406         MOV       A,#0x6
   \   000097   12....       LCALL     ?XSTACK_DISP0_8
   \   00009A   D0E0         POP       A
   \   00009C   F0           MOVX      @DPTR,A
   2515                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   00009D   7408         MOV       A,#0x8
   \   00009F   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A2   12....       LCALL     ?Subroutine18 & 0xFFFF
   2516          
   2517                    // set the user and address index
   2518                    entry.user  = ADDRMGR_USER_SECURITY;
   \                     ??CrossCallReturnLabel_13:
   \   0000A5   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A8   7402         MOV       A,#0x2
   \   0000AA   12....       LCALL     ?Subroutine30 & 0xFFFF
   2519                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \                     ??CrossCallReturnLabel_32:
   \   0000AD   F583         MOV       DPH,A
   \   0000AF   8882         MOV       DPL,R0
   \   0000B1   12....       LCALL     ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   0000B4   7415         MOV       A,#0x15
   \   0000B6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B9   12....       LCALL     ?Subroutine18 & 0xFFFF
   2520          
   2521                    // get the address data
   2522                    AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_14:
   \   0000BC   12....       LCALL     ?XSTACK_DISP101_8
   \   0000BF   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   2523          
   2524                    // set device address data
   2525                    device.nwkAddr = entry.nwkAddr;
   \   0000C2   740B         MOV       A,#0xb
   \   0000C4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C7   12....       LCALL     ?Subroutine28 & 0xFFFF
   2526                    device.extAddr = entry.extAddr;
   2527          
   2528                    // update from entry data
   2529                    ZDSecMgrDeviceCtrlHandler( &device );
   2530                  }
   \                     ??CrossCallReturnLabel_194:
   \   0000CA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CD   A882         MOV       R0,DPL
   \   0000CF   A983         MOV       R1,DPH
   \   0000D1   7402         MOV       A,#0x2
   \   0000D3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D6   12....       LCALL     ?Subroutine11 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   0000D9   12....       LCALL     `??ZDSecMgrDeviceCtrlHandler::?relay`; Banked call to: ZDSecMgrDeviceCtrlHandler
   \   0000DC   8003         SJMP      ??ZDSecMgrEvent_2
   2531                  else
   2532                  {
   2533                    restart = TRUE;
   \                     ??ZDSecMgrEvent_4:
   \   0000DE   75..01       MOV       ?V0,#0x1
   2534                  }
   2535                }
   2536              }
   \                     ??ZDSecMgrEvent_2:
   \   0000E1   0E           INC       R6
   \   0000E2   EE           MOV       A,R6
   \   0000E3   7001         JNZ       ??ZDSecMgrEvent_5
   \   0000E5   0F           INC       R7
   \                     ??ZDSecMgrEvent_5:
   \   0000E6   C3           CLR       C
   \   0000E7   9403         SUBB      A,#0x3
   \   0000E9   EF           MOV       A,R7
   \   0000EA   9400         SUBB      A,#0x0
   \   0000EC   5003         JNC       $+5
   \   0000EE   02....       LJMP      ??ZDSecMgrEvent_1 & 0xFFFF
   2537          
   2538              // check for timer restart
   2539              if ( restart == TRUE )
   \   0000F1   E5..         MOV       A,?V0
   \   0000F3   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000F5   5010         JNC       ??ZDSecMgrEvent_0
   2540              {
   2541                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000F7                ; Setup parameters for call to function osal_start_timerEx
   \   0000F7   7C64         MOV       R4,#0x64
   \   0000F9   7D00         MOV       R5,#0x0
   \   0000FB   7A00         MOV       R2,#0x0
   \   0000FD   7B01         MOV       R3,#0x1
   \   0000FF   90....       MOV       DPTR,#ZDAppTaskID
   \   000102   E0           MOVX      A,@DPTR
   \   000103   F9           MOV       R1,A
   \   000104   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   2542              }
   2543            }
   2544          }
   \                     ??ZDSecMgrEvent_0:
   \   000107   7417         MOV       A,#0x17
   \   000109   80..         SJMP      ??Subroutine114_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000003                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000003                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000003                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000003                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000003                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000003   AA..         MOV       R2,?XSP + 0
   \   000005   AB..         MOV       R3,?XSP + 1
   \   000007   22           RET
   2545          
   2546          /******************************************************************************
   2547           * @fn          ZDSecMgrEstablishKeyCfm
   2548           *
   2549           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2550           *
   2551           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2552           *
   2553           * @return      none
   2554           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2555          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2556          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2557            // send the NWK key
   2558            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2559            {
   2560              // update control for specified EXT address
   2561              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2562            }
   2563            else
   2564            {
   2565              // this should be done when receiving the NWK key
   2566              // if devState ==
   2567              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2568                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2569          
   2570              // if not in joining state -- this should trigger an event for an
   2571              // end point that requested SKKE
   2572              // if ( devState == DEV_END_DEVICE )
   2573             //       devState == DEV_ROUTER;
   2574          
   2575            }
   2576          }
   \   000000   02....       LJMP      ?BRET
   2577          
   2578          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2579          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2580          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2581            uint8  match;
   2582            uint8  lookup[Z_EXTADDR_LEN];
   2583          
   2584            match = FALSE;
   \   00000E   75..00       MOV       ?V0,#0x0
   2585          
   2586            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   AC..         MOV       R4,?XSP + 0
   \   000013   AD..         MOV       R5,?XSP + 1
   \   000015   7A00         MOV       R2,#0x0
   \   000017   7B00         MOV       R3,#0x0
   \   000019   12....       LCALL     `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
   \   00001C   E9           MOV       A,R1
   \   00001D   600E         JZ        ??ZDSecMgrTCExtAddrCheck_0
   2587            {
   2588              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   00001F                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00001F   EE           MOV       A,R6
   \   000020   FC           MOV       R4,A
   \   000021   EF           MOV       A,R7
   \   000022   FD           MOV       R5,A
   \   000023   AA..         MOV       R2,?XSP + 0
   \   000025   AB..         MOV       R3,?XSP + 1
   \   000027   12....       LCALL     `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   00002A   E9           MOV       A,R1
   \   00002B   F5..         MOV       ?V0,A
   2589            }
   2590          
   2591            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   00002D   A9..         MOV       R1,?V0
   \   00002F   7408         MOV       A,#0x8
   \   000031   02....       LJMP      ??Subroutine100_0 & 0xFFFF
   2592          }
   2593          
   2594          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2595          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2596          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV       A,#-0x14
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2597            uint16 ami;
   2598            uint16 keyNvId;   
   2599            uint8 masterKey[SEC_KEY_LEN];
   2600          
   2601            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV       DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   706B         JNZ       ??ZDSecMgrTCDataLoad_0
   2602            {
   2603              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   A8..         MOV       R0,?XSP + 0
   \   000012   A9..         MOV       R1,?XSP + 1
   \   000014   88..         MOV       ?V0,R0
   \   000016   89..         MOV       ?V1,R1
   \   000018   78..         MOV       R0,#?V0
   \   00001A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001D   EA           MOV       A,R2
   \   00001E   FC           MOV       R4,A
   \   00001F   EB           MOV       A,R3
   \   000020   FD           MOV       R5,A
   \   000021   7A00         MOV       R2,#0x0
   \   000023   7B00         MOV       R3,#0x0
   \   000025   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000028   7402         MOV       A,#0x2
   \   00002A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00002D   E9           MOV       A,R1
   \   00002E   7045         JNZ       ??ZDSecMgrTCDataLoad_1
   2604              {
   2605                // if preconfigured load key
   2606                if ( zgPreConfigKeys == TRUE )
   \   000030   90....       MOV       DPTR,#zgPreConfigKeys
   \   000033   E0           MOVX      A,@DPTR
   \   000034   6401         XRL       A,#0x1
   \   000036   703D         JNZ       ??ZDSecMgrTCDataLoad_1
   2607                {
   2608                  if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) != ZSuccess )
   \   000038                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000038   7402         MOV       A,#0x2
   \   00003A   12....       LCALL     ?XSTACK_DISP102_8
   \   00003D   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000040   6033         JZ        ??ZDSecMgrTCDataLoad_1
   2609                  {
   2610                    // temporary copy
   2611                    osal_memcpy( masterKey, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   000042                ; Setup parameters for call to function osal_memcpy
   \   000042   75....       MOV       ?V0,#ZDSecMgrTCMasterKey & 0xff
   \   000045   75....       MOV       ?V1,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   000048   75..80       MOV       ?V2,#-0x80
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000050   7C10         MOV       R4,#0x10
   \   000052   7D00         MOV       R5,#0x0
   \   000054   7407         MOV       A,#0x7
   \   000056   12....       LCALL     ?XSTACK_DISP101_8
   \   000059   12....       LCALL     ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   00005C   12....       LCALL     ?DEALLOC_XSTACK8
   2612          
   2613                    ZDSecMgrMasterKeyStore( ami, masterKey );
   \   00005F                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00005F   7404         MOV       A,#0x4
   \   000061   12....       LCALL     ?XSTACK_DISP102_8
   \   000064   12....       LCALL     ?Subroutine59 & 0xFFFF
   2614                      
   2615                    // remove copy of key in RAM  
   2616                    osal_memset( masterKey, 0x00, SEC_KEY_LEN );
   \                     ??CrossCallReturnLabel_72:
   \   000067                ; Setup parameters for call to function osal_memset
   \   000067   7C10         MOV       R4,#0x10
   \   000069   7D00         MOV       R5,#0x0
   \   00006B   7900         MOV       R1,#0x0
   \   00006D   7404         MOV       A,#0x4
   \   00006F   12....       LCALL     ?XSTACK_DISP101_8
   \   000072   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2617                  }
   2618                }
   2619              }
   2620          
   2621              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??ZDSecMgrTCDataLoad_1:
   \   000075   90....       MOV       DPTR,#ZDSecMgrTCDataLoaded
   \   000078   7401         MOV       A,#0x1
   \   00007A   F0           MOVX      @DPTR,A
   2622            }
   2623          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   00007B   7414         MOV       A,#0x14
   \   00007D                REQUIRE ?Subroutine6
   \   00007D                ; // Fall through to label ?Subroutine6

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F03         MOV       R7,#0x3
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA
   2624          
   2625          /******************************************************************************
   2626           * @fn          ZDSecMgrEstablishKeyInd
   2627           *
   2628           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2629           *
   2630           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2631           *
   2632           * @return      none
   2633           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2634          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2635          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV       A,#-0x11
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   2636            ZDSecMgrDevice_t        device;
   2637            APSME_EstablishKeyRsp_t rsp;
   2638          
   2639          
   2640            // load Trust Center data if needed
   2641            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   EA           MOV       A,R2
   \   00000F   2404         ADD       A,#0x4
   \   000011   FE           MOV       R6,A
   \   000012   E4           CLR       A
   \   000013   35..         ADDC      A,?V1
   \   000015   FF           MOV       R7,A
   \   000016                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000016   EE           MOV       A,R6
   \   000017   FA           MOV       R2,A
   \   000018   EF           MOV       A,R7
   \   000019   FB           MOV       R3,A
   \   00001A   12....       LCALL     `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   2642          
   2643            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   00001D   E5..         MOV       A,?V0
   \   00001F   2402         ADD       A,#0x2
   \   000021   F5..         MOV       ?V2,A
   \   000023   E4           CLR       A
   \   000024   35..         ADDC      A,?V1
   \   000026   F5..         MOV       ?V3,A
   \   000028                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   000028   EE           MOV       A,R6
   \   000029   FA           MOV       R2,A
   \   00002A   EF           MOV       A,R7
   \   00002B   FB           MOV       R3,A
   \   00002C   12....       LCALL     `??ZDSecMgrTCExtAddrCheck::?relay`; Banked call to: ZDSecMgrTCExtAddrCheck
   \   00002F   E9           MOV       A,R1
   \   000030   6016         JZ        ??ZDSecMgrEstablishKeyInd_0
   2644            {
   2645              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2646              //OR
   2647              //!ZDSecMgrTCAuthenticated
   2648              //devtag.0604.critical
   2649                  //how is the parentAddr used here
   2650          
   2651              // initial SKKE from Trust Center via parent
   2652              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000032   7407         MOV       A,#0x7
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   E4           CLR       A
   \   000038   F0           MOVX      @DPTR,A
   \   000039   A3           INC       DPTR
   \   00003A   12....       LCALL     ?Subroutine20 & 0xFFFF
   2653              device.parentAddr = ind->srcAddr;
   2654            }
   \                     ??CrossCallReturnLabel_17:
   \   00003D   740B         MOV       A,#0xb
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   E8           MOV       A,R0
   \   000043   F0           MOVX      @DPTR,A
   \   000044   A3           INC       DPTR
   \   000045   E9           MOV       A,R1
   \   000046   8015         SJMP      ??ZDSecMgrEstablishKeyInd_1
   2655            else
   2656            {
   2657              // Trust Center direct or E2E SKKE
   2658              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   000048   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   00004B   7407         MOV       A,#0x7
   \   00004D   12....       LCALL     ?XSTACK_DISP0_8
   \   000050   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   2659              device.parentAddr = INVALID_NODE_ADDR;
   \                     ??CrossCallReturnLabel_222:
   \   000053   740B         MOV       A,#0xb
   \   000055   12....       LCALL     ?XSTACK_DISP0_8
   \   000058   74FE         MOV       A,#-0x2
   \   00005A   F0           MOVX      @DPTR,A
   \   00005B   A3           INC       DPTR
   \   00005C   04           INC       A
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   00005D   F0           MOVX      @DPTR,A
   2660            }
   2661          
   2662            device.extAddr = ind->initExtAddr;
   \   00005E   7409         MOV       A,#0x9
   \   000060   12....       LCALL     ?XSTACK_DISP0_8
   \   000063   EE           MOV       A,R6
   \   000064   F0           MOVX      @DPTR,A
   \   000065   A3           INC       DPTR
   \   000066   EF           MOV       A,R7
   \   000067   F0           MOVX      @DPTR,A
   2663            //devtag.pro.security.0724.todo - verify usage
   2664            device.secure  = ind->nwkSecure;
   \   000068   E5..         MOV       A,?V0
   \   00006A   240E         ADD       A,#0xe
   \   00006C   F5..         MOV       ?V4,A
   \   00006E   E4           CLR       A
   \   00006F   35..         ADDC      A,?V1
   \   000071   F5..         MOV       ?V5,A
   \   000073   85..82       MOV       DPL,?V4
   \   000076   F583         MOV       DPH,A
   \   000078   E0           MOVX      A,@DPTR
   \   000079   C0E0         PUSH      A
   \   00007B   740D         MOV       A,#0xd
   \   00007D   12....       LCALL     ?XSTACK_DISP0_8
   \   000080   D0E0         POP       A
   \   000082   F0           MOVX      @DPTR,A
   2665          
   2666            // validate device for SKKE
   2667            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000083                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   000083   7407         MOV       A,#0x7
   \   000085   12....       LCALL     ?XSTACK_DISP101_8
   \   000088   12....       LCALL     `??ZDSecMgrDeviceValidateSKKE::?relay`; Banked call to: ZDSecMgrDeviceValidateSKKE
   \   00008B   E9           MOV       A,R1
   \   00008C   7009         JNZ       ??ZDSecMgrEstablishKeyInd_2
   2668            {
   2669              rsp.accept = TRUE;
   \   00008E   7404         MOV       A,#0x4
   \   000090   12....       LCALL     ?XSTACK_DISP0_8
   \   000093   7401         MOV       A,#0x1
   \   000095   8006         SJMP      ??ZDSecMgrEstablishKeyInd_3
   2670            }
   2671            else
   2672            {
   2673              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   000097   7404         MOV       A,#0x4
   \   000099   12....       LCALL     ?XSTACK_DISP0_8
   \   00009C   E4           CLR       A
   2674            }
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   00009D   12....       LCALL     ?Subroutine20 & 0xFFFF
   2675          
   2676            rsp.dstAddr     = ind->srcAddr;
   \                     ??CrossCallReturnLabel_18:
   \   0000A0   12....       LCALL     ?Subroutine29 & 0xFFFF
   2677            rsp.initExtAddr = &ind->initExtAddr[0];
   \                     ??CrossCallReturnLabel_212:
   \   0000A3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A6   EE           MOV       A,R6
   \   0000A7   F0           MOVX      @DPTR,A
   \   0000A8   A3           INC       DPTR
   \   0000A9   EF           MOV       A,R7
   \   0000AA   F0           MOVX      @DPTR,A
   2678            //devtag.0604.todo - remove obsolete
   2679            rsp.apsSecure   = ind->apsSecure;
   \   0000AB   E5..         MOV       A,?V0
   \   0000AD   240D         ADD       A,#0xd
   \   0000AF   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   0000B2   E0           MOVX      A,@DPTR
   \   0000B3   C0E0         PUSH      A
   \   0000B5   7405         MOV       A,#0x5
   \   0000B7   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BA   D0E0         POP       A
   \   0000BC   F0           MOVX      @DPTR,A
   2680            rsp.nwkSecure   = ind->nwkSecure;
   \   0000BD   85..82       MOV       DPL,?V4
   \   0000C0   85..83       MOV       DPH,?V5
   \   0000C3   E0           MOVX      A,@DPTR
   \   0000C4   C0E0         PUSH      A
   \   0000C6   7406         MOV       A,#0x6
   \   0000C8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CB   D0E0         POP       A
   \   0000CD   12....       LCALL     ??Subroutine106_0 & 0xFFFF
   2681          
   2682            APSME_EstablishKeyRsp( &rsp );
   \                     ??CrossCallReturnLabel_181:
   \   0000D0   12....       LCALL     `??APSME_EstablishKeyRsp::?relay`; Banked call to: APSME_EstablishKeyRsp
   2683          }
   \   0000D3   7411         MOV       A,#0x11
   \   0000D5                REQUIRE ?Subroutine4
   \   0000D5                ; // Fall through to label ?Subroutine4

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine116_0
   \   000003                ; // Fall through to label ??Subroutine116_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine117_0
   \   000006                ; // Fall through to label ??Subroutine117_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85..82       MOV       DPL,?V2
   \   000004   85..83       MOV       DPH,?V3
   \   000007   12....       LCALL     ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006                REQUIRE ??Subroutine120_0
   \   000006                ; // Fall through to label ??Subroutine120_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   F582         MOV       DPL,A
   \   000002   E4           CLR       A
   \   000003   35..         ADDC      A,?V1
   \   000005   F583         MOV       DPH,A
   \   000007   22           RET
   2684          //devtag.pro.security
   2685          #if 0
   2686          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2687          {
   2688            ZDSecMgrDevice_t        device;
   2689            APSME_EstablishKeyRsp_t rsp;
   2690          
   2691          
   2692            device.extAddr = ind->initExtAddr;
   2693            device.secure  = ind->secure;
   2694          
   2695            if ( ind->secure == FALSE )
   2696            {
   2697              // SKKE from Trust Center is not secured between child and parent
   2698              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2699              device.parentAddr = ind->srcAddr;
   2700            }
   2701            else
   2702            {
   2703              // SKKE from initiator should be secured
   2704              device.nwkAddr    = ind->srcAddr;
   2705              device.parentAddr = INVALID_NODE_ADDR;
   2706            }
   2707          
   2708            rsp.dstAddr     = ind->srcAddr;
   2709            rsp.initExtAddr = &ind->initExtAddr[0];
   2710            rsp.secure      = ind->secure;
   2711          
   2712            // validate device for SKKE
   2713            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2714            {
   2715              rsp.accept = TRUE;
   2716            }
   2717            else
   2718            {
   2719              rsp.accept = FALSE;
   2720            }
   2721          
   2722            APSME_EstablishKeyRsp( &rsp );
   2723          }
   2724          #endif
   2725          
   2726          /******************************************************************************
   2727           * @fn          ZDSecMgrTransportKeyInd
   2728           *
   2729           * @brief       Process the ZDO_TransportKeyInd_t message.
   2730           *
   2731           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2732           *
   2733           * @return      none
   2734           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2735          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2736          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV       A,#-0x10
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2737            uint8 index;
   2738            uint8 zgPreConfigKey[SEC_KEY_LEN];
   2739          
   2740            // load Trust Center data if needed
   2741            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   00000E                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   00000E   EA           MOV       A,R2
   \   00000F   2416         ADD       A,#0x16
   \   000011   FA           MOV       R2,A
   \   000012   E4           CLR       A
   \   000013   3F           ADDC      A,R7
   \   000014   FB           MOV       R3,A
   \   000015   12....       LCALL     `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   2742          
   2743            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000018   8E82         MOV       DPL,R6
   \   00001A   8F83         MOV       DPH,R7
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F8           MOV       R0,A
   \   000022   7003         JNZ       $+5
   \   000024   02....       LJMP      ??ZDSecMgrTransportKeyInd_0 & 0xFFFF
   2744            {
   2745              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2746              //ZDSecMgrTCMasterKey( ind );
   2747              {
   2748                if ( zgPreConfigKeys != TRUE )
   2749                {
   2750                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2751                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2752                }
   2753                else
   2754                {
   2755                  // error condition - reject key
   2756                }
   2757              }
   2758            }
   2759            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2760                      ( ind->keyType == 6                 ) ||
   2761                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000027   7401         MOV       A,#0x1
   \   000029   68           XRL       A,R0
   \   00002A   600A         JZ        ??ZDSecMgrTransportKeyInd_1
   \   00002C   7406         MOV       A,#0x6
   \   00002E   68           XRL       A,R0
   \   00002F   6005         JZ        ??ZDSecMgrTransportKeyInd_1
   \   000031   7405         MOV       A,#0x5
   \   000033   68           XRL       A,R0
   \   000034   7078         JNZ       ??ZDSecMgrTransportKeyInd_0
   2762            {
   2763              // check for dummy NWK key (all zeros)
   2764              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000036   7800         MOV       R0,#0x0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   000038   E8           MOV       A,R0
   \   000039   FA           MOV       R2,A
   \   00003A   EE           MOV       A,R6
   \   00003B   2A           ADD       A,R2
   \   00003C   F582         MOV       DPL,A
   \   00003E   E4           CLR       A
   \   00003F   3F           ADDC      A,R7
   \   000040   F583         MOV       DPH,A
   \   000042   A3           INC       DPTR
   \   000043   A3           INC       DPTR
   \   000044   A3           INC       DPTR
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   E0           MOVX      A,@DPTR
   \   000049   7007         JNZ       ??ZDSecMgrTransportKeyInd_3
   2765                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2766                    index++ );
   \   00004B   08           INC       R0
   \   00004C   E8           MOV       A,R0
   \   00004D   C3           CLR       C
   \   00004E   9410         SUBB      A,#0x10
   \   000050   40E6         JC        ??ZDSecMgrTransportKeyInd_2
   2767          
   2768              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   000052   7410         MOV       A,#0x10
   \   000054   68           XRL       A,R0
   \   000055   702E         JNZ       ??ZDSecMgrTransportKeyInd_4
   2769              {
   2770                // load preconfigured key - once!!
   2771                if ( !_NIB.nwkKeyLoaded )
   \   000057   90....       MOV       DPTR,#_NIB + 61
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   704E         JNZ       ??ZDSecMgrTransportKeyInd_5
   2772                {
   2773                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   00005D                ; Setup parameters for call to function ZDSecMgrReadKeyFromNv
   \   00005D   AC..         MOV       R4,?XSP + 0
   \   00005F   AD..         MOV       R5,?XSP + 1
   \   000061   7A62         MOV       R2,#0x62
   \   000063   7B00         MOV       R3,#0x0
   \   000065   12....       LCALL     `??ZDSecMgrReadKeyFromNv::?relay`; Banked call to: ZDSecMgrReadKeyFromNv
   2774                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   000068                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000068   7900         MOV       R1,#0x0
   \   00006A   AA..         MOV       R2,?XSP + 0
   \   00006C   AB..         MOV       R3,?XSP + 1
   \   00006E   12....       LCALL     `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2775                  SSP_SwitchNwkKey( 0 );
   \   000071                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000071   7900         MOV       R1,#0x0
   \   000073   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2776                  
   2777                  // clear local copy of key
   2778                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   000076                ; Setup parameters for call to function osal_memset
   \   000076   7C10         MOV       R4,#0x10
   \   000078   7D00         MOV       R5,#0x0
   \   00007A   7900         MOV       R1,#0x0
   \   00007C   AA..         MOV       R2,?XSP + 0
   \   00007E   AB..         MOV       R3,?XSP + 1
   \   000080   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   \   000083   8026         SJMP      ??ZDSecMgrTransportKeyInd_5
   2779                }
   2780              }
   2781              else
   2782              {
   2783                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000085   EE           MOV       A,R6
   \   000086   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   000089                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000089   85..82       MOV       DPL,?V0
   \   00008C   F583         MOV       DPH,A
   \   00008E   E0           MOVX      A,@DPTR
   \   00008F   F9           MOV       R1,A
   \   000090   EE           MOV       A,R6
   \   000091   2406         ADD       A,#0x6
   \   000093   FA           MOV       R2,A
   \   000094   E4           CLR       A
   \   000095   3F           ADDC      A,R7
   \   000096   FB           MOV       R3,A
   \   000097   12....       LCALL     `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2784                if ( !_NIB.nwkKeyLoaded )
   \   00009A   90....       MOV       DPTR,#_NIB + 61
   \   00009D   E0           MOVX      A,@DPTR
   \   00009E   700B         JNZ       ??ZDSecMgrTransportKeyInd_5
   2785                {
   2786                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000A0                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000A0   85..82       MOV       DPL,?V0
   \   0000A3   85..83       MOV       DPH,?V1
   \   0000A6   E0           MOVX      A,@DPTR
   \   0000A7   F9           MOV       R1,A
   \   0000A8   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2787                }
   2788              }
   2789          
   2790              // handle next step in authentication process
   2791              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   0000AB                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000AB   12....       LCALL     `??ZDSecMgrAuthNwkKey::?relay`; Banked call to: ZDSecMgrAuthNwkKey
   2792            }
   2793            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2794            {
   2795              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2796              {
   2797                // This should not happen because TCLK should not be Tx
   2798              }
   2799            }
   2800            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2801            {
   2802              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2803              {
   2804                uint16           ami;
   2805                AddrMgrEntry_t   entry;
   2806                ZDSecMgrEntry_t* entryZD;
   2807          
   2808                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2809          
   2810                if ( ind->initiator == TRUE )
   2811                {
   2812                  // get the ami data
   2813                  entry.user  = ADDRMGR_USER_SECURITY;
   2814                  entry.index = ami;
   2815                  AddrMgrEntryGet( &entry );
   2816          
   2817                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2818                  {
   2819                    APSME_EstablishKeyReq_t req;
   2820                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2821          
   2822                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2823          
   2824                    if ( entryZD == NULL )
   2825                    {
   2826                      // get new entry
   2827                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2828                      {
   2829                        // finish setting up entry
   2830                        entryZD->ami = ami;
   2831                      }
   2832                    }
   2833          
   2834                    req.respExtAddr = ind->srcExtAddr;
   2835                    req.method      = APSME_SKKE_METHOD;
   2836                    req.dstAddr     = entry.nwkAddr;
   2837                    req.apsSecure   = FALSE;
   2838                    req.nwkSecure   = TRUE;
   2839                    APSME_EstablishKeyReq( &req );
   2840                  }
   2841                }
   2842                else
   2843                {
   2844                  if ( ami == INVALID_NODE_ADDR )
   2845                  {
   2846                    // store new EXT address
   2847                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2848                  }
   2849          
   2850                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2851                }
   2852              }
   2853            }
   2854            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2855            {
   2856              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2857              {
   2858                uint16           ami;
   2859                ZDSecMgrEntry_t* entry;
   2860          
   2861                // get the address index
   2862                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2863                {
   2864                  // store new EXT address
   2865                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2866                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2867                }
   2868          
   2869                ZDSecMgrEntryLookupAMI( ami, &entry );
   2870          
   2871                if ( entry == NULL )
   2872                {
   2873                  // get new entry
   2874                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2875                  {
   2876                    // finish setting up entry
   2877                    entry->ami = ami;
   2878                  }
   2879                }
   2880          
   2881                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2882              }
   2883            }
   2884          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   0000AE   7410         MOV       A,#0x10
   \   0000B0   02....       LJMP      ??Subroutine114_0 & 0xFFFF
   2885          
   2886          /******************************************************************************
   2887           * @fn          ZDSecMgrUpdateDeviceInd
   2888           *
   2889           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2890           *
   2891           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2892           *
   2893           * @return      none
   2894           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   740A         MOV       A,#0xa
   \   000002                REQUIRE ??Subroutine93_0
   \   000002                ; // Fall through to label ??Subroutine93_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2895          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2896          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV       A,#-0xa
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   2897            ZDSecMgrDevice_t device;
   2898          
   2899          
   2900            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV       A,R2
   \   00000A   240C         ADD       A,#0xc
   \   00000C   F582         MOV       DPL,A
   \   00000E   E4           CLR       A
   \   00000F   3B           ADDC      A,R3
   \   000010   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   000013   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   2901            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_223:
   \   000016   EA           MOV       A,R2
   \   000017   2404         ADD       A,#0x4
   \   000019   F8           MOV       R0,A
   \   00001A   E4           CLR       A
   \   00001B   3B           ADDC      A,R3
   \   00001C   F9           MOV       R1,A
   \   00001D   7402         MOV       A,#0x2
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   12....       LCALL     ?Subroutine15 & 0xFFFF
   2902            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_8:
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   12....       LCALL     ?Subroutine11 & 0xFFFF
   2903          
   2904            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2905            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2906            //{
   2907            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2908            //  {
   2909            //    device.secure = TRUE;
   2910            //  }
   2911            //  else
   2912            //  {
   2913            //    device.secure = FALSE;
   2914            //  }
   2915          
   2916              // try to join this device
   2917              ZDSecMgrDeviceJoin( &device );
   \                     ??CrossCallReturnLabel_1:
   \   00002B   12....       LCALL     `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   2918            //}
   2919          }
   \   00002E   02....       LJMP      ?Subroutine9 & 0xFFFF
   2920          
   2921          /******************************************************************************
   2922           * @fn          ZDSecMgrRemoveDeviceInd
   2923           *
   2924           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2925           *
   2926           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2927           *
   2928           * @return      none
   2929           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2930          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2931          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2932            ZDSecMgrDevice_t device;
   2933          
   2934          
   2935            // only accept from Trust Center
   2936            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000A   8A82         MOV       DPL,R2
   \   00000C   8B83         MOV       DPH,R3
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000013   702F         JNZ       ??ZDSecMgrRemoveDeviceInd_0
   2937            {
   2938              // look up NWK address
   2939              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000015   EA           MOV       A,R2
   \   000016   2404         ADD       A,#0x4
   \   000018   FE           MOV       R6,A
   \   000019   E4           CLR       A
   \   00001A   3B           ADDC      A,R3
   \   00001B   FF           MOV       R7,A
   \   00001C                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001C   AC..         MOV       R4,?XSP + 0
   \   00001E   AD..         MOV       R5,?XSP + 1
   \   000020   EE           MOV       A,R6
   \   000021   FA           MOV       R2,A
   \   000022   EF           MOV       A,R7
   \   000023   FB           MOV       R3,A
   \   000024   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000027   E9           MOV       A,R1
   \   000028   6401         XRL       A,#0x1
   \   00002A   7018         JNZ       ??ZDSecMgrRemoveDeviceInd_0
   2940              {
   2941                device.parentAddr = NLME_GetShortAddr();
   \   00002C                ; Setup parameters for call to function NLME_GetShortAddr
   \   00002C   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00002F   7404         MOV       A,#0x4
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   12....       LCALL     ??Subroutine102_0 & 0xFFFF
   2942                device.extAddr    = ind->childExtAddr;
   2943          
   2944                // remove device
   2945                ZDSecMgrDeviceRemove( &device );
   2946              }
   2947            }
   \                     ??CrossCallReturnLabel_157:
   \   000037   12....       LCALL     ?XSTACK_DISP0_8
   \   00003A   EE           MOV       A,R6
   \   00003B   F0           MOVX      @DPTR,A
   \   00003C   A3           INC       DPTR
   \   00003D   EF           MOV       A,R7
   \   00003E   12....       LCALL     ??Subroutine106_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   000041   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2948          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000044   740A         MOV       A,#0xa
   \   000046   02....       LJMP      ??Subroutine100_0 & 0xFFFF
   2949          
   2950          /******************************************************************************
   2951           * @fn          ZDSecMgrRequestKeyInd
   2952           *
   2953           * @brief       Process the ZDO_RequestKeyInd_t message.
   2954           *
   2955           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2956           *
   2957           * @return      none
   2958           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2959          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2960          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2961            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F8           MOV       R0,A
   \   00000E   7401         MOV       A,#0x1
   \   000010   68           XRL       A,R0
   \   000011   6008         JZ        ??ZDSecMgrRequestKeyInd_0
   2962            {
   2963            }
   2964            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000013   7402         MOV       A,#0x2
   \   000015   68           XRL       A,R0
   \   000016   7003         JNZ       ??ZDSecMgrRequestKeyInd_0
   2965            {
   2966              ZDSecMgrAppKeyReq( ind );
   \   000018                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000018   12....       LCALL     `??ZDSecMgrAppKeyReq::?relay`; Banked call to: ZDSecMgrAppKeyReq
   2967            }
   2968            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2969            {
   2970            }
   2971            //else ignore
   2972          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00001B   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   2973          
   2974          /******************************************************************************
   2975           * @fn          ZDSecMgrSwitchKeyInd
   2976           *
   2977           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2978           *
   2979           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2980           *
   2981           * @return      none
   2982           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2983          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   2984          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2985            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F9           MOV       R1,A
   \   00000E   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2986          
   2987            // Save if nv
   2988            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL     `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   2989          }
   \   000014   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   2990          
   2991          /******************************************************************************
   2992           * @fn          ZDSecMgrAuthenticateInd
   2993           *
   2994           * @brief       Process the ZDO_AuthenticateInd_t message.
   2995           *
   2996           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   2997           *
   2998           * @return      none
   2999           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3000          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   3001          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV       A,#-0x14
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   3002            APSME_AuthenticateReq_t req;
   3003            AddrMgrEntry_t          entry;
   3004          
   3005          
   3006            // update the address manager
   3007            //---------------------------------------------------------------------------
   3008            // note:
   3009            // required for EA processing, but ultimately EA logic could also use the
   3010            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3011            // table is supposed to have authentication states for neighbors
   3012            //---------------------------------------------------------------------------
   3013            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV       A,#0x7
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   7402         MOV       A,#0x2
   \   000015   F0           MOVX      @DPTR,A
   3014            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   EA           MOV       A,R2
   \   000017   2402         ADD       A,#0x2
   \   000019   F5..         MOV       ?V2,A
   \   00001B   E4           CLR       A
   \   00001C   3F           ADDC      A,R7
   \   00001D   F5..         MOV       ?V3,A
   \   00001F   85..82       MOV       DPL,?V2
   \   000022   F583         MOV       DPH,A
   \   000024   12....       LCALL     ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000027   7408         MOV       A,#0x8
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   3015            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \                     ??CrossCallReturnLabel_224:
   \   00002F   EA           MOV       A,R2
   \   000030   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000033                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000033   AC..         MOV       R4,?V0
   \   000035   FD           MOV       R5,A
   \   000036   740A         MOV       A,#0xa
   \   000038   12....       LCALL     ?XSTACK_DISP0_8
   \   00003B   AA82         MOV       R2,DPL
   \   00003D   AB83         MOV       R3,DPH
   \   00003F   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   3016          
   3017            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000042                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000042   7407         MOV       A,#0x7
   \   000044   12....       LCALL     ?XSTACK_DISP101_8
   \   000047   12....       LCALL     ??Subroutine89_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   00004A   702A         JNZ       ??ZDSecMgrAuthenticateInd_0
   3018            {
   3019              // set request fields
   3020              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00004C   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   00004F   12....       LCALL     ?Subroutine29 & 0xFFFF
   3021              req.extAddr   = ind->aps.initExtAddr;
   \                     ??CrossCallReturnLabel_213:
   \   000052   12....       LCALL     ?XSTACK_DISP0_8
   \   000055   E5..         MOV       A,?V0
   \   000057   F0           MOVX      @DPTR,A
   \   000058   A3           INC       DPTR
   \   000059   E5..         MOV       A,?V1
   \   00005B   F0           MOVX      @DPTR,A
   3022              req.action    = APSME_EA_ACCEPT;
   \   00005C   7406         MOV       A,#0x6
   \   00005E   12....       LCALL     ?XSTACK_DISP0_8
   \   000061   7401         MOV       A,#0x1
   \   000063   F0           MOVX      @DPTR,A
   3023              req.challenge = ind->aps.challenge;
   \   000064   EE           MOV       A,R6
   \   000065   240C         ADD       A,#0xc
   \   000067   F8           MOV       R0,A
   \   000068   E4           CLR       A
   \   000069   3F           ADDC      A,R7
   \   00006A   F9           MOV       R1,A
   \   00006B   7404         MOV       A,#0x4
   \   00006D   12....       LCALL     ?XSTACK_DISP0_8
   \   000070   12....       LCALL     ?Subroutine11 & 0xFFFF
   3024          
   3025              // start EA processing
   3026              APSME_AuthenticateReq( &req );
   3027            }
   \                     ??CrossCallReturnLabel_2:
   \   000073   12....       LCALL     `??APSME_AuthenticateReq::?relay`; Banked call to: APSME_AuthenticateReq
   3028          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   000076   7414         MOV       A,#0x14
   \   000078   02....       LJMP      ??Subroutine109_0 & 0xFFFF
   3029          
   3030          /******************************************************************************
   3031           * @fn          ZDSecMgrAuthenticateCfm
   3032           *
   3033           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3034           *
   3035           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3036           *
   3037           * @return      none
   3038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3039          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3040          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3041            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV       A,R2
   \   000005   240B         ADD       A,#0xb
   \   000007   F582         MOV       DPL,A
   \   000009   E4           CLR       A
   \   00000A   3B           ADDC      A,R3
   \   00000B   F583         MOV       DPH,A
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   701F         JNZ       ??ZDSecMgrAuthenticateCfm_0
   3042            {
   3043              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000010   8A82         MOV       DPL,R2
   \   000012   8B83         MOV       DPH,R3
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   6401         XRL       A,#0x1
   \   000019   7014         JNZ       ??ZDSecMgrAuthenticateCfm_0
   \   00001B   90....       MOV       DPTR,#devState
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   6405         XRL       A,#0x5
   \   000021   700C         JNZ       ??ZDSecMgrAuthenticateCfm_0
   3044              {
   3045                // inform ZDO that device has been authenticated
   3046                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000023                ; Setup parameters for call to function osal_set_event
   \   000023   7A80         MOV       R2,#-0x80
   \   000025   7B00         MOV       R3,#0x0
   \   000027   90....       MOV       DPTR,#ZDAppTaskID
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F9           MOV       R1,A
   \   00002C   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   3047              }
   3048            }
   3049          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   00002F   02....       LJMP      ??Subroutine105_0 & 0xFFFF
   3050          
   3051          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3052          /******************************************************************************
   3053           * @fn          ZDSecMgrUpdateNwkKey
   3054           *
   3055           * @brief       Load a new NWK key and trigger a network wide update.
   3056           *
   3057           * @param       key       - [in] new NWK key
   3058           * @param       keySeqNum - [in] new NWK key sequence number
   3059           *
   3060           * @return      ZStatus_t
   3061           */
   3062          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3063          {
   3064            ZStatus_t               status;
   3065            APSME_TransportKeyReq_t req;
   3066          
   3067            // initialize common elements of local variables
   3068            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3069              req.keyType   = KEY_TYPE_NWK_HIGH;
   3070            else
   3071              req.keyType   = KEY_TYPE_NWK;
   3072          
   3073            req.dstAddr   = dstAddr;
   3074            req.keySeqNum = keySeqNum;
   3075            req.key       = key;
   3076            req.extAddr   = NULL;
   3077            req.nwkSecure = TRUE;
   3078            req.apsSecure = TRUE;
   3079            req.tunnel    = NULL;
   3080          
   3081            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3082            {
   3083              ZDSecMgrEntry_t*        entry;
   3084              uint16                  index;
   3085              AddrMgrEntry_t          addrEntry;
   3086          
   3087              addrEntry.user = ADDRMGR_USER_SECURITY;
   3088          
   3089              status = ZFailure;
   3090          
   3091              // verify data is available
   3092              if ( ZDSecMgrEntries != NULL )
   3093              {
   3094                // find available entry
   3095                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3096                {
   3097                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3098                  {
   3099                    // return successful result
   3100                    entry = &ZDSecMgrEntries[index];
   3101          
   3102                    // get NWK address
   3103                    addrEntry.index = entry->ami;
   3104                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3105                    {
   3106                      req.dstAddr = addrEntry.nwkAddr;
   3107                      req.extAddr = addrEntry.extAddr;
   3108                      status = APSME_TransportKeyReq( &req );
   3109                    }
   3110                  }
   3111                }
   3112              }
   3113            }
   3114            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3115            {
   3116              status = APSME_TransportKeyReq( &req );
   3117            }
   3118          
   3119            SSP_UpdateNwkKey( key, keySeqNum );
   3120          
   3121            // Save if nv
   3122            ZDApp_NVUpdate();
   3123          
   3124            return status;
   3125          }
   3126          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3127          
   3128          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3129          /******************************************************************************
   3130           * @fn          ZDSecMgrSwitchNwkKey
   3131           *
   3132           * @brief       Causes the NWK key to switch via a network wide command.
   3133           *
   3134           * @param       keySeqNum - [in] new NWK key sequence number
   3135           *
   3136           * @return      ZStatus_t
   3137           */
   3138          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3139          {
   3140            ZStatus_t            status;
   3141            APSME_SwitchKeyReq_t req;
   3142          
   3143            // initialize common elements of local variables
   3144            req.dstAddr = dstAddr;
   3145            req.keySeqNum = keySeqNum;
   3146          
   3147            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3148            {
   3149              ZDSecMgrEntry_t*     entry;
   3150              uint16               index;
   3151              AddrMgrEntry_t       addrEntry;
   3152          
   3153              addrEntry.user = ADDRMGR_USER_SECURITY;
   3154          
   3155              status = ZFailure;
   3156          
   3157              // verify data is available
   3158              if ( ZDSecMgrEntries != NULL )
   3159              {
   3160                // find available entry
   3161                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3162                {
   3163                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3164                  {
   3165                    // return successful result
   3166                    entry = &ZDSecMgrEntries[index];
   3167          
   3168                    // get NWK address
   3169                    addrEntry.index = entry->ami;
   3170          
   3171                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3172                    {
   3173                      req.dstAddr = addrEntry.nwkAddr;
   3174                      status = APSME_SwitchKeyReq( &req );
   3175                    }
   3176                  }
   3177                }
   3178              }
   3179            }
   3180            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3181            {
   3182              status = APSME_SwitchKeyReq( &req );
   3183            }
   3184          
   3185            SSP_SwitchNwkKey( keySeqNum );
   3186          
   3187            // Save if nv
   3188            ZDApp_NVUpdate();
   3189          
   3190            return status;
   3191          }
   3192          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3193          
   3194          #if ( ZG_BUILD_JOINING_TYPE )
   3195          /******************************************************************************
   3196           * @fn          ZDSecMgrRequestAppKey
   3197           *
   3198           * @brief       Request an application key with partner.
   3199           *
   3200           * @param       partNwkAddr - [in] partner network address
   3201           *
   3202           * @return      ZStatus_t
   3203           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3204          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   \                     ZDSecMgrRequestAppKey:
   3205          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 12
   \   000004   74F4         MOV       A,#-0xc
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   3206            ZStatus_t             status;
   3207            APSME_RequestKeyReq_t req;
   3208            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3209          
   3210          
   3211            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   \   000009                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000009   7404         MOV       A,#0x4
   \   00000B   12....       LCALL     ?XSTACK_DISP102_8
   \   00000E   12....       LCALL     `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
   \   000011   E9           MOV       A,R1
   \   000012   6023         JZ        ??ZDSecMgrRequestAppKey_0
   3212            {
   3213              req.dstAddr = 0;
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   E4           CLR       A
   \   00001B   F0           MOVX      @DPTR,A
   3214              req.keyType = KEY_TYPE_APP_MASTER;
   \   00001C   04           INC       A
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   7402         MOV       A,#0x2
   \   000022   F0           MOVX      @DPTR,A
   3215              req.partExtAddr = partExtAddr;
   \   000023   7404         MOV       A,#0x4
   \   000025   12....       LCALL     ?XSTACK_DISP100_8
   \   000028   7402         MOV       A,#0x2
   \   00002A   12....       LCALL     ?XSTACK_DISP0_8
   \   00002D   12....       LCALL     ?Subroutine11 & 0xFFFF
   3216              status = APSME_RequestKeyReq( &req );
   3217            }
   \                     ??CrossCallReturnLabel_3:
   \   000030   12....       LCALL     `??APSME_RequestKeyReq::?relay`; Banked call to: APSME_RequestKeyReq
   \   000033   E9           MOV       A,R1
   \   000034   F9           MOV       R1,A
   \   000035   8002         SJMP      ??ZDSecMgrRequestAppKey_1
   3218            else
   3219            {
   3220              status = ZFailure;
   \                     ??ZDSecMgrRequestAppKey_0:
   \   000037   7901         MOV       R1,#0x1
   3221            }
   3222          
   3223            return status;
   \                     ??ZDSecMgrRequestAppKey_1:
   \   000039   740C         MOV       A,#0xc
   \   00003B   02....       LJMP      ??Subroutine93_0 & 0xFFFF
   3224          }
   3225          #endif // ( ZG_BUILD_JOINING_TYPE )
   3226          
   3227          #if ( ZG_BUILD_JOINING_TYPE )
   3228          /******************************************************************************
   3229           * @fn          ZDSecMgrSetupPartner
   3230           *
   3231           * @brief       Setup for application key partner.
   3232           *
   3233           * @param       partNwkAddr - [in] partner network address
   3234           *
   3235           * @return      ZStatus_t
   3236           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3237          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3238          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   8C..         MOV       ?V0,R4
   \   000010   8D..         MOV       ?V1,R5
   3239            AddrMgrEntry_t entry;
   3240            ZStatus_t      status;
   3241          
   3242            status = ZFailure;
   \   000012   75..01       MOV       ?V2,#0x1
   3243          
   3244            // update the address manager
   3245            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV       DPL,?XSP + 0
   \   000018   85..83       MOV       DPH,?XSP + 1
   \   00001B   7402         MOV       A,#0x2
   \   00001D   F0           MOVX      @DPTR,A
   3246            entry.nwkAddr = partNwkAddr;
   \   00001E   14           DEC       A
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   12....       LCALL     ?Subroutine24 & 0xFFFF
   3247            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \                     ??CrossCallReturnLabel_27:
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   AA82         MOV       R2,DPL
   \   00002A   AB83         MOV       R3,DPH
   \   00002C   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   3248          
   3249            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00002F                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00002F   12....       LCALL     ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000032   7036         JNZ       ??ZDSecMgrSetupPartner_0
   3250            {
   3251              status = ZSuccess;
   \   000034   75..00       MOV       ?V2,#0x0
   3252          
   3253              // check for address discovery
   3254              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000037   74FE         MOV       A,#-0x2
   \   000039   6E           XRL       A,R6
   \   00003A   7003         JNZ       ??ZDSecMgrSetupPartner_1
   \   00003C   74FF         MOV       A,#-0x1
   \   00003E   6F           XRL       A,R7
   \                     ??ZDSecMgrSetupPartner_1:
   \   00003F   700F         JNZ       ??ZDSecMgrSetupPartner_2
   3255              {
   3256                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000041                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   000041   7D00         MOV       R5,#0x0
   \   000043   7C00         MOV       R4,#0x0
   \   000045   7900         MOV       R1,#0x0
   \   000047   AA..         MOV       R2,?V0
   \   000049   AB..         MOV       R3,?V1
   \   00004B   12....       LCALL     `??ZDP_NwkAddrReq::?relay`; Banked call to: ZDP_NwkAddrReq
   \   00004E   8017         SJMP      ??ZDSecMgrSetupPartner_3
   3257              }
   3258              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   000050                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000050   AA..         MOV       R2,?V0
   \   000052   AB..         MOV       R3,?V1
   \   000054   12....       LCALL     `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000057   E9           MOV       A,R1
   \   000058   7010         JNZ       ??ZDSecMgrSetupPartner_0
   3259              {
   3260                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00005A                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   00005A   7D00         MOV       R5,#0x0
   \   00005C   7C00         MOV       R4,#0x0
   \   00005E   7900         MOV       R1,#0x0
   \   000060   EE           MOV       A,R6
   \   000061   FA           MOV       R2,A
   \   000062   EF           MOV       A,R7
   \   000063   FB           MOV       R3,A
   \   000064   12....       LCALL     `??ZDP_IEEEAddrReq::?relay`; Banked call to: ZDP_IEEEAddrReq
   \                     ??ZDSecMgrSetupPartner_3:
   \   000067   E9           MOV       A,R1
   \   000068   F5..         MOV       ?V2,A
   3261              }
   3262            }
   3263          
   3264            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   00006A   A9..         MOV       R1,?V2
   \   00006C   740D         MOV       A,#0xd
   \   00006E   02....       LJMP      ?Subroutine6 & 0xFFFF
   3265          }
   3266          #endif // ( ZG_BUILD_JOINING_TYPE )
   3267          
   3268          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3269          /******************************************************************************
   3270           * @fn          ZDSecMgrAppKeyTypeSet
   3271           *
   3272           * @brief       Set application key type.
   3273           *
   3274           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3275           *                                                   KEY_TYPE_APP_LINK@3
   3276           *
   3277           * @return      ZStatus_t
   3278           */
   3279          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3280          {
   3281            if ( keyType == KEY_TYPE_APP_LINK )
   3282            {
   3283              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3284            }
   3285            else
   3286            {
   3287              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3288            }
   3289          
   3290            return ZSuccess;
   3291          }
   3292          #endif
   3293          
   3294          /******************************************************************************
   3295           * ZigBee Device Security Manager - Stub Implementations
   3296           */
   3297          /******************************************************************************
   3298           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3299           *
   3300           * @brief       Get MASTER key for specified EXT address.
   3301           *
   3302           * @param       extAddr - [in] EXT address
   3303           * @param       pKeyNvId - [out] MASTER key NV ID
   3304           *
   3305           * @return      ZStatus_t
   3306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3307          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint16* pKeyNvId )
   \                     APSME_MasterKeyGet:
   3308          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3309            ZStatus_t status;
   3310            uint16 ami;
   3311          
   3312          
   3313            // lookup entry for specified EXT address
   3314            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   F5..         MOV       ?V0,A
   3315          
   3316            if ( status == ZSuccess )
   \   000018   7012         JNZ       ??APSME_MasterKeyGet_0
   3317            {
   3318              ZDSecMgrMasterKeyLookup( ami, pKeyNvId );
   \   00001A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00001A   EE           MOV       A,R6
   \   00001B   FC           MOV       R4,A
   \   00001C   EF           MOV       A,R7
   \   00001D   FD           MOV       R5,A
   \   00001E   85..82       MOV       DPL,?XSP + 0
   \   000021   85..83       MOV       DPH,?XSP + 1
   \   000024   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   3319            }
   \                     ??CrossCallReturnLabel_169:
   \   000027   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   00002A   8008         SJMP      ??APSME_MasterKeyGet_1
   3320            else
   3321            {
   3322              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_MasterKeyGet_0:
   \   00002C   8E82         MOV       DPL,R6
   \   00002E   8F83         MOV       DPH,R7
   \   000030   E4           CLR       A
   \   000031   F0           MOVX      @DPTR,A
   \   000032   A3           INC       DPTR
   \   000033   F0           MOVX      @DPTR,A
   3323            }
   3324          
   3325            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   000034   02....       LJMP      ?Subroutine1 & 0xFFFF
   3326          }
   3327          
   3328          /******************************************************************************
   3329           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3330           *
   3331           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3332           *
   3333           * @param       extAddr - [in] EXT address
   3334           * @param       data    - [in] APSME_LinkKeyData_t
   3335           *
   3336           * @return      ZStatus_t
   3337           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3338          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3339          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8C..         MOV       ?V2,R4
   \   00000C   8D..         MOV       ?V3,R5
   3340            ZStatus_t status;
   3341            ZDSecMgrEntry_t* entry;
   3342            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3343            uint16 Index;
   3344          
   3345            // lookup entry index for specified EXT address
   3346            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index ); 
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExtGetIndex
   \   00000E   7402         MOV       A,#0x2
   \   000010   12....       LCALL     ?XSTACK_DISP100_8
   \   000013   88..         MOV       ?V0,R0
   \   000015   89..         MOV       ?V1,R1
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP102_8
   \   000021   12....       LCALL     `??ZDSecMgrEntryLookupExtGetIndex::?relay`; Banked call to: ZDSecMgrEntryLookupExtGetIndex
   \   000024   7402         MOV       A,#0x2
   \   000026   12....       LCALL     ?DEALLOC_XSTACK8
   \   000029   E9           MOV       A,R1
   \   00002A   FE           MOV       R6,A
   3347          
   3348            if ( status == ZSuccess )
   \   00002B   6003         JZ        $+5
   \   00002D   02....       LJMP      ??CrossCallReturnLabel_287 & 0xFFFF
   3349            {
   3350              // point to NV item
   3351              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000030   7402         MOV       A,#0x2
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   E0           MOVX      A,@DPTR
   \   000036   2401         ADD       A,#0x1
   \   000038   F8           MOV       R0,A
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   3402         ADDC      A,#0x2
   \   00003D   F9           MOV       R1,A
   \   00003E   85..82       MOV       DPL,?XSP + 0
   \   000041   85..83       MOV       DPH,?XSP + 1
   \   000044   12....       LCALL     ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000047   12....       LCALL     ?Subroutine34 & 0xFFFF
   3352          
   3353              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \                     ??CrossCallReturnLabel_227:
   \   00004A                ; Setup parameters for call to function osal_mem_alloc
   \   00004A   12....       LCALL     ?Subroutine64 & 0xFFFF
   3354          
   3355              if (pApsLinkKey != NULL)
   \                     ??CrossCallReturnLabel_312:
   \   00004D   7003         JNZ       $+5
   \   00004F   02....       LJMP      ??CrossCallReturnLabel_287 & 0xFFFF
   3356              {
   3357                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3358                osal_nv_read( entry->keyNvId, 0, 
   3359                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000052                ; Setup parameters for call to function osal_nv_read
   \   000052   78..         MOV       R0,#?V0
   \   000054   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000057   75..18       MOV       ?V4,#0x18
   \   00005A   75..00       MOV       ?V5,#0x0
   \   00005D   78..         MOV       R0,#?V4
   \   00005F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000062   7C00         MOV       R4,#0x0
   \   000064   7D00         MOV       R5,#0x0
   \   000066   7404         MOV       A,#0x4
   \   000068   12....       LCALL     ?XSTACK_DISP0_8
   \   00006B   12....       LCALL     ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   00006E   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   000071   12....       LCALL     ?DEALLOC_XSTACK8
   3360                
   3361                // set new values of the key 
   3362                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   000074                ; Setup parameters for call to function osal_memcpy
   \   000074   85....       MOV       ?V4,?V2
   \   000077   85....       MOV       ?V5,?V3
   \   00007A   75..00       MOV       ?V6,#0x0
   \   00007D   78..         MOV       R0,#?V4
   \   00007F   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000082   7C10         MOV       R4,#0x10
   \   000084   7D00         MOV       R5,#0x0
   \   000086   AA..         MOV       R2,?V0
   \   000088   AB..         MOV       R3,?V1
   \   00008A   12....       LCALL     ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   00008D   12....       LCALL     ?DEALLOC_XSTACK8
   3363                pApsLinkKey->rxFrmCntr = 0;
   \   000090   E5..         MOV       A,?V0
   \   000092   2414         ADD       A,#0x14
   \   000094   12....       LCALL     ?Subroutine12 & 0xFFFF
   3364                pApsLinkKey->txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_288:
   \   000097   E5..         MOV       A,?V0
   \   000099   2410         ADD       A,#0x10
   \   00009B   12....       LCALL     ?Subroutine12 & 0xFFFF
   3365                
   3366                osal_nv_write( entry->keyNvId, 0, 
   3367                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \                     ??CrossCallReturnLabel_289:
   \   00009E                ; Setup parameters for call to function osal_nv_write
   \   00009E   78..         MOV       R0,#?V0
   \   0000A0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A3   75..18       MOV       ?V2,#0x18
   \   0000A6   75..00       MOV       ?V3,#0x0
   \   0000A9   78..         MOV       R0,#?V2
   \   0000AB   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AE   7C00         MOV       R4,#0x0
   \   0000B0   7D00         MOV       R5,#0x0
   \   0000B2   7404         MOV       A,#0x4
   \   0000B4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B7   12....       LCALL     ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   0000BA   12....       LCALL     ??Subroutine123_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   0000BD   12....       LCALL     ?DEALLOC_XSTACK8
   3368                
   3369                // clear copy of key in RAM 
   3370                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   0000C0                ; Setup parameters for call to function osal_memset
   \   0000C0   12....       LCALL     ?Subroutine37 & 0xFFFF
   3371                
   3372                osal_mem_free(pApsLinkKey);
   \                     ??CrossCallReturnLabel_266:
   \   0000C3   12....       LCALL     ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   0000C6   12....       LCALL     ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   0000C9   E8           MOV       A,R0
   \   0000CA   75F009       MOV       B,#0x9
   \   0000CD   A4           MUL       AB
   \   0000CE   F8           MOV       R0,A
   \   0000CF   AAF0         MOV       R2,B
   \   0000D1   75F009       MOV       B,#0x9
   \   0000D4   E9           MOV       A,R1
   \   0000D5   A4           MUL       AB
   \   0000D6   2A           ADD       A,R2
   \   0000D7   F9           MOV       R1,A
   \   0000D8   74..         MOV       A,#ApsLinkKeyFrmCntr & 0xff
   \   0000DA   28           ADD       A,R0
   \   0000DB   F8           MOV       R0,A
   \   0000DC   74..         MOV       A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   0000DE   39           ADDC      A,R1
   \   0000DF   F9           MOV       R1,A
   \   0000E0   E8           MOV       A,R0
   \   0000E1   24F7         ADD       A,#-0x9
   \   0000E3   F582         MOV       DPL,A
   \   0000E5   E9           MOV       A,R1
   \   0000E6   34ED         ADDC      A,#-0x13
   \   0000E8   12....       LCALL     ??Subroutine125_0 & 0xFFFF
   3373                
   3374                // set initial values for counters in RAM
   3375                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   3376                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_286:
   \   0000EB   E8           MOV       A,R0
   \   0000EC   24FB         ADD       A,#-0x5
   \   0000EE   F582         MOV       DPL,A
   \   0000F0   E9           MOV       A,R1
   \   0000F1   34ED         ADDC      A,#-0x13
   \   0000F3   12....       LCALL     ??Subroutine125_0 & 0xFFFF
   3377              }
   3378            }
   3379          
   3380            return status;
   \                     ??CrossCallReturnLabel_287:
   \   0000F6   EE           MOV       A,R6
   \   0000F7   F9           MOV       R1,A
   \   0000F8   7404         MOV       A,#0x4
   \   0000FA   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000FD   7F07         MOV       R7,#0x7
   \   0000FF   02....       LJMP      ?BANKED_LEAVE_XDATA
   3381          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   7C18         MOV       R4,#0x18
   \   000002                REQUIRE ??Subroutine122_0
   \   000002                ; // Fall through to label ??Subroutine122_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine122_0:
   \   000000   7D00         MOV       R5,#0x0
   \   000002   7900         MOV       R1,#0x0
   \   000004   AA..         MOV       R2,?V0
   \   000006   AB..         MOV       R3,?V1
   \   000008   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   \   00000B                ; Setup parameters for call to function osal_mem_free
   \   00000B                ; Setup parameters for call to function osal_mem_free
   \   00000B                ; Setup parameters for call to function osal_mem_free
   \   00000B   AA..         MOV       R2,?V0
   \   00000D   AB..         MOV       R3,?V1
   \   00000F   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   F582         MOV       DPL,A
   \   000002   E4           CLR       A
   \   000003   35..         ADDC      A,?V1
   \   000005                REQUIRE ??Subroutine125_0
   \   000005                ; // Fall through to label ??Subroutine125_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine125_0:
   \   000000   F583         MOV       DPH,A
   \   000002                REQUIRE ??Subroutine126_0
   \   000002                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   F0           MOVX      @DPTR,A
   \   000004   A3           INC       DPTR
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   F0           MOVX      @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine127_0
   \   000006                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   12....       LCALL     ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL     ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   000003   12....       LCALL     ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   7A18         MOV       R2,#0x18
   \   000002                REQUIRE ??Subroutine129_0
   \   000002                ; // Fall through to label ??Subroutine129_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine129_0:
   \   000000   7B00         MOV       R3,#0x0
   \   000002   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EA           MOV       A,R2
   \   00000A   4B           ORL       A,R3
   \   00000B   22           RET
   3382          
   3383          /******************************************************************************
   3384           * @fn          ZDSecMgrAuthenticationSet
   3385           *
   3386           * @brief       Mark the specific device as authenticated or not
   3387           *
   3388           * @param       extAddr - [in] EXT address
   3389           * @param       option  - [in] authenticated or not
   3390           *
   3391           * @return      ZStatus_t
   3392           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3393          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3394          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   3395            ZStatus_t        status;
   3396            ZDSecMgrEntry_t* entry;
   3397          
   3398          
   3399            // lookup entry index for specified EXT address
   3400            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   AC..         MOV       R4,?XSP + 0
   \   00000E   AD..         MOV       R5,?XSP + 1
   \   000010   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000013   E9           MOV       A,R1
   \   000014   F9           MOV       R1,A
   3401          
   3402            if ( status == ZSuccess )
   \   000015   7007         JNZ       ??ZDSecMgrAuthenticationSet_0
   3403            {
   3404              entry->authenticateOption = option;
   \   000017   12....       LCALL     ?Subroutine53 & 0xFFFF
   3405            }
   \                     ??CrossCallReturnLabel_292:
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   EE           MOV       A,R6
   \   00001D   F0           MOVX      @DPTR,A
   3406          
   3407            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   00001E   02....       LJMP      ??Subroutine99_0 & 0xFFFF
   3408          }
   3409          
   3410          /******************************************************************************
   3411           * @fn          ZDSecMgrAuthenticationCheck
   3412           *
   3413           * @brief       Check if the specific device has been authenticated or not
   3414           *              For non-trust center device, always return true
   3415           *
   3416           * @param       shortAddr - [in] short address
   3417           *
   3418           * @return      TRUE @ authenticated with CBKE
   3419           *              FALSE @ not authenticated
   3420           */
   3421          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3422          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3423          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3424          #if defined (TC_LINKKEY_JOIN)
   3425          
   3426            ZDSecMgrEntry_t* entry;
   3427            uint8 extAddr[Z_EXTADDR_LEN];
   3428          
   3429            // If the local device is not the trust center, always return TRUE
   3430            if ( NLME_GetShortAddr() != TCshortAddr )
   3431            {
   3432              return TRUE;
   3433            }
   3434            // Otherwise, check the authentication option
   3435            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3436            {
   3437              // lookup entry index for specified EXT address
   3438              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3439              {
   3440                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3441                {
   3442                  return TRUE;
   3443                }
   3444                else
   3445                {
   3446                  return FALSE;
   3447                }
   3448              }
   3449            }
   3450            return FALSE;
   3451          
   3452          #else
   3453            (void)shortAddr;  // Intentionally unreferenced parameter
   3454            
   3455            // For non AMI/SE Profile, perform no check and always return true.
   3456            return TRUE;
   \   000000   7901         MOV       R1,#0x1
   \   000002   02....       LJMP      ?BRET
   3457          
   3458          #endif // TC_LINKKEY_JOIN
   3459          }
   3460          
   3461          
   3462          /******************************************************************************
   3463           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   3464           *
   3465           * @brief       Get Key NV ID for specified NWK address.
   3466           *
   3467           * @param       extAddr - [in] EXT address
   3468           * @param       keyNvId - [out] NV ID
   3469           *
   3470           * @return      ZStatus_t
   3471           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3472          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   3473          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3474            ZStatus_t status;
   3475            ZDSecMgrEntry_t* entry;
   3476          
   3477            // lookup entry index for specified NWK address
   3478            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000015   E9           MOV       A,R1
   \   000016   F9           MOV       R1,A
   3479          
   3480            if ( status == ZSuccess )
   \   000017   7014         JNZ       ??APSME_LinkKeyNVIdGet_0
   3481            {
   3482              // return the index to the NV table
   3483              *pKeyNvId = entry->keyNvId;
   \   000019   85..82       MOV       DPL,?XSP + 0
   \   00001C   85..83       MOV       DPH,?XSP + 1
   \   00001F   12....       LCALL     ?Subroutine52 & 0xFFFF
   3484            }
   \                     ??CrossCallReturnLabel_59:
   \   000022   FB           MOV       R3,A
   \   000023   8E82         MOV       DPL,R6
   \   000025   8F83         MOV       DPH,R7
   \   000027   EA           MOV       A,R2
   \   000028   F0           MOVX      @DPTR,A
   \   000029   A3           INC       DPTR
   \   00002A   EB           MOV       A,R3
   \   00002B   8007         SJMP      ??APSME_LinkKeyNVIdGet_1
   3485            else
   3486            {
   3487              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   00002D   8E82         MOV       DPL,R6
   \   00002F   8F83         MOV       DPH,R7
   \   000031   E4           CLR       A
   \   000032   F0           MOVX      @DPTR,A
   \   000033   A3           INC       DPTR
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   000034   F0           MOVX      @DPTR,A
   3488            }
   3489          
   3490            return status;
   \   000035   02....       LJMP      ??Subroutine99_0 & 0xFFFF
   3491          }
   3492          
   3493          /******************************************************************************
   3494           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   3495           *
   3496           * @brief       Verifies if Link Key in NV has been set.
   3497           *
   3498           * @param       extAddr - [in] EXT address
   3499           *
   3500           * @return      TRUE - Link Key has been established
   3501           *              FALSE - Link Key in NV has default value.
   3502           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3503          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   3504          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   3505            APSME_LinkKeyData_t *pKeyData = NULL;
   3506            uint16 apsLinkKeyNvId;
   3507            uint8 nullKey[SEC_KEY_LEN];
   3508            uint8 status = FALSE;
   \   00000E   7E00         MOV       R6,#0x0
   3509          
   3510            // initialize default vealue to compare to
   3511            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   000010                ; Setup parameters for call to function osal_memset
   \   000010   7C10         MOV       R4,#0x10
   \   000012   7D00         MOV       R5,#0x0
   \   000014   7900         MOV       R1,#0x0
   \   000016   7402         MOV       A,#0x2
   \   000018   12....       LCALL     ?XSTACK_DISP101_8
   \   00001B   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3512          
   3513            // check for APS link NV ID
   3514            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \   00001E                ; Setup parameters for call to function APSME_LinkKeyNVIdGet
   \   00001E   AC..         MOV       R4,?XSP + 0
   \   000020   AD..         MOV       R5,?XSP + 1
   \   000022   AA..         MOV       R2,?V0
   \   000024   AB..         MOV       R3,?V1
   \   000026   12....       LCALL     `??APSME_LinkKeyNVIdGet::?relay`; Banked call to: APSME_LinkKeyNVIdGet
   3515          
   3516            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   000029   12....       LCALL     ??Subroutine112_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   00002C   605D         JZ        ??APSME_IsLinkKeyValid_0
   3517            {
   3518              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00002E                ; Setup parameters for call to function osal_mem_alloc
   \   00002E   7A18         MOV       R2,#0x18
   \   000030   7B00         MOV       R3,#0x0
   \   000032   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000035   8A..         MOV       ?V4,R2
   \   000037   8B..         MOV       ?V5,R3
   3519              
   3520              if (pKeyData != NULL)
   \   000039   EA           MOV       A,R2
   \   00003A   4B           ORL       A,R3
   \   00003B   604E         JZ        ??APSME_IsLinkKeyValid_0
   3521              {
   3522                // retrieve key from NV
   3523                if ( osal_nv_read( apsLinkKeyNvId, 0, 
   3524                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   00003D                ; Setup parameters for call to function osal_nv_read
   \   00003D   78..         MOV       R0,#?V4
   \   00003F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000042   75..18       MOV       ?V0,#0x18
   \   000045   8E..         MOV       ?V1,R6
   \   000047   78..         MOV       R0,#?V0
   \   000049   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004C   7C00         MOV       R4,#0x0
   \   00004E   7D00         MOV       R5,#0x0
   \   000050   7404         MOV       A,#0x4
   \   000052   12....       LCALL     ?XSTACK_DISP0_8
   \   000055   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000058   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005B   E9           MOV       A,R1
   \   00005C   702D         JNZ       ??APSME_IsLinkKeyValid_0
   3525                {
   3526                  // if stored key is different than default value, then a key has been established
   3527                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   00005E                ; Setup parameters for call to function osal_memcmp
   \   00005E   7402         MOV       A,#0x2
   \   000060   12....       LCALL     ?XSTACK_DISP100_8
   \   000063   88..         MOV       ?V0,R0
   \   000065   89..         MOV       ?V1,R1
   \   000067   8E..         MOV       ?V2,R6
   \   000069   78..         MOV       R0,#?V0
   \   00006B   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00006E   7C10         MOV       R4,#0x10
   \   000070   7D00         MOV       R5,#0x0
   \   000072   85..82       MOV       DPL,?V4
   \   000075   85..83       MOV       DPH,?V5
   \   000078   A982         MOV       R1,DPL
   \   00007A   AA83         MOV       R2,DPH
   \   00007C   7B00         MOV       R3,#0x0
   \   00007E   12....       LCALL     `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   000081   7403         MOV       A,#0x3
   \   000083   12....       LCALL     ?DEALLOC_XSTACK8
   \   000086   E9           MOV       A,R1
   \   000087   7002         JNZ       ??APSME_IsLinkKeyValid_0
   3528                  {
   3529                    status = TRUE;
   \   000089   7E01         MOV       R6,#0x1
   3530                  }
   3531                }
   3532              }
   3533            }
   3534          
   3535            return status;
   \                     ??APSME_IsLinkKeyValid_0:
   \   00008B   EE           MOV       A,R6
   \   00008C   F9           MOV       R1,A
   \   00008D   7412         MOV       A,#0x12
   \   00008F   02....       LJMP      ?Subroutine4 & 0xFFFF
   3536          }
   3537          
   3538          /******************************************************************************
   3539           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3540           *
   3541           * @brief       Verify and process key transportation to child.
   3542           *
   3543           * @param       ind - [in] APSME_TransportKeyInd_t
   3544           *
   3545           * @return      uint8 - success(TRUE:FALSE)
   3546           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3547          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3548          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3549            uint8 success;
   3550          
   3551            success = FALSE;
   \   000005   7E00         MOV       R6,#0x0
   3552          
   3553            // verify from Trust Center
   3554            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000007   8A82         MOV       DPL,R2
   \   000009   8B83         MOV       DPH,R3
   \   00000B   12....       LCALL     ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   00000E   7028         JNZ       ??APSME_KeyFwdToChild_0
   3555            {
   3556              success = TRUE;
   \   000010   7E01         MOV       R6,#0x1
   3557          
   3558              // check for initial NWK key
   3559              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3560                   ( ind->keyType == 6                 ) ||
   3561                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F8           MOV       R0,A
   \   00001A   EE           MOV       A,R6
   \   00001B   68           XRL       A,R0
   \   00001C   600A         JZ        ??APSME_KeyFwdToChild_1
   \   00001E   7406         MOV       A,#0x6
   \   000020   68           XRL       A,R0
   \   000021   6005         JZ        ??APSME_KeyFwdToChild_1
   \   000023   7405         MOV       A,#0x5
   \   000025   68           XRL       A,R0
   \   000026   7010         JNZ       ??APSME_KeyFwdToChild_0
   3562              {
   3563                // set association status to authenticated
   3564                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   000028                ; Setup parameters for call to function AssocGetWithExt
   \   000028   8A82         MOV       DPL,R2
   \   00002A   8B83         MOV       DPH,R3
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   12....       LCALL     ?Subroutine61 & 0xFFFF
   3565              }
   3566            }
   \                     ??CrossCallReturnLabel_76:
   \   000035                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000035   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   3567          
   3568            return success;
   \                     ??APSME_KeyFwdToChild_0:
   \   000038   EE           MOV       A,R6
   \   000039   F9           MOV       R1,A
   \   00003A   02....       LJMP      ??Subroutine115_0 & 0xFFFF
   3569          }
   3570          
   3571          /******************************************************************************
   3572           * @fn          ZDSecMgrAddLinkKey
   3573           *
   3574           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3575           *              as authenticated in the authenticateOption. Note that this function
   3576           *              is hardwared to CBKE right now.
   3577           *
   3578           * @param       shortAddr - short address of the partner device
   3579           * @param       extAddr - extended address of the partner device
   3580           * @param       key - link key
   3581           *
   3582           * @return      ZStatus_t
   3583           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3584          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3585          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3586            uint16           ami;
   3587            ZDSecMgrEntry_t* entry;
   3588          
   3589            /* Store the device address in the addr manager */
   3590            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00000E   7402         MOV       A,#0x2
   \   000010   12....       LCALL     ?XSTACK_DISP100_8
   \   000013   88..         MOV       ?V0,R0
   \   000015   89..         MOV       ?V1,R1
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   00001F   7402         MOV       A,#0x2
   \   000021   12....       LCALL     ?DEALLOC_XSTACK8
   \   000024   E9           MOV       A,R1
   \   000025   6004         JZ        ??ZDSecMgrAddLinkKey_0
   3591            {
   3592              /* Adding to Addr Manager fails */
   3593              return ZFailure;
   \   000027   7901         MOV       R1,#0x1
   \   000029   8036         SJMP      ??ZDSecMgrAddLinkKey_1
   3594            }
   3595          
   3596            /* Lookup entry using specified address index */
   3597            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   00002B                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00002B   AC..         MOV       R4,?XSP + 0
   \   00002D   AD..         MOV       R5,?XSP + 1
   \   00002F   7402         MOV       A,#0x2
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   12....       LCALL     ?Subroutine58 & 0xFFFF
   3598          
   3599            // If no existing entry, create one
   3600            if ( entry == NULL )
   \                     ??CrossCallReturnLabel_70:
   \   000037   12....       LCALL     ??Subroutine112_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   00003A   7018         JNZ       ??CrossCallReturnLabel_225
   3601            {
   3602              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00003C                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00003C   AA..         MOV       R2,?XSP + 0
   \   00003E   AB..         MOV       R3,?XSP + 1
   \   000040   12....       LCALL     `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   000043   E9           MOV       A,R1
   \   000044   701E         JNZ       ??ZDSecMgrAddLinkKey_2
   3603              {
   3604                entry->ami = ami;
   \   000046   7402         MOV       A,#0x2
   \   000048   12....       LCALL     ?XSTACK_DISP0_8
   \   00004B   12....       LCALL     ??Subroutine97_0 & 0xFFFF
   3605              }
   \                     ??CrossCallReturnLabel_147:
   \   00004E   12....       LCALL     ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000051   12....       LCALL     ??Subroutine119_0 & 0xFFFF
   3606              else
   3607              {
   3608                /* Security Manager full */
   3609                return ZBufferFull;
   3610              }
   3611            }
   3612            // Write the link key
   3613            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_225:
   \   000054                ; Setup parameters for call to function APSME_LinkKeySet
   \   000054   740E         MOV       A,#0xe
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   12....       LCALL     ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   00005C   12....       LCALL     `??APSME_LinkKeySet::?relay`; Banked call to: APSME_LinkKeySet
   3614          
   3615          #if defined (TC_LINKKEY_JOIN)
   3616            // Mark the device as authenticated.
   3617            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3618          #endif
   3619          
   3620          #if defined NV_RESTORE
   3621            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3622          #endif
   3623            
   3624            return ZSuccess;
   \   00005F   7900         MOV       R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000061   02....       LJMP      ?Subroutine10 & 0xFFFF
   \                     ??ZDSecMgrAddLinkKey_2:
   \   000064   7911         MOV       R1,#0x11
   \   000066   80F9         SJMP      ??ZDSecMgrAddLinkKey_1
   3625          }
   3626          
   3627          #if defined ( NV_RESTORE )
   3628          /******************************************************************************
   3629           * @fn          ZDSecMgrInitNV
   3630           *
   3631           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   3632           *
   3633           * @param       none
   3634           *
   3635           * @return      uint8 - <osal_nv_item_init> return codes
   3636           */
   3637          uint8 ZDSecMgrInitNV(void)
   3638          {
   3639            
   3640            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE, 
   3641                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3642            
   3643            // If the item does not already exist, set all values to 0 
   3644            if (rtrn != SUCCESS)  
   3645            {
   3646              nvDeviceListHdr_t hdr;
   3647              hdr.numRecs = 0;
   3648              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3649            }
   3650          
   3651            return rtrn;
   3652          }
   3653          #endif // NV_RESTORE
   3654          
   3655          #if defined ( NV_RESTORE )
   3656          /*********************************************************************
   3657           * @fn      ZDSecMgrWriteNV()
   3658           *
   3659           * @brief   Save off the APS link key list to NV
   3660           *
   3661           * @param   none
   3662           *
   3663           * @return  none
   3664           */
   3665          static void ZDSecMgrWriteNV( void )
   3666          {
   3667            uint16 i;
   3668            nvDeviceListHdr_t hdr;
   3669          
   3670            hdr.numRecs = 0;
   3671          
   3672            if (ZDSecMgrEntries != NULL)
   3673            {
   3674              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3675              {
   3676                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3677                {
   3678                  // Save off the record
   3679                  osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3680                          (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3681                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3682                  hdr.numRecs++;
   3683                }
   3684              }
   3685            }
   3686          
   3687            // Save off the header
   3688            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3689          }
   3690          #endif // NV_RESTORE
   3691          
   3692          #if defined ( NV_RESTORE )
   3693          /******************************************************************************
   3694           * @fn          ZDSecMgrRestoreFromNV
   3695           *
   3696           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   3697           *              the key data itself as they remain in NV until they are used. 
   3698           *              Only list data is restored.
   3699           *
   3700           * @param       none
   3701           *
   3702           * @return      None.
   3703           */
   3704          static void ZDSecMgrRestoreFromNV( void )
   3705          {
   3706            nvDeviceListHdr_t hdr;
   3707            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3708            
   3709            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3710                (hdr.numRecs <= ZDSECMGR_ENTRY_MAX))
   3711            {
   3712              uint8 x;
   3713          
   3714              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3715              
   3716              for (x = 0; x < hdr.numRecs; x++)
   3717              {
   3718                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3719                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3720                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   3721                {
   3722                  // update data only for valid entries 
   3723                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   3724                  {
   3725                    if (pApsLinkKey != NULL)
   3726                    {
   3727                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3728                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0, 
   3729                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3730                      
   3731                      // set new values for the counter 
   3732                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3733          
   3734                      // restore values for counters in RAM
   3735                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 
   3736                                                      pApsLinkKey->txFrmCntr;
   3737          
   3738                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 
   3739                                                      pApsLinkKey->rxFrmCntr;
   3740                      
   3741                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0, 
   3742                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3743                      
   3744                      // clear copy of key in RAM 
   3745                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   3746                    }
   3747                  }
   3748                }
   3749              }
   3750              
   3751              if (pApsLinkKey != NULL)
   3752              {
   3753                osal_mem_free(pApsLinkKey);
   3754              }    
   3755            }
   3756          }
   3757          #endif // NV_RESTORE
   3758          
   3759          /*********************************************************************
   3760           * @fn          ZDSecMgrSetDefaultNV
   3761           *
   3762           * @brief       Write the defaults to NV for Entry table and for APS key data table
   3763           *
   3764           * @param       none
   3765           *
   3766           * @return      none
   3767           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3768          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3769          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   3770            uint16 i;
   3771            nvDeviceListHdr_t hdr;
   3772            ZDSecMgrEntry_t secMgrEntry;
   3773            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3774              
   3775            // Initialize the header
   3776            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   3777          
   3778            // clear the header
   3779            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \   000014                ; Setup parameters for call to function osal_nv_write
   \   000014   A8..         MOV       R0,?XSP + 0
   \   000016   A9..         MOV       R1,?XSP + 1
   \   000018   88..         MOV       ?V0,R0
   \   00001A   89..         MOV       ?V1,R1
   \   00001C   78..         MOV       R0,#?V0
   \   00001E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000021   75..02       MOV       ?V0,#0x2
   \   000024   75..00       MOV       ?V1,#0x0
   \   000027   78..         MOV       R0,#?V0
   \   000029   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002C   7C00         MOV       R4,#0x0
   \   00002E   7D00         MOV       R5,#0x0
   \   000030   7A4C         MOV       R2,#0x4c
   \   000032   7B00         MOV       R3,#0x0
   \   000034   12....       LCALL     ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000037   12....       LCALL     ?DEALLOC_XSTACK8
   3780            
   3781            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   00003A                ; Setup parameters for call to function osal_memset
   \   00003A   7C05         MOV       R4,#0x5
   \   00003C   7D00         MOV       R5,#0x0
   \   00003E   7900         MOV       R1,#0x0
   \   000040   7402         MOV       A,#0x2
   \   000042   12....       LCALL     ?XSTACK_DISP101_8
   \   000045   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3782          
   3783            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000048   7E00         MOV       R6,#0x0
   \   00004A   7F00         MOV       R7,#0x0
   3784            {
   3785              // Clear the record
   3786              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3787                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   3788                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   00004C                ; Setup parameters for call to function osal_nv_write
   \   00004C   7402         MOV       A,#0x2
   \   00004E   12....       LCALL     ?XSTACK_DISP100_8
   \   000051   88..         MOV       ?V0,R0
   \   000053   89..         MOV       ?V1,R1
   \   000055   78..         MOV       R0,#?V0
   \   000057   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005A   75..05       MOV       ?V0,#0x5
   \   00005D   75..00       MOV       ?V1,#0x0
   \   000060   78..         MOV       R0,#?V0
   \   000062   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000065   EE           MOV       A,R6
   \   000066   F8           MOV       R0,A
   \   000067   EF           MOV       A,R7
   \   000068   F9           MOV       R1,A
   \   000069   E8           MOV       A,R0
   \   00006A   75F005       MOV       B,#0x5
   \   00006D   A4           MUL       AB
   \   00006E   F8           MOV       R0,A
   \   00006F   AAF0         MOV       R2,B
   \   000071   75F005       MOV       B,#0x5
   \   000074   E9           MOV       A,R1
   \   000075   A4           MUL       AB
   \   000076   2A           ADD       A,R2
   \   000077   F9           MOV       R1,A
   \   000078   E8           MOV       A,R0
   \   000079   2402         ADD       A,#0x2
   \   00007B   FC           MOV       R4,A
   \   00007C   E4           CLR       A
   \   00007D   39           ADDC      A,R1
   \   00007E   FD           MOV       R5,A
   \   00007F   7A4C         MOV       R2,#0x4c
   \   000081   7B00         MOV       R3,#0x0
   \   000083   12....       LCALL     ??Subroutine124_0 & 0xFFFF
   3789            }
   \                     ??CrossCallReturnLabel_279:
   \   000086   12....       LCALL     ?DEALLOC_XSTACK8
   \   000089   0E           INC       R6
   \   00008A   EE           MOV       A,R6
   \   00008B   7001         JNZ       ??ZDSecMgrSetDefaultNV_1
   \   00008D   0F           INC       R7
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   00008E   C3           CLR       C
   \   00008F   9403         SUBB      A,#0x3
   \   000091   EF           MOV       A,R7
   \   000092   9400         SUBB      A,#0x0
   \   000094   40B6         JC        ??ZDSecMgrSetDefaultNV_0
   3790          
   3791            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000096                ; Setup parameters for call to function osal_mem_alloc
   \   000096   12....       LCALL     ?Subroutine64 & 0xFFFF
   3792          
   3793            if (pApsLinkKey != NULL)
   \                     ??CrossCallReturnLabel_313:
   \   000099   6042         JZ        ??ZDSecMgrSetDefaultNV_2
   3794            {
   3795              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00009B                ; Setup parameters for call to function osal_memset
   \   00009B   7C18         MOV       R4,#0x18
   \   00009D   7D00         MOV       R5,#0x0
   \   00009F   7900         MOV       R1,#0x0
   \   0000A1   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3796          
   3797              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   0000A4   7E00         MOV       R6,#0x0
   \   0000A6   7F00         MOV       R7,#0x0
   3798              {
   3799                // Clear the record
   3800                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3801                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \                     ??ZDSecMgrSetDefaultNV_3:
   \   0000A8                ; Setup parameters for call to function osal_nv_write
   \   0000A8   78..         MOV       R0,#?V0
   \   0000AA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AD   75..18       MOV       ?V2,#0x18
   \   0000B0   75..00       MOV       ?V3,#0x0
   \   0000B3   78..         MOV       R0,#?V2
   \   0000B5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B8   7C00         MOV       R4,#0x0
   \   0000BA   7D00         MOV       R5,#0x0
   \   0000BC   EE           MOV       A,R6
   \   0000BD   2401         ADD       A,#0x1
   \   0000BF   FA           MOV       R2,A
   \   0000C0   EF           MOV       A,R7
   \   0000C1   3402         ADDC      A,#0x2
   \   0000C3   12....       LCALL     ??Subroutine123_0 & 0xFFFF
   3802              }
   \                     ??CrossCallReturnLabel_277:
   \   0000C6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000C9   0E           INC       R6
   \   0000CA   EE           MOV       A,R6
   \   0000CB   7001         JNZ       ??ZDSecMgrSetDefaultNV_4
   \   0000CD   0F           INC       R7
   \                     ??ZDSecMgrSetDefaultNV_4:
   \   0000CE   C3           CLR       C
   \   0000CF   9403         SUBB      A,#0x3
   \   0000D1   EF           MOV       A,R7
   \   0000D2   9400         SUBB      A,#0x0
   \   0000D4   40D2         JC        ??ZDSecMgrSetDefaultNV_3
   3803              
   3804              osal_mem_free(pApsLinkKey);
   \   0000D6                ; Setup parameters for call to function osal_mem_free
   \   0000D6   AA..         MOV       R2,?V0
   \   0000D8   AB..         MOV       R3,?V1
   \   0000DA   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   3805            }
   3806          }
   \                     ??ZDSecMgrSetDefaultNV_2:
   \   0000DD   7407         MOV       A,#0x7
   \   0000DF   02....       LJMP      ??Subroutine109_0 & 0xFFFF
   3807          
   3808          /******************************************************************************
   3809           * @fn          ZDSecMgrAPSRemove
   3810           *
   3811           * @brief       Remove device from network.
   3812           *
   3813           * @param       nwkAddr - device's NWK address
   3814           * @param       extAddr - device's Extended address
   3815           * @param       parentAddr - parent's NWK address
   3816           *
   3817           * @return      ZStatus_t
   3818           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3819          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3820          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV       A,#-0xa
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   3821            ZDSecMgrDevice_t device;
   3822          
   3823            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3824                 ( extAddr == NULL )              ||
   3825                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000009   74FE         MOV       A,#-0x2
   \   00000B   6A           XRL       A,R2
   \   00000C   7003         JNZ       ??ZDSecMgrAPSRemove_0
   \   00000E   74FF         MOV       A,#-0x1
   \   000010   6B           XRL       A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000011   6016         JZ        ??ZDSecMgrAPSRemove_1
   \   000013   EC           MOV       A,R4
   \   000014   4D           ORL       A,R5
   \   000015   6012         JZ        ??ZDSecMgrAPSRemove_1
   \   000017   740A         MOV       A,#0xa
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ??Subroutine120_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   00001F   74FE         MOV       A,#-0x2
   \   000021   68           XRL       A,R0
   \   000022   7003         JNZ       ??ZDSecMgrAPSRemove_2
   \   000024   74FF         MOV       A,#-0x1
   \   000026   69           XRL       A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000027   7004         JNZ       ??ZDSecMgrAPSRemove_3
   3826            {
   3827              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   000029   7901         MOV       R1,#0x1
   \   00002B   8018         SJMP      ??ZDSecMgrAPSRemove_4
   3828            }
   3829          
   3830            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002D   12....       LCALL     ?Subroutine26 & 0xFFFF
   3831            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_156:
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   EC           MOV       A,R4
   \   000034   F0           MOVX      @DPTR,A
   \   000035   A3           INC       DPTR
   \   000036   ED           MOV       A,R5
   \   000037   F0           MOVX      @DPTR,A
   3832            device.parentAddr = parentAddr;
   \   000038   7404         MOV       A,#0x4
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   12....       LCALL     ?Subroutine11 & 0xFFFF
   3833          
   3834            // remove device
   3835            ZDSecMgrDeviceRemove( &device );
   \                     ??CrossCallReturnLabel_4:
   \   000040   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   3836          
   3837            return ( ZSuccess );
   \   000043   7900         MOV       R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000045   02....       LJMP      ?Subroutine9 & 0xFFFF
   3838          }
   3839          
   3840          /******************************************************************************
   3841           * @fn          APSME_TCLinkKeyInit
   3842           *
   3843           * @brief       Initialize the NV table for preconfigured TC link key
   3844           *               
   3845           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3846           *              Trust Center Link Key is written to NV. A single tclk is used   
   3847           *              by all devices joining the network.
   3848           *              
   3849           * @param       setDefault - TRUE to set default values
   3850           *
   3851           * @return      none
   3852           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3853          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   3854          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV       A,#-0x20
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   3855            uint8             i;
   3856            APSME_TCLinkKey_t tcLinkKey;
   3857            uint8             rtrn;
   3858            
   3859            // Initialize all NV items for preconfigured TCLK 
   3860            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3861            {
   3862              // Making sure data is cleared for every key all the time
   3863              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C20         MOV       R4,#0x20
   \   00000C   7D00         MOV       R5,#0x0
   \   00000E   7900         MOV       R1,#0x0
   \   000010   AA..         MOV       R2,?XSP + 0
   \   000012   AB..         MOV       R3,?XSP + 1
   \   000014   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3864          
   3865              // Initialize first element of the table with the default TCLK
   3866              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   \   000017   90....       MOV       DPTR,#zgUseDefaultTCLK
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   6401         XRL       A,#0x1
   \   00001D   702A         JNZ       ??APSME_TCLinkKeyInit_0
   3867              {
   3868                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   00001F                ; Setup parameters for call to function osal_memset
   \   00001F   7C08         MOV       R4,#0x8
   \   000021   7D00         MOV       R5,#0x0
   \   000023   79FF         MOV       R1,#-0x1
   \   000025   AA..         MOV       R2,?XSP + 0
   \   000027   AB..         MOV       R3,?XSP + 1
   \   000029   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3869                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   00002C                ; Setup parameters for call to function osal_memcpy
   \   00002C   75....       MOV       ?V0,#defaultTCLinkKey & 0xff
   \   00002F   75....       MOV       ?V1,#(defaultTCLinkKey >> 8) & 0xff
   \   000032   75..80       MOV       ?V2,#-0x80
   \   000035   78..         MOV       R0,#?V0
   \   000037   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00003A   7C10         MOV       R4,#0x10
   \   00003C   7D00         MOV       R5,#0x0
   \   00003E   740B         MOV       A,#0xb
   \   000040   12....       LCALL     ?XSTACK_DISP0_8
   \   000043   12....       LCALL     ?Subroutine67 & 0xFFFF
   3870              }
   \                     ??CrossCallReturnLabel_262:
   \   000046   12....       LCALL     ?DEALLOC_XSTACK8
   3871          
   3872              // If the item doesn't exist in NV memory, create and initialize
   3873              // it with the default value passed in, either defaultTCLK or 0
   3874              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i), 
   3875                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   3876               
   3877              if (rtrn == SUCCESS)
   \                     ??APSME_TCLinkKeyInit_0:
   \   000049                ; Setup parameters for call to function osal_nv_item_init
   \   000049   A8..         MOV       R0,?XSP + 0
   \   00004B   A9..         MOV       R1,?XSP + 1
   \   00004D   88..         MOV       ?V0,R0
   \   00004F   89..         MOV       ?V1,R1
   \   000051   78..         MOV       R0,#?V0
   \   000053   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000056   7C20         MOV       R4,#0x20
   \   000058   7D00         MOV       R5,#0x0
   \   00005A   7A01         MOV       R2,#0x1
   \   00005C   7B01         MOV       R3,#0x1
   \   00005E   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000061   12....       LCALL     ?DEALLOC_XSTACK8
   \   000064   E9           MOV       A,R1
   \   000065   7070         JNZ       ??APSME_TCLinkKeyInit_1
   3878              {
   3879                // set the Frame counters to 0 to existing keys in NV
   3880                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0, 
   3881                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000067                ; Setup parameters for call to function osal_nv_read
   \   000067   78..         MOV       R0,#?V0
   \   000069   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006C   75..20       MOV       ?V0,#0x20
   \   00006F   75..00       MOV       ?V1,#0x0
   \   000072   78..         MOV       R0,#?V0
   \   000074   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000077   7C00         MOV       R4,#0x0
   \   000079   7D00         MOV       R5,#0x0
   \   00007B   7A01         MOV       R2,#0x1
   \   00007D   7B01         MOV       R3,#0x1
   \   00007F   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000082   12....       LCALL     ?DEALLOC_XSTACK8
   3882                
   3883          #if defined ( NV_RESTORE )
   3884                if (setDefault == TRUE)
   3885                {
   3886                  // clear the value stored in NV  
   3887                  tcLinkKey.txFrmCntr = 0;
   3888                }
   3889                else
   3890                {
   3891                  // increase the value stored in NV  
   3892                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   3893                }
   3894          #else      
   3895                // Clear the counters if NV_RESTORE is not enabled and this NV item
   3896                // already existed in the NV memory
   3897                tcLinkKey.txFrmCntr = 0;
   \   000085   7418         MOV       A,#0x18
   \   000087   12....       LCALL     ?XSTACK_DISP0_8
   \   00008A   12....       LCALL     ??Subroutine126_0 & 0xFFFF
   3898                tcLinkKey.rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_284:
   \   00008D   741C         MOV       A,#0x1c
   \   00008F   12....       LCALL     ?XSTACK_DISP0_8
   \   000092   12....       LCALL     ??Subroutine126_0 & 0xFFFF
   3899          #endif  // NV_RESTORE
   3900          
   3901                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   3902                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??CrossCallReturnLabel_285:
   \   000095                ; Setup parameters for call to function osal_nv_write
   \   000095   A8..         MOV       R0,?XSP + 0
   \   000097   A9..         MOV       R1,?XSP + 1
   \   000099   88..         MOV       ?V0,R0
   \   00009B   89..         MOV       ?V1,R1
   \   00009D   78..         MOV       R0,#?V0
   \   00009F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A2   75..20       MOV       ?V0,#0x20
   \   0000A5   75..00       MOV       ?V1,#0x0
   \   0000A8   78..         MOV       R0,#?V0
   \   0000AA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AD   7C00         MOV       R4,#0x0
   \   0000AF   7D00         MOV       R5,#0x0
   \   0000B1   7A01         MOV       R2,#0x1
   \   0000B3   7B01         MOV       R3,#0x1
   \   0000B5   12....       LCALL     ??Subroutine124_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   0000B8   12....       LCALL     ?DEALLOC_XSTACK8
   3903                
   3904                // set initial values for counters in RAM
   3905                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   \   0000BB   7418         MOV       A,#0x18
   \   0000BD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL     ?XLOAD_R0123
   \   0000C3   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   0000C6   12....       LCALL     ?XSTORE_R0123
   3906                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;    
   \   0000C9   741C         MOV       A,#0x1c
   \   0000CB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CE   12....       LCALL     ?XLOAD_R0123
   \   0000D1   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 4
   \   0000D4   12....       LCALL     ?XSTORE_R0123
   3907              }
   3908            }
   3909              
   3910            // clear copy of key in RAM
   3911            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyInit_1:
   \   0000D7                ; Setup parameters for call to function osal_memset
   \   0000D7   7C20         MOV       R4,#0x20
   \   0000D9   7D00         MOV       R5,#0x0
   \   0000DB   7900         MOV       R1,#0x0
   \   0000DD   AA..         MOV       R2,?XSP + 0
   \   0000DF   AB..         MOV       R3,?XSP + 1
   \   0000E1   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3912          
   3913          }
   \   0000E4   7420         MOV       A,#0x20
   \   0000E6   02....       LJMP      ?Subroutine6 & 0xFFFF
   3914          
   3915          /******************************************************************************
   3916           * @fn          APSME_TCLinkKeySync
   3917           *
   3918           * @brief       Sync Trust Center LINK key data.
   3919           *
   3920           * @param       srcAddr - [in] srcAddr
   3921           * @param       si      - [in, out] SSP_Info_t
   3922           *
   3923           * @return      ZStatus_t
   3924           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3925          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   3926          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV       A,#-0x20
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   8C..         MOV       ?V0,R4
   \   000010   8D..         MOV       ?V1,R5
   3927            ZStatus_t status = ZSecNoKey;
   3928            uint8 i;
   3929            APSME_TCLinkKey_t tcLinkKey;       
   3930            uint32 *tclkRxFrmCntr;
   3931            
   3932            // Look up the IEEE address of the trust center if it's available
   3933            if ( AddrMgrExtAddrValid( si->extAddr ) == false )
   \   000012   EC           MOV       A,R4
   \   000013   2406         ADD       A,#0x6
   \   000015   FE           MOV       R6,A
   \   000016   E4           CLR       A
   \   000017   35..         ADDC      A,?V1
   \   000019   FF           MOV       R7,A
   \   00001A                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00001A   EE           MOV       A,R6
   \   00001B   FA           MOV       R2,A
   \   00001C   EF           MOV       A,R7
   \   00001D   FB           MOV       R3,A
   \   00001E   12....       LCALL     `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000021   E9           MOV       A,R1
   \   000022   700B         JNZ       ??APSME_TCLinkKeySync_0
   3934            {
   3935              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   000024                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000024   EE           MOV       A,R6
   \   000025   FC           MOV       R4,A
   \   000026   EF           MOV       A,R7
   \   000027   FD           MOV       R5,A
   \   000028   AA..         MOV       R2,?V2
   \   00002A   AB..         MOV       R3,?V3
   \   00002C   12....       LCALL     `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   3936            }
   3937            
   3938            // Look up the TC link key associated with the device
   3939            // or the default TC link key (extAddr is all FFs), whichever is found
   3940            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3941            {
   3942              // Read entry i of the TC link key table from NV
   3943              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3944                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeySync_0:
   \   00002F                ; Setup parameters for call to function osal_nv_read
   \   00002F   A8..         MOV       R0,?XSP + 0
   \   000031   A9..         MOV       R1,?XSP + 1
   \   000033   88..         MOV       ?V2,R0
   \   000035   89..         MOV       ?V3,R1
   \   000037   78..         MOV       R0,#?V2
   \   000039   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003C   75..20       MOV       ?V2,#0x20
   \   00003F   75..00       MOV       ?V3,#0x0
   \   000042   78..         MOV       R0,#?V2
   \   000044   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000047   7C00         MOV       R4,#0x0
   \   000049   7D00         MOV       R5,#0x0
   \   00004B   7A01         MOV       R2,#0x1
   \   00004D   7B01         MOV       R3,#0x1
   \   00004F   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000052   12....       LCALL     ?DEALLOC_XSTACK8
   3945              
   3946              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3947                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   000055                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000055   AC..         MOV       R4,?XSP + 0
   \   000057   AD..         MOV       R5,?XSP + 1
   \   000059   EE           MOV       A,R6
   \   00005A   FA           MOV       R2,A
   \   00005B   EF           MOV       A,R7
   \   00005C   FB           MOV       R3,A
   \   00005D   12....       LCALL     `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   000060   E9           MOV       A,R1
   \   000061   700A         JNZ       ??APSME_TCLinkKeySync_1
   \   000063                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000063   AA..         MOV       R2,?XSP + 0
   \   000065   AB..         MOV       R3,?XSP + 1
   \   000067   12....       LCALL     `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   00006A   E9           MOV       A,R1
   \   00006B   603A         JZ        ??APSME_TCLinkKeySync_2
   3948              {
   3949                tclkRxFrmCntr = &TCLinkKeyFrmCntr[i].rxFrmCntr;
   3950          
   3951                // verify that the incoming frame counter is valid
   3952                if ( si->frmCntr >= *tclkRxFrmCntr )
   \                     ??APSME_TCLinkKeySync_1:
   \   00006D   E5..         MOV       A,?V0
   \   00006F   2412         ADD       A,#0x12
   \   000071   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000074   78..         MOV       R0,#?V4
   \   000076   12....       LCALL     ?L_MOV_X
   \   000079   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 4
   \   00007C   78..         MOV       R0,#?V4
   \   00007E   12....       LCALL     ?UL_GE_X
   \   000081   5020         JNC       ??APSME_TCLinkKeySync_3
   3953                {
   3954                  // set the keyNvId to use
   3955                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   000083   E5..         MOV       A,?V0
   \   000085   240F         ADD       A,#0xf
   \   000087   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00008A   7401         MOV       A,#0x1
   \   00008C   F0           MOVX      @DPTR,A
   \   00008D   A3           INC       DPTR
   \   00008E   F0           MOVX      @DPTR,A
   3956                  
   3957                  // update the rx frame counter
   3958                  *tclkRxFrmCntr = si->frmCntr + 1;
   \   00008F   90....       MOV       DPTR,#__Constant_1
   \   000092   78..         MOV       R0,#?V4
   \   000094   12....       LCALL     ?L_ADD_X
   \   000097   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 4
   \   00009A   78..         MOV       R0,#?V4
   \   00009C   12....       LCALL     ?L_MOV_TO_X
   3959                  
   3960                  status = ZSuccess;
   \   00009F   7900         MOV       R1,#0x0
   \   0000A1   8013         SJMP      ??APSME_TCLinkKeySync_4
   3961                }
   3962                else
   3963                {
   3964                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_3:
   \   0000A3   79A2         MOV       R1,#-0x5e
   3965                }
   3966                
   3967                return status;
   \   0000A5   800F         SJMP      ??APSME_TCLinkKeySync_4
   3968              }
   3969            }
   3970            
   3971            // clear copy of key in RAM 
   3972            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeySync_2:
   \   0000A7                ; Setup parameters for call to function osal_memset
   \   0000A7   7C20         MOV       R4,#0x20
   \   0000A9   7D00         MOV       R5,#0x0
   \   0000AB   7900         MOV       R1,#0x0
   \   0000AD   AA..         MOV       R2,?XSP + 0
   \   0000AF   AB..         MOV       R3,?XSP + 1
   \   0000B1   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3973            
   3974            return status;
   \   0000B4   79A1         MOV       R1,#-0x5f
   \                     ??APSME_TCLinkKeySync_4:
   \   0000B6   7420         MOV       A,#0x20
   \   0000B8   80..         SJMP      ??Subroutine130_0
   3975          }
   3976          
   3977          /******************************************************************************
   3978           * @fn          APSME_TCLinkKeyLoad
   3979           *
   3980           * @brief       Load Trust Center LINK key data.
   3981           *
   3982           * @param       dstAddr - [in] dstAddr
   3983           * @param       si      - [in, out] SSP_Info_t
   3984           *
   3985           * @return      ZStatus_t
   3986           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3987          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   3988          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV       A,#-0x2d
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3989            uint8              i;
   3990            APSME_TCLinkKey_t  tcLinkKey;
   3991            AddrMgrEntry_t     addrEntry;  
   3992            uint32 *tclkTxFrmCntr;
   3993            
   3994            // Look up the ami of the srcAddr if available
   3995            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   E4           CLR       A
   \   000015   F0           MOVX      @DPTR,A
   3996            addrEntry.nwkAddr = dstAddr;
   \   000016   04           INC       A
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   12....       LCALL     ??Subroutine107_0 & 0xFFFF
   3997          
   3998            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \                     ??CrossCallReturnLabel_190:
   \   00001D   EC           MOV       A,R4
   \   00001E   2406         ADD       A,#0x6
   \   000020   F5..         MOV       ?V0,A
   \   000022   E4           CLR       A
   \   000023   3F           ADDC      A,R7
   \   000024   F5..         MOV       ?V1,A
   \   000026                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000026   AC..         MOV       R4,?V0
   \   000028   FD           MOV       R5,A
   \   000029   12....       LCALL     `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   3999          
   4000            if ( AddrMgrExtAddrValid( si->extAddr ) == TRUE )
   \   00002C                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00002C   AA..         MOV       R2,?V0
   \   00002E   AB..         MOV       R3,?V1
   \   000030   12....       LCALL     `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000033   E9           MOV       A,R1
   \   000034   6401         XRL       A,#0x1
   \   000036   6003         JZ        $+5
   \   000038   02....       LJMP      ??APSME_TCLinkKeyLoad_0 & 0xFFFF
   4001            {
   4002              // Look up the TC link key associated with the device
   4003              // or the master TC link key (ami = 0xFFFF), whichever is found
   4004              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   4005              {
   4006                // Read entry i of the TC link key table from NV
   4007                osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   4008                             sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00003B                ; Setup parameters for call to function osal_nv_read
   \   00003B   740D         MOV       A,#0xd
   \   00003D   12....       LCALL     ?XSTACK_DISP100_8
   \   000040   88..         MOV       ?V2,R0
   \   000042   89..         MOV       ?V3,R1
   \   000044   78..         MOV       R0,#?V2
   \   000046   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000049   75..20       MOV       ?V2,#0x20
   \   00004C   75..00       MOV       ?V3,#0x0
   \   00004F   78..         MOV       R0,#?V2
   \   000051   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000054   7C00         MOV       R4,#0x0
   \   000056   7D00         MOV       R5,#0x0
   \   000058   7A01         MOV       R2,#0x1
   \   00005A   7B01         MOV       R3,#0x1
   \   00005C   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   00005F   12....       LCALL     ?DEALLOC_XSTACK8
   4009                
   4010                if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   4011                   APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   000062                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000062   740D         MOV       A,#0xd
   \   000064   12....       LCALL     ?XSTACK_DISP102_8
   \   000067   AA..         MOV       R2,?V0
   \   000069   AB..         MOV       R3,?V1
   \   00006B   12....       LCALL     `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   00006E   E9           MOV       A,R1
   \   00006F   700B         JNZ       ??APSME_TCLinkKeyLoad_1
   \   000071                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000071   740D         MOV       A,#0xd
   \   000073   12....       LCALL     ?XSTACK_DISP101_8
   \   000076   12....       LCALL     `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   000079   E9           MOV       A,R1
   \   00007A   603F         JZ        ??APSME_TCLinkKeyLoad_0
   4012                {
   4013                  tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   4014                  
   4015                  // set the keyNvId to use
   4016                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \                     ??APSME_TCLinkKeyLoad_1:
   \   00007C   EE           MOV       A,R6
   \   00007D   240F         ADD       A,#0xf
   \   00007F   F582         MOV       DPL,A
   \   000081   E4           CLR       A
   \   000082   3F           ADDC      A,R7
   \   000083   F583         MOV       DPH,A
   \   000085   7401         MOV       A,#0x1
   \   000087   F0           MOVX      @DPTR,A
   \   000088   A3           INC       DPTR
   \   000089   F0           MOVX      @DPTR,A
   4017                  
   4018                  // update link key related fields
   4019                  si->keyID   = SEC_KEYID_LINK;
   \   00008A   EE           MOV       A,R6
   \   00008B   240E         ADD       A,#0xe
   \   00008D   F582         MOV       DPL,A
   \   00008F   E4           CLR       A
   \   000090   3F           ADDC      A,R7
   \   000091   F583         MOV       DPH,A
   \   000093   E4           CLR       A
   \   000094   F0           MOVX      @DPTR,A
   4020                  si->frmCntr = *tclkTxFrmCntr;
   \   000095   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   000098   12....       LCALL     ?XLOAD_R0123
   \   00009B   EE           MOV       A,R6
   \   00009C   2412         ADD       A,#0x12
   \   00009E   F582         MOV       DPL,A
   \   0000A0   E4           CLR       A
   \   0000A1   3F           ADDC      A,R7
   \   0000A2   F583         MOV       DPH,A
   \   0000A4   12....       LCALL     ?XSTORE_R0123
   4021                
   4022                  // update outgoing frame counter
   4023                  (*tclkTxFrmCntr)++;
   \   0000A7   90....       MOV       DPTR,#__Constant_1
   \   0000AA   78..         MOV       R0,#?V0
   \   0000AC   12....       LCALL     ?L_MOV_X
   \   0000AF   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   0000B2   78..         MOV       R0,#?V0
   \   0000B4   12....       LCALL     ?L_ADD_TO_X
   4024                  
   4025          #if defined ( NV_RESTORE )
   4026                  // write periodically to NV
   4027                  if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   4028                  {
   4029                    // set the flag to write key to NV
   4030                    TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   4031                    
   4032                    // Notify the ZDApp that the frame counter has changed.
   4033                    osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   4034                  }        
   4035          #endif
   4036                  
   4037                  return ZSuccess;
   \   0000B7   7900         MOV       R1,#0x0
   \   0000B9   8023         SJMP      ??APSME_TCLinkKeyLoad_2
   4038                }
   4039              }
   4040            }
   4041              
   4042            // If no TC link key found, remove the device from the address manager
   4043            if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   \                     ??APSME_TCLinkKeyLoad_0:
   \   0000BB                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   0000BB   AA..         MOV       R2,?XSP + 0
   \   0000BD   AB..         MOV       R3,?XSP + 1
   \   0000BF   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   0000C2   E9           MOV       A,R1
   \   0000C3   6401         XRL       A,#0x1
   \   0000C5   7007         JNZ       ??APSME_TCLinkKeyLoad_3
   4044            {
   4045              AddrMgrEntryRelease( &addrEntry );
   \   0000C7                ; Setup parameters for call to function AddrMgrEntryRelease
   \   0000C7   AA..         MOV       R2,?XSP + 0
   \   0000C9   AB..         MOV       R3,?XSP + 1
   \   0000CB   12....       LCALL     `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
   4046            }
   4047            
   4048              // clear copy of key in RAM 
   4049            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyLoad_3:
   \   0000CE                ; Setup parameters for call to function osal_memset
   \   0000CE   7C20         MOV       R4,#0x20
   \   0000D0   7D00         MOV       R5,#0x0
   \   0000D2   7900         MOV       R1,#0x0
   \   0000D4   740D         MOV       A,#0xd
   \   0000D6   12....       LCALL     ?XSTACK_DISP101_8
   \   0000D9   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4050          
   4051            return ZSecNoKey;
   \   0000DC   79A1         MOV       R1,#-0x5f
   \                     ??APSME_TCLinkKeyLoad_2:
   \   0000DE   742D         MOV       A,#0x2d
   \   0000E0   02....       LJMP      ??Subroutine109_0 & 0xFFFF
   4052          }
   4053          
   4054          /******************************************************************************
   4055           * @fn          APSME_IsDefaultTCLK
   4056           *
   4057           * @brief       Return true or false based on the extended address.  If the 
   4058           *              input ext address is all FFs, it means the trust center link
   4059           *              assoiciated with the address is the default trust center link key
   4060           *
   4061           * @param       extAddr - [in] extended address
   4062           *
   4063           * @return      uint8 TRUE/FALSE
   4064           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4065          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   4066          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   4067            uint8 i = 0;
   \   000005   7C00         MOV       R4,#0x0
   4068            
   4069            if( extAddr == NULL )
   \   000007   EA           MOV       A,R2
   \   000008   4B           ORL       A,R3
   \   000009   6020         JZ        ??APSME_IsDefaultTCLK_0
   4070            {
   4071              return FALSE;
   4072            }
   4073            
   4074            while( i++ < Z_EXTADDR_LEN )
   \                     ??APSME_IsDefaultTCLK_1:
   \   00000B   EC           MOV       A,R4
   \   00000C   FD           MOV       R5,A
   \   00000D   7401         MOV       A,#0x1
   \   00000F   2D           ADD       A,R5
   \   000010   FC           MOV       R4,A
   \   000011   ED           MOV       A,R5
   \   000012   C3           CLR       C
   \   000013   9408         SUBB      A,#0x8
   \   000015   5018         JNC       ??APSME_IsDefaultTCLK_2
   4075            {
   4076              if( *extAddr++ != 0xFF )
   \   000017   EA           MOV       A,R2
   \   000018   F8           MOV       R0,A
   \   000019   EB           MOV       A,R3
   \   00001A   8882         MOV       DPL,R0
   \   00001C   F583         MOV       DPH,A
   \   00001E   A3           INC       DPTR
   \   00001F   AA82         MOV       R2,DPL
   \   000021   AB83         MOV       R3,DPH
   \   000023   8882         MOV       DPL,R0
   \   000025   F583         MOV       DPH,A
   \   000027   E0           MOVX      A,@DPTR
   \   000028   F4           CPL       A
   \   000029   60E0         JZ        ??APSME_IsDefaultTCLK_1
   4077              {
   4078                return FALSE;
   \                     ??APSME_IsDefaultTCLK_0:
   \   00002B   7900         MOV       R1,#0x0
   \   00002D   8002         SJMP      ??APSME_IsDefaultTCLK_3
   4079              }
   4080            }
   4081            
   4082            return TRUE;
   \                     ??APSME_IsDefaultTCLK_2:
   \   00002F   7901         MOV       R1,#0x1
   \                     ??APSME_IsDefaultTCLK_3:
   \   000031   02....       LJMP      ??Subroutine101_0 & 0xFFFF
   4083          }
   4084          
   4085          /******************************************************************************
   4086           * @fn          ZDSecMgrNwkKeyInit
   4087           *
   4088           * @brief       Initialize the NV items for 
   4089           *                  ZCD_NV_NWKKEY, 
   4090           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and 
   4091           *                  ZCD_NV_NWK_ALTERN_KEY_INFO 
   4092           *               
   4093           * @param       setDefault
   4094           *
   4095           * @return      none
   4096           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4097          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   4098          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV       A,#-0x26
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   4099            uint8 status;
   4100            nwkKeyDesc nwkKey;
   4101          
   4102            // Initialize NV items for NWK key, this structure contains the frame counter
   4103            // and is only used when NV_RESTORE is enabled
   4104            nwkActiveKeyItems keyItems;  
   4105              
   4106            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C15         MOV       R4,#0x15
   \   00000C   7D00         MOV       R5,#0x0
   \   00000E   7900         MOV       R1,#0x0
   \   000010   7411         MOV       A,#0x11
   \   000012   12....       LCALL     ?XSTACK_DISP101_8
   \   000015   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4107            
   4108            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   4109          
   4110          #if defined ( NV_RESTORE )
   4111            // reset the values of NV items if NV_RESTORE is not enabled
   4112            if ((status == SUCCESS) && (setDefault == TRUE))
   4113            {
   4114              // clear NV data to default values
   4115              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   4116            }
   4117          #else
   4118            (void)setDefault;   // to eliminate compiler warning
   4119            
   4120            // reset the values of NV items if NV_RESTORE is not enabled
   4121            if (status == SUCCESS)
   \   000018                ; Setup parameters for call to function osal_nv_item_init
   \   000018   7411         MOV       A,#0x11
   \   00001A   12....       LCALL     ?XSTACK_DISP100_8
   \   00001D   88..         MOV       ?V0,R0
   \   00001F   89..         MOV       ?V1,R1
   \   000021   78..         MOV       R0,#?V0
   \   000023   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000026   7C15         MOV       R4,#0x15
   \   000028   7D00         MOV       R5,#0x0
   \   00002A   7A82         MOV       R2,#-0x7e
   \   00002C   7B00         MOV       R3,#0x0
   \   00002E   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000031   12....       LCALL     ?DEALLOC_XSTACK8
   \   000034   E9           MOV       A,R1
   \   000035   701E         JNZ       ??ZDSecMgrNwkKeyInit_0
   4122            {
   4123              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   000037                ; Setup parameters for call to function osal_nv_write
   \   000037   78..         MOV       R0,#?V0
   \   000039   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003C   75..15       MOV       ?V0,#0x15
   \   00003F   75..00       MOV       ?V1,#0x0
   \   000042   78..         MOV       R0,#?V0
   \   000044   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000047   7C00         MOV       R4,#0x0
   \   000049   7D00         MOV       R5,#0x0
   \   00004B   7A82         MOV       R2,#-0x7e
   \   00004D   7B00         MOV       R3,#0x0
   \   00004F   12....       LCALL     ??Subroutine124_0 & 0xFFFF
   4124            }
   \                     ??CrossCallReturnLabel_281:
   \   000052   12....       LCALL     ?DEALLOC_XSTACK8
   4125          #endif // defined (NV_RESTORE)    
   4126          
   4127            // Initialize NV items for NWK Active and Alternate keys. These items are used 
   4128            // all the time, independently of NV_RESTORE being set or not
   4129            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   000055                ; Setup parameters for call to function osal_memset
   \   000055   7C11         MOV       R4,#0x11
   \   000057   7D00         MOV       R5,#0x0
   \   000059   7900         MOV       R1,#0x0
   \   00005B   AA..         MOV       R2,?XSP + 0
   \   00005D   AB..         MOV       R3,?XSP + 1
   \   00005F   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4130          
   4131            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   4132            
   4133          #if defined ( NV_RESTORE )
   4134            // reset the values of NV items if NV_RESTORE is not enabled
   4135            if ((status == SUCCESS) && (setDefault == TRUE))
   4136            {
   4137              // clear NV data to default values
   4138              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4139            }
   4140          #else
   4141            // reset the values of NV items if NV_RESTORE is not enabled
   4142            if (status == SUCCESS)
   \   000062                ; Setup parameters for call to function osal_nv_item_init
   \   000062   A8..         MOV       R0,?XSP + 0
   \   000064   A9..         MOV       R1,?XSP + 1
   \   000066   88..         MOV       ?V0,R0
   \   000068   89..         MOV       ?V1,R1
   \   00006A   78..         MOV       R0,#?V0
   \   00006C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006F   7C11         MOV       R4,#0x11
   \   000071   7D00         MOV       R5,#0x0
   \   000073   7A3A         MOV       R2,#0x3a
   \   000075   7B00         MOV       R3,#0x0
   \   000077   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   00007A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007D   E9           MOV       A,R1
   \   00007E   701E         JNZ       ??ZDSecMgrNwkKeyInit_1
   4143            {
   4144              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   000080                ; Setup parameters for call to function osal_nv_write
   \   000080   78..         MOV       R0,#?V0
   \   000082   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000085   75..11       MOV       ?V0,#0x11
   \   000088   75..00       MOV       ?V1,#0x0
   \   00008B   78..         MOV       R0,#?V0
   \   00008D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000090   7C00         MOV       R4,#0x0
   \   000092   7D00         MOV       R5,#0x0
   \   000094   7A3A         MOV       R2,#0x3a
   \   000096   7B00         MOV       R3,#0x0
   \   000098   12....       LCALL     ??Subroutine124_0 & 0xFFFF
   4145            }
   \                     ??CrossCallReturnLabel_282:
   \   00009B   12....       LCALL     ?DEALLOC_XSTACK8
   4146          #endif // defined (NV_RESTORE)    
   4147            
   4148            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   4149            
   4150          #if defined ( NV_RESTORE )
   4151            // reset the values of NV items if NV_RESTORE is not enabled
   4152            if ((status == SUCCESS) && (setDefault == TRUE))
   4153            {
   4154              // clear NV data to default values
   4155              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4156            }
   4157          #else
   4158            // reset the values of NV items if NV_RESTORE is not enabled
   4159            if (status == SUCCESS)
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   00009E                ; Setup parameters for call to function osal_nv_item_init
   \   00009E   A8..         MOV       R0,?XSP + 0
   \   0000A0   A9..         MOV       R1,?XSP + 1
   \   0000A2   88..         MOV       ?V0,R0
   \   0000A4   89..         MOV       ?V1,R1
   \   0000A6   78..         MOV       R0,#?V0
   \   0000A8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AB   7C11         MOV       R4,#0x11
   \   0000AD   7D00         MOV       R5,#0x0
   \   0000AF   7A3B         MOV       R2,#0x3b
   \   0000B1   7B00         MOV       R3,#0x0
   \   0000B3   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   0000B6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B9   E9           MOV       A,R1
   \   0000BA   701E         JNZ       ??ZDSecMgrNwkKeyInit_2
   4160            {
   4161              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000BC                ; Setup parameters for call to function osal_nv_write
   \   0000BC   78..         MOV       R0,#?V0
   \   0000BE   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C1   75..11       MOV       ?V0,#0x11
   \   0000C4   75..00       MOV       ?V1,#0x0
   \   0000C7   78..         MOV       R0,#?V0
   \   0000C9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000CC   7C00         MOV       R4,#0x0
   \   0000CE   7D00         MOV       R5,#0x0
   \   0000D0   7A3B         MOV       R2,#0x3b
   \   0000D2   7B00         MOV       R3,#0x0
   \   0000D4   12....       LCALL     ??Subroutine124_0 & 0xFFFF
   4162            }
   \                     ??CrossCallReturnLabel_283:
   \   0000D7   12....       LCALL     ?DEALLOC_XSTACK8
   4163          #endif // defined (NV_RESTORE)
   4164          
   4165          }
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   0000DA   7426         MOV       A,#0x26
   \   0000DC   02....       LJMP      ??Subroutine114_0 & 0xFFFF
   4166          
   4167          /*********************************************************************
   4168           * @fn          ZDSecMgrReadKeyFromNv
   4169           *
   4170           * @brief       Looks for a specific key in NV based on Index value
   4171           *
   4172           * @param   keyNvId - Index of key to look in NV
   4173           *                    valid values are:
   4174           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO    
   4175           *                    ZCD_NV_NWK_ALTERN_KEY_INFO 
   4176           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4177           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4178           *                    ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4179           *                    ZCD_NV_PRECFGKEY
   4180           *
   4181           * @param  *keyinfo - Data is read into this buffer.
   4182           *
   4183           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   4184           *          Otherwise, NV_OPER_FAILED for failure.
   4185           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4186          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   4187          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4188            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   4189                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   000005   743A         MOV       A,#0x3a
   \   000007   6A           XRL       A,R2
   \   000008   7001         JNZ       ??ZDSecMgrReadKeyFromNv_0
   \   00000A   EB           MOV       A,R3
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   00000B   6006         JZ        ??ZDSecMgrReadKeyFromNv_1
   \   00000D   743B         MOV       A,#0x3b
   \   00000F   6A           XRL       A,R2
   \   000010   4B           ORL       A,R3
   \   000011   7018         JNZ       ??ZDSecMgrReadKeyFromNv_2
   4190            {
   4191              // get NWK active or alternate key from NV
   4192              return (osal_nv_read(keyNvId, 
   4193                                   osal_offsetof(nwkKeyDesc, key), 
   4194                                   SEC_KEY_LEN, 
   4195                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000013                ; Setup parameters for call to function osal_nv_read
   \   000013   8C..         MOV       ?V0,R4
   \   000015   8D..         MOV       ?V1,R5
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   75..10       MOV       ?V0,#0x10
   \   00001F   75..00       MOV       ?V1,#0x0
   \   000022   78..         MOV       R0,#?V0
   \   000024   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000027   7C01         MOV       R4,#0x1
   \   000029   8062         SJMP      ??ZDSecMgrReadKeyFromNv_3
   4196            }
   4197            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   4198                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   00002B   EA           MOV       A,R2
   \   00002C   24FF         ADD       A,#-0x1
   \   00002E   F8           MOV       R0,A
   \   00002F   EB           MOV       A,R3
   \   000030   34FE         ADDC      A,#-0x2
   \   000032   F9           MOV       R1,A
   \   000033   E8           MOV       A,R0
   \   000034   49           ORL       A,R1
   \   000035   7018         JNZ       ??ZDSecMgrReadKeyFromNv_4
   4199            {
   4200              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   4201              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4202              return (osal_nv_read(keyNvId, 
   4203                                   osal_offsetof(APSME_TCLinkKey_t, key), 
   4204                                   SEC_KEY_LEN, 
   4205                                   keyinfo));
   \   000037                ; Setup parameters for call to function osal_nv_read
   \   000037   8C..         MOV       ?V0,R4
   \   000039   8D..         MOV       ?V1,R5
   \   00003B   78..         MOV       R0,#?V0
   \   00003D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000040   75..10       MOV       ?V0,#0x10
   \   000043   75..00       MOV       ?V1,#0x0
   \   000046   78..         MOV       R0,#?V0
   \   000048   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004B   7C08         MOV       R4,#0x8
   \   00004D   803E         SJMP      ??ZDSecMgrReadKeyFromNv_3
   4206            }
   4207            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   4208                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   00004F   19           DEC       R1
   \   000050   C3           CLR       C
   \   000051   E8           MOV       A,R0
   \   000052   12....       LCALL     ??Subroutine92_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000055   5018         JNC       ??ZDSecMgrReadKeyFromNv_5
   4209            {
   4210              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   4211              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4212              return (osal_nv_read(keyNvId, 
   4213                                   osal_offsetof(APSME_LinkKeyData_t, key), 
   4214                                   SEC_KEY_LEN, 
   4215                                   keyinfo));
   \   000057                ; Setup parameters for call to function osal_nv_read
   \   000057   8C..         MOV       ?V0,R4
   \   000059   8D..         MOV       ?V1,R5
   \   00005B   78..         MOV       R0,#?V0
   \   00005D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000060   75..10       MOV       ?V0,#0x10
   \   000063   75..00       MOV       ?V1,#0x0
   \   000066   78..         MOV       R0,#?V0
   \   000068   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006B   7C00         MOV       R4,#0x0
   \   00006D   801E         SJMP      ??ZDSecMgrReadKeyFromNv_3
   4216            }
   4217            else if ((keyNvId >= ZCD_NV_MASTER_KEY_DATA_START) &&
   4218                     (keyNvId < (ZCD_NV_MASTER_KEY_DATA_START + ZDSECMGR_MASTERKEY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   00006F   19           DEC       R1
   \   000070   C3           CLR       C
   \   000071   E8           MOV       A,R0
   \   000072   12....       LCALL     ??Subroutine92_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000075   501A         JNC       ??ZDSecMgrReadKeyFromNv_6
   4219            {
   4220              // Read entry keyNvId of the MASTER key table from NV. keyNvId should be
   4221              // ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4222              return (osal_nv_read(keyNvId, 
   4223                                   osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   4224                                   SEC_KEY_LEN, 
   4225                                   keyinfo));
   \   000077                ; Setup parameters for call to function osal_nv_read
   \   000077   8C..         MOV       ?V0,R4
   \   000079   8D..         MOV       ?V1,R5
   \   00007B   78..         MOV       R0,#?V0
   \   00007D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000080   75..10       MOV       ?V0,#0x10
   \   000083   75..00       MOV       ?V1,#0x0
   \   000086   78..         MOV       R0,#?V0
   \   000088   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008B   7C02         MOV       R4,#0x2
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   00008D   7D00         MOV       R5,#0x0
   \   00008F   8022         SJMP      ??ZDSecMgrReadKeyFromNv_7
   4226            }
   4227            else if (keyNvId == ZCD_NV_PRECFGKEY)
   \                     ??ZDSecMgrReadKeyFromNv_6:
   \   000091   7462         MOV       A,#0x62
   \   000093   6A           XRL       A,R2
   \   000094   4B           ORL       A,R3
   \   000095   7024         JNZ       ??ZDSecMgrReadKeyFromNv_8
   4228            {
   4229              // Read entry keyNvId of the Preconfig key from NV. 
   4230              return (osal_nv_read(keyNvId, 
   4231                                   0, 
   4232                                   SEC_KEY_LEN, 
   4233                                   keyinfo));
   \   000097                ; Setup parameters for call to function osal_nv_read
   \   000097   8C..         MOV       ?V0,R4
   \   000099   8D..         MOV       ?V1,R5
   \   00009B   78..         MOV       R0,#?V0
   \   00009D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A0   75..10       MOV       ?V0,#0x10
   \   0000A3   75..00       MOV       ?V1,#0x0
   \   0000A6   78..         MOV       R0,#?V0
   \   0000A8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AB   7C00         MOV       R4,#0x0
   \   0000AD   7D00         MOV       R5,#0x0
   \   0000AF   7A62         MOV       R2,#0x62
   \   0000B1   7B00         MOV       R3,#0x0
   4234            }
   \                     ??ZDSecMgrReadKeyFromNv_7:
   \   0000B3   12....       LCALL     ??Subroutine91_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   0000B6   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000B9   8002         SJMP      ??ZDSecMgrReadKeyFromNv_9
   4235            
   4236            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_8:
   \   0000BB   790A         MOV       R1,#0xa
   \                     ??ZDSecMgrReadKeyFromNv_9:
   \   0000BD   02....       LJMP      ??Subroutine115_0 & 0xFFFF
   4237          }
   4238          
   4239          /******************************************************************************
   4240           * @fn          ZDSecMgrApsLinkKeyInit
   4241           *
   4242           * @brief       Initialize the NV table for Application link keys
   4243           *           
   4244           * @param       none
   4245           *
   4246           * @return      none
   4247           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4248          void ZDSecMgrApsLinkKeyInit(void)
   \                     ZDSecMgrApsLinkKeyInit:
   4249          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV       A,#-0x18
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   4250            APSME_LinkKeyData_t pApsLinkKey;
   4251            uint8 i;
   4252            uint8 status;
   4253            
   4254            // Initialize all NV items for APS link key, if not exist already.
   4255            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C18         MOV       R4,#0x18
   \   00000C   7D00         MOV       R5,#0x0
   \   00000E   7900         MOV       R1,#0x0
   \   000010   AA..         MOV       R2,?XSP + 0
   \   000012   AB..         MOV       R3,?XSP + 1
   \   000014   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4256            
   4257            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000017   75..00       MOV       ?V0,#0x0
   4258            {
   4259              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 
   4260                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   4261              
   4262          #if defined ( NV_RESTORE )
   4263              (void)status;   // to eliminate compiler warning
   4264          #else
   4265              // reset the values of NV items if NV_RESTORE is not enabled
   4266              if (status == SUCCESS)
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   00001A   E5..         MOV       A,?V0
   \   00001C   2401         ADD       A,#0x1
   \   00001E   FE           MOV       R6,A
   \   00001F   E4           CLR       A
   \   000020   3402         ADDC      A,#0x2
   \   000022   FF           MOV       R7,A
   \   000023                ; Setup parameters for call to function osal_nv_item_init
   \   000023   A8..         MOV       R0,?XSP + 0
   \   000025   A9..         MOV       R1,?XSP + 1
   \   000027   88..         MOV       ?V2,R0
   \   000029   89..         MOV       ?V3,R1
   \   00002B   78..         MOV       R0,#?V2
   \   00002D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000030   7C18         MOV       R4,#0x18
   \   000032   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000035   12....       LCALL     ?DEALLOC_XSTACK8
   \   000038   E9           MOV       A,R1
   \   000039   7016         JNZ       ??ZDSecMgrApsLinkKeyInit_1
   4267              {
   4268                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0, 
   4269                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   00003B                ; Setup parameters for call to function osal_nv_write
   \   00003B   78..         MOV       R0,#?V2
   \   00003D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000040   75..18       MOV       ?V2,#0x18
   \   000043   75..00       MOV       ?V3,#0x0
   \   000046   78..         MOV       R0,#?V2
   \   000048   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004B   12....       LCALL     ?Subroutine35 & 0xFFFF
   4270                
   4271              }
   4272          #endif // defined (NV_RESTORE)
   4273            }
   \                     ??CrossCallReturnLabel_271:
   \   00004E   12....       LCALL     ?DEALLOC_XSTACK8
   \                     ??ZDSecMgrApsLinkKeyInit_1:
   \   000051   05..         INC       ?V0
   \   000053   EE           MOV       A,R6
   \   000054   C3           CLR       C
   \   000055   9403         SUBB      A,#0x3
   \   000057   40C1         JC        ??ZDSecMgrApsLinkKeyInit_0
   4274          }
   \   000059   7418         MOV       A,#0x18
   \   00005B   02....       LJMP      ??Subroutine109_0 & 0xFFFF
   4275          
   4276          /******************************************************************************
   4277           * @fn          ZDSecMgrInitNVKeyTables
   4278           *
   4279           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   4280           *           
   4281           * @param       setDefault - TRUE to set default values 
   4282           *
   4283           * @return      none
   4284           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4285          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   4286          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   4287            ZDSecMgrNwkKeyInit(setDefault);
   \   000007                ; Setup parameters for call to function ZDSecMgrNwkKeyInit
   \   000007   12....       LCALL     `??ZDSecMgrNwkKeyInit::?relay`; Banked call to: ZDSecMgrNwkKeyInit
   4288            ZDSecMgrMasterKeyInit();
   \   00000A                ; Setup parameters for call to function ZDSecMgrMasterKeyInit
   \   00000A   12....       LCALL     `??ZDSecMgrMasterKeyInit::?relay`; Banked call to: ZDSecMgrMasterKeyInit
   4289            ZDSecMgrApsLinkKeyInit();
   \   00000D                ; Setup parameters for call to function ZDSecMgrApsLinkKeyInit
   \   00000D   12....       LCALL     `??ZDSecMgrApsLinkKeyInit::?relay`; Banked call to: ZDSecMgrApsLinkKeyInit
   4290            APSME_TCLinkKeyInit(setDefault);
   \   000010                ; Setup parameters for call to function APSME_TCLinkKeyInit
   \   000010   EE           MOV       A,R6
   \   000011   F9           MOV       R1,A
   \   000012   12....       LCALL     `??APSME_TCLinkKeyInit::?relay`; Banked call to: APSME_TCLinkKeyInit
   4291          }
   \   000015   02....       LJMP      ??Subroutine101_0 & 0xFFFF
   4292          
   4293          /******************************************************************************
   4294           * @fn          ZDSecMgrSaveApsLinkKey
   4295           *
   4296           * @brief       Save APS Link Key to NV. It will loop through all the keys  
   4297           *              to see which one to save.
   4298           *           
   4299           * @param       none
   4300           *
   4301           * @return      none
   4302           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4303          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   4304          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   4305            APSME_LinkKeyData_t *pKeyData = NULL;
   4306            int i;
   4307            
   4308            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   12....       LCALL     ?Subroutine64 & 0xFFFF
   4309            
   4310            if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_314:
   \   000008   7003         JNZ       $+5
   \   00000A   02....       LJMP      ??CrossCallReturnLabel_267 & 0xFFFF
   4311            {          
   4312              // checks all pending flags to know which one to save
   4313              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   00000D   75..00       MOV       ?V2,#0x0
   \   000010   75..00       MOV       ?V3,#0x0
   4314              {
   4315                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   000013   E5..         MOV       A,?V2
   \   000015   75F009       MOV       B,#0x9
   \   000018   A4           MUL       AB
   \   000019   F8           MOV       R0,A
   \   00001A   AAF0         MOV       R2,B
   \   00001C   75F009       MOV       B,#0x9
   \   00001F   E5..         MOV       A,?V3
   \   000021   A4           MUL       AB
   \   000022   2A           ADD       A,R2
   \   000023   F9           MOV       R1,A
   \   000024   74..         MOV       A,#ApsLinkKeyFrmCntr & 0xff
   \   000026   28           ADD       A,R0
   \   000027   F5..         MOV       ?V6,A
   \   000029   74..         MOV       A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   00002B   12....       LCALL     ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   00002E   706D         JNZ       ??ZDSecMgrSaveApsLinkKey_1
   \   000030   E5..         MOV       A,?V2
   \   000032   2401         ADD       A,#0x1
   \   000034   FE           MOV       R6,A
   \   000035   E5..         MOV       A,?V3
   \   000037   3402         ADDC      A,#0x2
   \   000039   FF           MOV       R7,A
   \   00003A                ; Setup parameters for call to function osal_nv_read
   \   00003A   78..         MOV       R0,#?V0
   \   00003C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003F   75..18       MOV       ?V4,#0x18
   \   000042   75..00       MOV       ?V5,#0x0
   \   000045   78..         MOV       R0,#?V4
   \   000047   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004A   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   00004D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000050   E9           MOV       A,R1
   \   000051   704A         JNZ       ??ZDSecMgrSaveApsLinkKey_1
   4316                {
   4317                  // retrieve key from NV
   4318                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0, 
   4319                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   4320                  {                
   4321                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   000053   85..82       MOV       DPL,?V6
   \   000056   85..83       MOV       DPH,?V7
   \   000059   12....       LCALL     ?XLOAD_R0123
   \   00005C   E5..         MOV       A,?V0
   \   00005E   2410         ADD       A,#0x10
   \   000060   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000063   12....       LCALL     ?XSTORE_R0123
   4322                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   000066   85..82       MOV       DPL,?V6
   \   000069   85..83       MOV       DPH,?V7
   \   00006C   A3           INC       DPTR
   \   00006D   A3           INC       DPTR
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   12....       LCALL     ?XLOAD_R0123
   \   000073   E5..         MOV       A,?V0
   \   000075   2414         ADD       A,#0x14
   \   000077   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   00007A   12....       LCALL     ?XSTORE_R0123
   4323                    
   4324                    // Write the APS link key back to the NV
   4325                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0, 
   4326                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   00007D                ; Setup parameters for call to function osal_nv_write
   \   00007D   78..         MOV       R0,#?V0
   \   00007F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000082   78..         MOV       R0,#?V4
   \   000084   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000087   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   00008A   12....       LCALL     ?DEALLOC_XSTACK8
   4327                    
   4328                    // clear the pending write flag
   4329                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   00008D   85..82       MOV       DPL,?V6
   \   000090   85..83       MOV       DPH,?V7
   \   000093   A3           INC       DPTR
   \   000094   A3           INC       DPTR
   \   000095   A3           INC       DPTR
   \   000096   A3           INC       DPTR
   \   000097   A3           INC       DPTR
   \   000098   A3           INC       DPTR
   \   000099   A3           INC       DPTR
   \   00009A   A3           INC       DPTR
   \   00009B   E4           CLR       A
   \   00009C   F0           MOVX      @DPTR,A
   4330                  }
   4331                }
   4332              }
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   00009D   05..         INC       ?V2
   \   00009F   E5..         MOV       A,?V2
   \   0000A1   7002         JNZ       ??ZDSecMgrSaveApsLinkKey_2
   \   0000A3   05..         INC       ?V3
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   0000A5   C3           CLR       C
   \   0000A6   9403         SUBB      A,#0x3
   \   0000A8   E5..         MOV       A,?V3
   \   0000AA   9400         SUBB      A,#0x0
   \   0000AC   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0000AE   65D0         XRL       A,PSW
   \   0000B0   33           RLC       A
   \   0000B1   5003         JNC       $+5
   \   0000B3   02....       LJMP      ??ZDSecMgrSaveApsLinkKey_0 & 0xFFFF
   4333              
   4334              // clear copy of key in RAM 
   4335              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000B6                ; Setup parameters for call to function osal_memset
   \   0000B6   12....       LCALL     ?Subroutine37 & 0xFFFF
   4336              
   4337              osal_mem_free(pKeyData);
   4338            }  
   4339          }
   \                     ??CrossCallReturnLabel_267:
   \   0000B9   02....       LJMP      ??Subroutine131_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   39           ADDC      A,R1
   \   000001   F5..         MOV       ?V7,A
   \   000003   85..82       MOV       DPL,?V6
   \   000006   F583         MOV       DPH,A
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   E0           MOVX      A,@DPTR
   \   000011   6401         XRL       A,#0x1
   \   000013   22           RET
   4340          
   4341          /******************************************************************************
   4342           * @fn          ZDSecMgrSaveTCLinkKey
   4343           *
   4344           * @brief       Save TC Link Key to NV. It will loop through all the keys 
   4345           *              to see which one to save.
   4346           *           
   4347           * @param       none
   4348           *
   4349           * @return      none
   4350           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4351          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   4352          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   4353            APSME_TCLinkKey_t *pKeyData = NULL;
   4354            int i;
   4355            
   4356            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A20         MOV       R2,#0x20
   \   000007   12....       LCALL     ??Subroutine129_0 & 0xFFFF
   4357            
   4358            if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_315:
   \   00000A   7003         JNZ       $+5
   \   00000C   02....       LJMP      ??CrossCallReturnLabel_268 & 0xFFFF
   4359            {          
   4360              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00000F   75..00       MOV       ?V2,#0x0
   \   000012   75..00       MOV       ?V3,#0x0
   4361              {
   4362                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   000015   E5..         MOV       A,?V2
   \   000017   75F009       MOV       B,#0x9
   \   00001A   A4           MUL       AB
   \   00001B   F8           MOV       R0,A
   \   00001C   AAF0         MOV       R2,B
   \   00001E   75F009       MOV       B,#0x9
   \   000021   E5..         MOV       A,?V3
   \   000023   A4           MUL       AB
   \   000024   2A           ADD       A,R2
   \   000025   F9           MOV       R1,A
   \   000026   74..         MOV       A,#TCLinkKeyFrmCntr & 0xff
   \   000028   28           ADD       A,R0
   \   000029   F5..         MOV       ?V6,A
   \   00002B   74..         MOV       A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   00002D   12....       LCALL     ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000030   706D         JNZ       ??ZDSecMgrSaveTCLinkKey_1
   \   000032   E5..         MOV       A,?V2
   \   000034   2401         ADD       A,#0x1
   \   000036   FE           MOV       R6,A
   \   000037   E5..         MOV       A,?V3
   \   000039   3401         ADDC      A,#0x1
   \   00003B   FF           MOV       R7,A
   \   00003C                ; Setup parameters for call to function osal_nv_read
   \   00003C   78..         MOV       R0,#?V0
   \   00003E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000041   75..20       MOV       ?V4,#0x20
   \   000044   75..00       MOV       ?V5,#0x0
   \   000047   78..         MOV       R0,#?V4
   \   000049   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004C   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   00004F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000052   E9           MOV       A,R1
   \   000053   704A         JNZ       ??ZDSecMgrSaveTCLinkKey_1
   4363                {
   4364                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0, 
   4365                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   4366                  {                
   4367                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   000055   85..82       MOV       DPL,?V6
   \   000058   85..83       MOV       DPH,?V7
   \   00005B   12....       LCALL     ?XLOAD_R0123
   \   00005E   E5..         MOV       A,?V0
   \   000060   2418         ADD       A,#0x18
   \   000062   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000065   12....       LCALL     ?XSTORE_R0123
   4368                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   000068   85..82       MOV       DPL,?V6
   \   00006B   85..83       MOV       DPH,?V7
   \   00006E   A3           INC       DPTR
   \   00006F   A3           INC       DPTR
   \   000070   A3           INC       DPTR
   \   000071   A3           INC       DPTR
   \   000072   12....       LCALL     ?XLOAD_R0123
   \   000075   E5..         MOV       A,?V0
   \   000077   241C         ADD       A,#0x1c
   \   000079   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   00007C   12....       LCALL     ?XSTORE_R0123
   4369                    
   4370                    // Write the TC link key back to the NV
   4371                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0, 
   4372                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   \   00007F                ; Setup parameters for call to function osal_nv_write
   \   00007F   78..         MOV       R0,#?V0
   \   000081   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000084   78..         MOV       R0,#?V4
   \   000086   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000089   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   00008C   12....       LCALL     ?DEALLOC_XSTACK8
   4373                    
   4374                    // clear the pending write flag
   4375                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   00008F   85..82       MOV       DPL,?V6
   \   000092   85..83       MOV       DPH,?V7
   \   000095   A3           INC       DPTR
   \   000096   A3           INC       DPTR
   \   000097   A3           INC       DPTR
   \   000098   A3           INC       DPTR
   \   000099   A3           INC       DPTR
   \   00009A   A3           INC       DPTR
   \   00009B   A3           INC       DPTR
   \   00009C   A3           INC       DPTR
   \   00009D   E4           CLR       A
   \   00009E   F0           MOVX      @DPTR,A
   4376                  }
   4377                }
   4378              }
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   00009F   05..         INC       ?V2
   \   0000A1   E5..         MOV       A,?V2
   \   0000A3   7002         JNZ       ??ZDSecMgrSaveTCLinkKey_2
   \   0000A5   05..         INC       ?V3
   \                     ??ZDSecMgrSaveTCLinkKey_2:
   \   0000A7   C3           CLR       C
   \   0000A8   9401         SUBB      A,#0x1
   \   0000AA   E5..         MOV       A,?V3
   \   0000AC   9400         SUBB      A,#0x0
   \   0000AE   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0000B0   65D0         XRL       A,PSW
   \   0000B2   33           RLC       A
   \   0000B3   5003         JNC       $+5
   \   0000B5   02....       LJMP      ??ZDSecMgrSaveTCLinkKey_0 & 0xFFFF
   4379                // clear copy of key in RAM 
   4380              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   0000B8                ; Setup parameters for call to function osal_memset
   \   0000B8   7C20         MOV       R4,#0x20
   \   0000BA   12....       LCALL     ??Subroutine122_0 & 0xFFFF
   4381              
   4382              osal_mem_free(pKeyData);
   4383            }
   4384          }
   \                     ??CrossCallReturnLabel_268:
   \   0000BD   02....       LJMP      ??Subroutine131_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   12....       LCALL     ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   000003   12....       LCALL     `??ZDSecMgrEntryFree::?relay`; Banked call to: ZDSecMgrEntryFree
   \   000006   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupAMI::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExtGetIndex::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExtGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryFree::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlRelease::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlAdd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlTerm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlReset::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendMasterKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceEntryRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemoveByExtAddr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrMgrUpdate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceEntryAdd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlSetup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlUpdate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_SKA_TimerExpired::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateSKKE::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateRM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateCM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinDirect::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinFwd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAssocDeviceAuth::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthInitiate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrConfig::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoining::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoiningTimeout::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNewDeviceEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKeyCfm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCExtAddrCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCDataLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTransportKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRemoveDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSwitchKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticateInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticateCfm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestAppKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSetupPartner::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_MasterKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeySet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeyNVIdGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyNVIdGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsLinkKeyValid::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsLinkKeyValid

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_KeyFwdToChild::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSetDefaultNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAPSRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeySync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsDefaultTCLK::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNwkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNwkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrReadKeyFromNv::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrReadKeyFromNv

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrApsLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrApsLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInitNVKeyTables::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNVKeyTables

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSaveApsLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveApsLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSaveTCLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveTCLinkKey
   4385          
   4386          #if defined ( NV_RESTORE )
   4387          /******************************************************************************
   4388           * @fn          ZDSecMgrClearNVKeyValues
   4389           *
   4390           * @brief       If NV_RESTORE is enabled and the status of the network needs 
   4391           *              default values this fuction clears ZCD_NV_NWKKEY, 
   4392           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link 
   4393           *           
   4394           * @param       none
   4395           *
   4396           * @return      none
   4397           */
   4398          void ZDSecMgrClearNVKeyValues(void)
   4399          {
   4400            nwkActiveKeyItems keyItems;
   4401            nwkKeyDesc nwkKey;
   4402          
   4403            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   4404          
   4405            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   4406          
   4407            // Initialize NV items for NWK Active and Alternate keys. 
   4408            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   4409          
   4410            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4411          
   4412            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4413          }
   4414          #endif // defined ( NV_RESTORE )
   4415          
   4416          /******************************************************************************
   4417          ******************************************************************************/
   4418          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     66   APSME_IsDefaultTCLK
      0     36   APSME_IsLinkKeyValid
        0     32   -> APSME_LinkKeyNVIdGet
        0     32   -> osal_mem_alloc
        0     35   -> osal_memcmp
        0     32   -> osal_memset
        0     36   -> osal_nv_read
      0     10   APSME_KeyFwdToChild
        0     10   -> AssocGetWithExt
        0     10   -> ZDSecMgrAssocDeviceAuth
      0     43   APSME_LinkKeyNVIdGet
        0     11   -> ZDSecMgrEntryLookupExt
      0     37   APSME_LinkKeySet
        0     21   -> ZDSecMgrEntryLookupExtGetIndex
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     22   -> osal_memcpy
        0     19   -> osal_memset
        0     23   -> osal_nv_read
        0     23   -> osal_nv_write
      0     11   APSME_MasterKeyGet
        0     11   -> ZDSecMgrExtAddrLookup
        0     11   -> ZDSecMgrMasterKeyLookup
      0      0   APSME_SKA_TimerExpired
      0     56   APSME_TCLinkKeyInit
        0     46   -> osal_memcpy
        0     43   -> osal_memset
        0     45   -> osal_nv_item_init
        0     47   -> osal_nv_read
        0     47   -> osal_nv_write
      0     61   APSME_TCLinkKeyLoad
        0     57   -> APSME_IsDefaultTCLK
        0     57   -> APSME_LookupExtAddr
        0     57   -> AddrMgrEntryLookupNwk
        0     57   -> AddrMgrEntryRelease
        0     57   -> AddrMgrExtAddrEqual
        0     57   -> AddrMgrExtAddrValid
        0     57   -> osal_memset
        0     61   -> osal_nv_read
      0     52   APSME_TCLinkKeySync
        0     48   -> APSME_IsDefaultTCLK
        0     48   -> APSME_LookupExtAddr
        0     48   -> AddrMgrExtAddrEqual
        0     48   -> AddrMgrExtAddrValid
        0     48   -> osal_memset
        0     52   -> osal_nv_read
      2     12   ZDSecMgrAPSRemove
        2     10   -> ZDSecMgrDeviceRemove
      0     18   ZDSecMgrAddLinkKey
        0     14   -> APSME_LinkKeySet
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
      0     36   ZDSecMgrAddrMgrUpdate
        0     22   -> AddrMgrEntryGet
        0     22   -> AddrMgrEntryUpdate
      0     55   ZDSecMgrAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      3     59   ZDSecMgrAppKeyGet
        2      0   -> SSP_GetTrueRand
      0     59   ZDSecMgrAppKeyReq
        0     51   -> APSME_LookupExtAddr
        0     51   -> APSME_LookupNwkAddr
        0     51   -> APSME_TransportKeyReq
        0     59   -> ZDSecMgrAppKeyGet
        0     51   -> osal_memset
      0     49   ZDSecMgrApsLinkKeyInit
        0     36   -> osal_memset
        0     38   -> osal_nv_item_init
        0     40   -> osal_nv_write
      2     35   ZDSecMgrAssocDeviceAuth
      0     16   ZDSecMgrAuthInitiate
        0     16   -> APSME_AuthenticateReq
        0     16   -> APSME_LookupNwkAddr
      2     26   ZDSecMgrAuthNwkKey
        2      0   -> osal_set_event
      2      0   ZDSecMgrAuthenticateCfm
        2      0   -> osal_set_event
      0     32   ZDSecMgrAuthenticateInd
        0     32   -> APSME_AuthenticateReq
        0     32   -> AddrMgrEntryUpdate
        0     32   -> AddrMgrExtAddrSet
      0      0   ZDSecMgrAuthenticationCheck
      1     11   ZDSecMgrAuthenticationSet
        0     11   -> ZDSecMgrEntryLookupExt
      2      0   ZDSecMgrConfig
        2      0   -> APSME_SecurityNM
      0     26   ZDSecMgrCtrlAdd
        0     14   -> ZDSecMgrCtrlSet
      2      0   ZDSecMgrCtrlInit
        2      0   -> osal_mem_alloc
      0     23   ZDSecMgrCtrlLookup
      2      0   ZDSecMgrCtrlRelease
      0     14   ZDSecMgrCtrlReset
        0     12   -> ZDSecMgrCtrlAdd
        0     12   -> ZDSecMgrCtrlLookup
        0     14   -> ZDSecMgrCtrlSet
      1     23   ZDSecMgrCtrlSet
      2      2   ZDSecMgrCtrlTerm
        2      2   -> ZDSecMgrCtrlLookup
      1     42   ZDSecMgrDeviceCtrlHandler
        0      9   -> ZDSecMgrEstablishKey
        0      9   -> ZDSecMgrSendMasterKey
        0      9   -> ZDSecMgrSendNwkKey
        0      9   -> osal_start_timerEx
      2      0   ZDSecMgrDeviceCtrlSetup
        2      0   -> ZDSecMgrDeviceCtrlHandler
      0     13   ZDSecMgrDeviceCtrlUpdate
        0     13   -> ZDSecMgrCtrlLookup
        0     13   -> ZDSecMgrEntryLookupExt
      0     44   ZDSecMgrDeviceEntryAdd
        0     14   -> ZDSecMgrAddrMgrUpdate
        0     14   -> ZDSecMgrEntryFree
        0     14   -> ZDSecMgrEntryLookup
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
      2      0   ZDSecMgrDeviceEntryRemove
        2      0   -> ZDSecMgrEntryFree
      0     24   ZDSecMgrDeviceJoin
        0     14   -> ZDSecMgrAddrStore
        0     12   -> ZDSecMgrDeviceRemove
        0     12   -> ZDSecMgrDeviceValidate
        0     12   -> ZDSecMgrSendNwkKey
      0      9   ZDSecMgrDeviceJoinDirect
        0      9   -> AssocGetWithShort
        0      9   -> ZDSecMgrAssocDeviceAuth
        0      9   -> ZDSecMgrDeviceJoin
      2      8   ZDSecMgrDeviceJoinFwd
        2      8   -> APSME_UpdateDeviceReq
      2     35   ZDSecMgrDeviceNew
        2      0   -> ZDSecMgrDeviceJoinFwd
      0     38   ZDSecMgrDeviceRemove
        0     19   -> APSME_RemoveDeviceReq
        0     19   -> AssocGetWithExt
        0     19   -> NLME_GetShortAddr
        0     19   -> NLME_LeaveReq
      0     11   ZDSecMgrDeviceRemoveByExtAddr
        0     11   -> ZDSecMgrEntryFree
        0     11   -> ZDSecMgrEntryLookupExt
      2     12   ZDSecMgrDeviceValidate
        2      0   -> ZDSecMgrDeviceValidateRM
      0     33   ZDSecMgrDeviceValidateCM
        0     32   -> ZDSecMgrAddrStore
        0     30   -> ZDSecMgrDeviceEntryAdd
        0     30   -> ZDSecMgrMasterKeyLoad
        0     33   -> osal_memcpy
        0     30   -> osal_memset
      2      0   ZDSecMgrDeviceValidateRM
      0     44   ZDSecMgrDeviceValidateSKKE
        0     13   -> ZDSecMgrDeviceEntryAdd
        0     13   -> ZDSecMgrExtAddrLookup
        0     13   -> ZDSecMgrMasterKeyLookup
      0     32   ZDSecMgrEntryFree
        0     14   -> osal_mem_alloc
        0     14   -> osal_mem_free
        0     14   -> osal_memset
        0     18   -> osal_nv_write
      2      0   ZDSecMgrEntryInit
        2      0   -> osal_mem_alloc
      0     36   ZDSecMgrEntryLookup
        0     22   -> AddrMgrEntryLookupNwk
      0     23   ZDSecMgrEntryLookupAMI
      0     24   ZDSecMgrEntryLookupExt
        0     11   -> ZDSecMgrEntryLookupAMI
        0     11   -> ZDSecMgrExtAddrLookup
      0     32   ZDSecMgrEntryLookupExtGetIndex
        0     11   -> ZDSecMgrExtAddrLookup
      0     24   ZDSecMgrEntryNew
      0     26   ZDSecMgrEstablishKey
        0     17   -> APSME_EstablishKeyReq
        0     17   -> NLME_GetShortAddr
      0      0   ZDSecMgrEstablishKeyCfm
      1     31   ZDSecMgrEstablishKeyInd
        0     31   -> APSME_EstablishKeyRsp
        0     31   -> ZDSecMgrDeviceValidateSKKE
        0     31   -> ZDSecMgrTCDataLoad
        0     31   -> ZDSecMgrTCExtAddrCheck
      1     33   ZDSecMgrEvent
        0     33   -> AddrMgrEntryGet
        0     33   -> ZDSecMgrDeviceCtrlHandler
        0     33   -> osal_start_timerEx
      0     36   ZDSecMgrExtAddrLookup
        0     22   -> AddrMgrEntryLookupExt
        0     22   -> AddrMgrExtAddrSet
      0     24   ZDSecMgrExtAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      2      0   ZDSecMgrInit
        2      0   -> APSME_SecurityNM
      0      9   ZDSecMgrInitNVKeyTables
        0      9   -> APSME_TCLinkKeyInit
        0      9   -> ZDSecMgrApsLinkKeyInit
        0      9   -> ZDSecMgrMasterKeyInit
        0      9   -> ZDSecMgrNwkKeyInit
      0     43   ZDSecMgrMasterKeyInit
        0     30   -> osal_memset
        0     32   -> osal_nv_item_init
        0     34   -> osal_nv_write
      0     48   ZDSecMgrMasterKeyLoad
        0     14   -> ZDSecMgrExtAddrLookup
        0     14   -> ZDSecMgrMasterKeyLookup
        0     14   -> ZDSecMgrMasterKeyStore
        0     18   -> osal_nv_write
      0     79   ZDSecMgrMasterKeyLookup
        0     34   -> osal_memset
        0     38   -> osal_nv_read
      0     69   ZDSecMgrMasterKeyStore
        0     37   -> osal_memcpy
        0     34   -> osal_memset
        0     38   -> osal_nv_read
        0     38   -> osal_nv_write
      1     35   ZDSecMgrNewDeviceEvent
        0     35   -> AddrMgrEntryGet
        0     35   -> AssocMatchDeviceStatus
        0     35   -> AssocRemove
        0     35   -> NLME_GetShortAddr
        0     35   -> ZDSecMgrAssocDeviceAuth
        0     35   -> ZDSecMgrDeviceNew
      0     61   ZDSecMgrNwkKeyInit
        0     48   -> osal_memset
        0     50   -> osal_nv_item_init
        0     52   -> osal_nv_write
      2      0   ZDSecMgrPermitJoining
      2      0   ZDSecMgrPermitJoiningTimeout
      0     40   ZDSecMgrReadKeyFromNv
        0     14   -> osal_nv_read
      0     19   ZDSecMgrRemoveDeviceInd
        0     19   -> APSME_LookupNwkAddr
        0     19   -> NLME_GetShortAddr
        0     19   -> ZDSecMgrDeviceRemove
      2     12   ZDSecMgrRequestAppKey
        2     12   -> APSME_RequestKeyReq
        2     12   -> AddrMgrExtAddrLookup
      2      0   ZDSecMgrRequestKeyInd
        2      0   -> ZDSecMgrAppKeyReq
      0     20   ZDSecMgrSaveApsLinkKey
        0     16   -> osal_mem_alloc
        0     16   -> osal_mem_free
        0     16   -> osal_memset
        0     20   -> osal_nv_read
        0     20   -> osal_nv_write
      0     20   ZDSecMgrSaveTCLinkKey
        0     16   -> osal_mem_alloc
        0     16   -> osal_mem_free
        0     16   -> osal_memset
        0     20   -> osal_nv_read
        0     20   -> osal_nv_write
      0     54   ZDSecMgrSendMasterKey
        0     41   -> APSME_TransportKeyReq
        0     41   -> NLME_GetShortAddr
        0     41   -> ZDSecMgrMasterKeyLookup
        0     41   -> osal_memset
        0     45   -> osal_nv_read
      1     58   ZDSecMgrSendNwkKey
        0     42   -> APSME_TransportKeyReq
        0     42   -> NLME_GetShortAddr
        0     46   -> NLME_ReadNwkKeyInfo
        0     42   -> osal_memset
      0     23   ZDSecMgrSetDefaultNV
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     19   -> osal_memset
        0     23   -> osal_nv_write
      0     24   ZDSecMgrSetupPartner
        0     24   -> AddrMgrEntryUpdate
        0     24   -> AddrMgrExtAddrSet
        0     24   -> AddrMgrExtAddrValid
        0     24   -> ZDP_IEEEAddrReq
        0     24   -> ZDP_NwkAddrReq
      2      0   ZDSecMgrSwitchKeyInd
        2      0   -> SSP_SwitchNwkKey
        2      0   -> ZDApp_NVUpdate
      0     65   ZDSecMgrTCDataLoad
        0     33   -> ZDSecMgrAddrStore
        0     31   -> ZDSecMgrMasterKeyLookup
        0     31   -> ZDSecMgrMasterKeyStore
        0     34   -> osal_memcpy
        0     31   -> osal_memset
      0     48   ZDSecMgrTCExtAddrCheck
        0     17   -> AddrMgrExtAddrEqual
        0     17   -> AddrMgrExtAddrLookup
      0     26   ZDSecMgrTransportKeyInd
        0     26   -> SSP_SwitchNwkKey
        0     26   -> SSP_UpdateNwkKey
        0     26   -> ZDSecMgrAuthNwkKey
        0     26   -> ZDSecMgrReadKeyFromNv
        0     26   -> ZDSecMgrTCDataLoad
        0     26   -> osal_memset
      2     10   ZDSecMgrUpdateDeviceInd
        2     10   -> ZDSecMgrDeviceJoin


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for ZDSecMgrAppKeyType>
       3  ??Subroutine100_0
       5  ??Subroutine101_0
       8  ??Subroutine102_0
       8  ??Subroutine103_0
       4  ??Subroutine104_0
       7  ??Subroutine105_0
       6  ??Subroutine106_0
       6  ??Subroutine107_0
       6  ??Subroutine108_0
       3  ??Subroutine109_0
       5  ??Subroutine110_0
       3  ??Subroutine111_0
       6  ??Subroutine112_0
       6  ??Subroutine113_0
       3  ??Subroutine114_0
       5  ??Subroutine115_0
       5  ??Subroutine116_0
       6  ??Subroutine117_0
       5  ??Subroutine118_0
       4  ??Subroutine119_0
       4  ??Subroutine120_0
       6  ??Subroutine121_0
      19  ??Subroutine122_0
       1  ??Subroutine123_0
       6  ??Subroutine124_0
       2  ??Subroutine125_0
       9  ??Subroutine126_0
       4  ??Subroutine127_0
       5  ??Subroutine128_0
      12  ??Subroutine129_0
       3  ??Subroutine130_0
       5  ??Subroutine131_0
       6  ??Subroutine88_0
       7  ??Subroutine89_0
       6  ??Subroutine90_0
       6  ??Subroutine91_0
       6  ??Subroutine92_0
       6  ??Subroutine93_0
       1  ??Subroutine94_0
       7  ??Subroutine95_0
       6  ??Subroutine96_0
       4  ??Subroutine97_0
       7  ??Subroutine98_0
       2  ??Subroutine99_0
       2  ?Subroutine0
       2  ?Subroutine1
       5  ?Subroutine10
       8  ?Subroutine11
       5  ?Subroutine12
       4  ?Subroutine13
      16  ?Subroutine14
      13  ?Subroutine15
      13  ?Subroutine16
       3  ?Subroutine17
       6  ?Subroutine18
       7  ?Subroutine19
       2  ?Subroutine2
      11  ?Subroutine20
      13  ?Subroutine21
       8  ?Subroutine22
       9  ?Subroutine23
       8  ?Subroutine24
       9  ?Subroutine25
       6  ?Subroutine26
       6  ?Subroutine27
       3  ?Subroutine28
       6  ?Subroutine29
       7  ?Subroutine3
       7  ?Subroutine30
       4  ?Subroutine31
       9  ?Subroutine32
       7  ?Subroutine33
       2  ?Subroutine34
       7  ?Subroutine35
       1  ?Subroutine36
       2  ?Subroutine37
      10  ?Subroutine38
       6  ?Subroutine39
       3  ?Subroutine4
       8  ?Subroutine40
       1  ?Subroutine41
       4  ?Subroutine42
       6  ?Subroutine43
      18  ?Subroutine44
       2  ?Subroutine45
      14  ?Subroutine46
       9  ?Subroutine47
       9  ?Subroutine48
       6  ?Subroutine49
       2  ?Subroutine5
       6  ?Subroutine50
       5  ?Subroutine51
       7  ?Subroutine52
       6  ?Subroutine53
      13  ?Subroutine54
      14  ?Subroutine55
       8  ?Subroutine56
       9  ?Subroutine57
       7  ?Subroutine58
       7  ?Subroutine59
       8  ?Subroutine6
       7  ?Subroutine60
       7  ?Subroutine61
       4  ?Subroutine62
       1  ?Subroutine63
       2  ?Subroutine64
       8  ?Subroutine65
      30  ?Subroutine66
       4  ?Subroutine67
      20  ?Subroutine68
       8  ?Subroutine69
       5  ?Subroutine7
      13  ?Subroutine70
       9  ?Subroutine71
       9  ?Subroutine72
       6  ?Subroutine73
       8  ?Subroutine74
       6  ?Subroutine75
      15  ?Subroutine76
       6  ?Subroutine77
       6  ?Subroutine78
      10  ?Subroutine79
       4  ?Subroutine8
      11  ?Subroutine80
      12  ?Subroutine81
       9  ?Subroutine82
       2  ?Subroutine83
       4  ?Subroutine84
       9  ?Subroutine85
       5  ?Subroutine86
       5  ?Subroutine87
       2  ?Subroutine9
      52  APSME_IsDefaultTCLK
       6  APSME_IsDefaultTCLK::?relay
     146  APSME_IsLinkKeyValid
       6  APSME_IsLinkKeyValid::?relay
      61  APSME_KeyFwdToChild
       6  APSME_KeyFwdToChild::?relay
      56  APSME_LinkKeyNVIdGet
       6  APSME_LinkKeyNVIdGet::?relay
     258  APSME_LinkKeySet
       6  APSME_LinkKeySet::?relay
      55  APSME_MasterKeyGet
       6  APSME_MasterKeyGet::?relay
       3  APSME_SKA_TimerExpired
       6  APSME_SKA_TimerExpired::?relay
     233  APSME_TCLinkKeyInit
       6  APSME_TCLinkKeyInit::?relay
     227  APSME_TCLinkKeyLoad
       6  APSME_TCLinkKeyLoad::?relay
     186  APSME_TCLinkKeySync
       6  APSME_TCLinkKeySync::?relay
      27  ApsLinkKeyFrmCntr
       9  TCLinkKeyFrmCntr
      32  TrustCenterLinkKey
      72  ZDSecMgrAPSRemove
       6  ZDSecMgrAPSRemove::?relay
     104  ZDSecMgrAddLinkKey
       6  ZDSecMgrAddLinkKey::?relay
      66  ZDSecMgrAddrMgrUpdate
       6  ZDSecMgrAddrMgrUpdate::?relay
      67  ZDSecMgrAddrStore
       6  ZDSecMgrAddrStore::?relay
      43  ZDSecMgrAppKeyGet
       6  ZDSecMgrAppKeyGet::?relay
     262  ZDSecMgrAppKeyReq
       6  ZDSecMgrAppKeyReq::?relay
       1  ZDSecMgrAppKeyType
      94  ZDSecMgrApsLinkKeyInit
       6  ZDSecMgrApsLinkKeyInit::?relay
      23  ZDSecMgrAssocDeviceAuth
       6  ZDSecMgrAssocDeviceAuth::?relay
      60  ZDSecMgrAuthInitiate
       6  ZDSecMgrAuthInitiate::?relay
      27  ZDSecMgrAuthNwkKey
       6  ZDSecMgrAuthNwkKey::?relay
      50  ZDSecMgrAuthenticateCfm
       6  ZDSecMgrAuthenticateCfm::?relay
     123  ZDSecMgrAuthenticateInd
       6  ZDSecMgrAuthenticateInd::?relay
       5  ZDSecMgrAuthenticationCheck
       6  ZDSecMgrAuthenticationCheck::?relay
      33  ZDSecMgrAuthenticationSet
       6  ZDSecMgrAuthenticationSet::?relay
       3  ZDSecMgrConfig
       6  ZDSecMgrConfig::?relay
      96  ZDSecMgrCtrlAdd
       6  ZDSecMgrCtrlAdd::?relay
       2  ZDSecMgrCtrlData
      78  ZDSecMgrCtrlInit
       6  ZDSecMgrCtrlInit::?relay
      99  ZDSecMgrCtrlLookup
       6  ZDSecMgrCtrlLookup::?relay
      18  ZDSecMgrCtrlRelease
       6  ZDSecMgrCtrlRelease::?relay
      75  ZDSecMgrCtrlReset
       6  ZDSecMgrCtrlReset::?relay
      74  ZDSecMgrCtrlSet
       6  ZDSecMgrCtrlSet::?relay
      38  ZDSecMgrCtrlTerm
       6  ZDSecMgrCtrlTerm::?relay
     102  ZDSecMgrDeviceCtrlHandler
       6  ZDSecMgrDeviceCtrlHandler::?relay
      58  ZDSecMgrDeviceCtrlSetup
       6  ZDSecMgrDeviceCtrlSetup::?relay
      99  ZDSecMgrDeviceCtrlUpdate
       6  ZDSecMgrDeviceCtrlUpdate::?relay
     140  ZDSecMgrDeviceEntryAdd
       6  ZDSecMgrDeviceEntryAdd::?relay
      10  ZDSecMgrDeviceEntryRemove
       6  ZDSecMgrDeviceEntryRemove::?relay
      71  ZDSecMgrDeviceJoin
       6  ZDSecMgrDeviceJoin::?relay
      31  ZDSecMgrDeviceJoinDirect
       6  ZDSecMgrDeviceJoinDirect::?relay
     159  ZDSecMgrDeviceJoinFwd
       6  ZDSecMgrDeviceJoinFwd::?relay
       9  ZDSecMgrDeviceNew
       6  ZDSecMgrDeviceNew::?relay
     167  ZDSecMgrDeviceRemove
       6  ZDSecMgrDeviceRemove::?relay
      29  ZDSecMgrDeviceRemoveByExtAddr
       6  ZDSecMgrDeviceRemoveByExtAddr::?relay
      49  ZDSecMgrDeviceValidate
       6  ZDSecMgrDeviceValidate::?relay
     125  ZDSecMgrDeviceValidateCM
       6  ZDSecMgrDeviceValidateCM::?relay
      17  ZDSecMgrDeviceValidateRM
       6  ZDSecMgrDeviceValidateRM::?relay
      52  ZDSecMgrDeviceValidateSKKE
       6  ZDSecMgrDeviceValidateSKKE::?relay
       2  ZDSecMgrEntries
     105  ZDSecMgrEntryFree
       6  ZDSecMgrEntryFree::?relay
      66  ZDSecMgrEntryInit
       6  ZDSecMgrEntryInit::?relay
      99  ZDSecMgrEntryLookup
       6  ZDSecMgrEntryLookup::?relay
      79  ZDSecMgrEntryLookupAMI
       6  ZDSecMgrEntryLookupAMI::?relay
      54  ZDSecMgrEntryLookupExt
       6  ZDSecMgrEntryLookupExt::?relay
     107  ZDSecMgrEntryLookupExtGetIndex
       6  ZDSecMgrEntryLookupExtGetIndex::?relay
     127  ZDSecMgrEntryNew
       6  ZDSecMgrEntryNew::?relay
      94  ZDSecMgrEstablishKey
       6  ZDSecMgrEstablishKey::?relay
       3  ZDSecMgrEstablishKeyCfm
       6  ZDSecMgrEstablishKeyCfm::?relay
     213  ZDSecMgrEstablishKeyInd
       6  ZDSecMgrEstablishKeyInd::?relay
     267  ZDSecMgrEvent
       6  ZDSecMgrEvent::?relay
      69  ZDSecMgrExtAddrLookup
       6  ZDSecMgrExtAddrLookup::?relay
      66  ZDSecMgrExtAddrStore
       6  ZDSecMgrExtAddrStore::?relay
       3  ZDSecMgrInit
       6  ZDSecMgrInit::?relay
      24  ZDSecMgrInitNVKeyTables
       6  ZDSecMgrInitNVKeyTables::?relay
     106  ZDSecMgrMasterKeyInit
       6  ZDSecMgrMasterKeyInit::?relay
      82  ZDSecMgrMasterKeyLoad
       6  ZDSecMgrMasterKeyLoad::?relay
     130  ZDSecMgrMasterKeyLookup
       6  ZDSecMgrMasterKeyLookup::?relay
     211  ZDSecMgrMasterKeyStore
       6  ZDSecMgrMasterKeyStore::?relay
     178  ZDSecMgrNewDeviceEvent
       6  ZDSecMgrNewDeviceEvent::?relay
     223  ZDSecMgrNwkKeyInit
       6  ZDSecMgrNwkKeyInit::?relay
      39  ZDSecMgrPermitJoining
       6  ZDSecMgrPermitJoining::?relay
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      24  ZDSecMgrPermitJoiningTimeout
       6  ZDSecMgrPermitJoiningTimeout::?relay
     192  ZDSecMgrReadKeyFromNv
       6  ZDSecMgrReadKeyFromNv::?relay
      73  ZDSecMgrRemoveDeviceInd
       6  ZDSecMgrRemoveDeviceInd::?relay
      62  ZDSecMgrRequestAppKey
       6  ZDSecMgrRequestAppKey::?relay
      30  ZDSecMgrRequestKeyInd
       6  ZDSecMgrRequestKeyInd::?relay
     188  ZDSecMgrSaveApsLinkKey
       6  ZDSecMgrSaveApsLinkKey::?relay
     192  ZDSecMgrSaveTCLinkKey
       6  ZDSecMgrSaveTCLinkKey::?relay
     218  ZDSecMgrSendMasterKey
       6  ZDSecMgrSendMasterKey::?relay
     281  ZDSecMgrSendNwkKey
       6  ZDSecMgrSendNwkKey::?relay
     226  ZDSecMgrSetDefaultNV
       6  ZDSecMgrSetDefaultNV::?relay
     113  ZDSecMgrSetupPartner
       6  ZDSecMgrSetupPartner::?relay
      23  ZDSecMgrSwitchKeyInd
       6  ZDSecMgrSwitchKeyInd::?relay
       1  ZDSecMgrTCAuthenticated
     125  ZDSecMgrTCDataLoad
       6  ZDSecMgrTCDataLoad::?relay
       1  ZDSecMgrTCDataLoaded
       8  ZDSecMgrTCExtAddr
      52  ZDSecMgrTCExtAddrCheck
       6  ZDSecMgrTCExtAddrCheck::?relay
      16  ZDSecMgrTCMasterKey
     179  ZDSecMgrTransportKeyInd
       6  ZDSecMgrTransportKeyInd::?relay
      49  ZDSecMgrUpdateDeviceInd
       6  ZDSecMgrUpdateDeviceInd::?relay
       4  __Constant_1

 
 9 167 bytes in segment BANKED_CODE
   510 bytes in segment BANK_RELAYS
    16 bytes in segment CODE_C
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
     4 bytes in segment XDATA_ROM_C
    84 bytes in segment XDATA_Z
 
   527 bytes of CODE     memory
     0 bytes of CONST    memory (+ 4 bytes shared)
 9 167 bytes of HUGECODE memory
    85 bytes of XDATA    memory

Errors: none
Warnings: none
