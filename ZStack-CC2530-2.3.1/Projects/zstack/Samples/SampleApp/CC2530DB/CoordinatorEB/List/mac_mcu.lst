###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               12/Sep/2018  03:56:53
# Copyright 2004-2018 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation version 10.20
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Components\mac\low_level\srf04\single_chip\mac_mcu.c
#    Command line       =  
#        -f C:\Users\ANANDA~1\AppData\Local\Temp\EW5390.tmp ("C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Components\mac\low_level\srf04\single_chip\mac_mcu.c"
#        -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
#        LCD_SUPPORTED=DEBUG -lC "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\CoordinatorEB\List"
#        -lA "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\CoordinatorEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\SOURCE\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARGET\CC2530EB\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\MCU\CCSOC\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\OSAL\INCLUDE\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SEC\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SAPI\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\SYS\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\ZDO\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\F8W\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\ZMAC\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SADDR\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\SERVICES\SDATA\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH_LEVEL\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\"
#        -I "C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\"
#        -Ohz --require_prototypes)
#    Locale             =  English_USA.1252
#    List file          =  
#        C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\CoordinatorEB\List\mac_mcu.lst
#    Object file        =  
#        C:\Users\Ananda
#        Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Projects\zstack\Samples\SampleApp\CC2530DB\CoordinatorEB\Obj\mac_mcu.r51
#
###############################################################################

C:\Users\Ananda Utama\Documents\RMIT2018\WSN\ZStack-CC2530-2.3.1\Components\mac\low_level\srf04\single_chip\mac_mcu.c
      1          /**************************************************************************************************
      2            Filename:       mac_mcu.c
      3            Revised:        $Date: 2010-07-22 09:47:19 -0700 (Thu, 22 Jul 2010) $
      4            Revision:       $Revision: 23100 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_defs.h"
     47          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x91
   \   unsigned char volatile __sfr RFIRQF1
   \                     RFIRQF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x94
   \   unsigned char volatile __sfr T2CTRL
   \                     T2CTRL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9b
   \   unsigned char volatile __sfr S1CON
   \                     S1CON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa1
   \   unsigned char volatile __sfr T2IRQF
   \                     T2IRQF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa2
   \   unsigned char volatile __sfr T2M0
   \                     T2M0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa3
   \   unsigned char volatile __sfr T2M1
   \                     T2M1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa4
   \   unsigned char volatile __sfr T2MOVF0
   \                     T2MOVF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa5
   \   unsigned char volatile __sfr T2MOVF1
   \                     T2MOVF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa6
   \   unsigned char volatile __sfr T2MOVF2
   \                     T2MOVF2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa7
   \   unsigned char volatile __sfr T2IRQM
   \                     T2IRQM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa9
   \   unsigned char volatile __sfr IP0
   \                     IP0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb9
   \   unsigned char volatile __sfr IP1
   \                     IP1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbc
   \   unsigned char volatile __sfr RNDL
   \                     RNDL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbd
   \   unsigned char volatile __sfr RNDH
   \                     RNDH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbf
   \   unsigned char volatile __sfr RFERRF
   \                     RFERRF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc3
   \   unsigned char volatile __sfr T2MSEL
   \                     T2MSEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe9
   \   unsigned char volatile __sfr RFIRQF0
   \                     RFIRQF0:
   \   000000                DS 1
     48          
     49          /* low-level specific */
     50          #include "mac_rx.h"
     51          #include "mac_tx.h"
     52          #include "mac_backoff_timer.h"
     53          #include "mac_csp_tx.h"
     54          #include "mac_rx_onoff.h"
     55          #include "mac_low_level.h"
     56          
     57          /* target specific */
     58          #include "mac_mcu.h"
     59          #include "mac_radio_defs.h"
     60          
     61          /* debug */
     62          #include "mac_assert.h"
     63          
     64          
     65          /* ------------------------------------------------------------------------------------------------
     66           *                                           Defines
     67           * ------------------------------------------------------------------------------------------------
     68           */
     69          
     70          #if !defined (OSC32K_CRYSTAL_INSTALLED) || (defined (OSC32K_CRYSTAL_INSTALLED) && (OSC32K_CRYSTAL_INSTALLED == TRUE))
     71          #define T2CNF_BASE_VALUE    (RUN | SYNC)
     72          #else
     73          #define T2CNF_BASE_VALUE     RUN
     74          #endif
     75          
     76          /* for optimized indexing of uint32's */
     77          #if HAL_MCU_LITTLE_ENDIAN()
     78          #define UINT32_NDX0   0
     79          #define UINT32_NDX1   1
     80          #define UINT32_NDX2   2
     81          #define UINT32_NDX3   3
     82          #else
     83          #define UINT32_NDX0   3
     84          #define UINT32_NDX1   2
     85          #define UINT32_NDX2   1
     86          #define UINT32_NDX3   0
     87          #endif
     88          
     89          /* ------------------------------------------------------------------------------------------------
     90           *                                        Local Variables
     91           * ------------------------------------------------------------------------------------------------
     92           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     93          uint8       macChipVersion = 0;
   \                     macChipVersion:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     94          static int8 maxRssi;
   \                     maxRssi:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     95          
     96          
     97          /*
     98           *  This number is used to calculate the precision count for OSAL timer update. In Beacon mode,
     99           *  the overflow count may be initialized to zero or to a constant. The "skip" in overflow count
    100           *  needs to be accounted for in this variable.
    101           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    102          static uint32 accumulatedOverflowCount = 0;
   \                     accumulatedOverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    103          
    104          /* Function pointer for the random seed callback */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    105          static macRNGFcn_t pRandomSeedCB = NULL;
   \                     pRandomSeedCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    106          /* ------------------------------------------------------------------------------------------------
    107           *                                       Local Prototypes
    108           * ------------------------------------------------------------------------------------------------
    109           */
    110          static void mcuRecordMaxRssiIsr(void);
    111          static uint32 macMcuOverflowGetCompare(void);
    112          
    113          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn);
    114          
    115          /**************************************************************************************************
    116           * @fn          MAC_SetRandomSeedCB
    117           *
    118           * @brief       Set the function pointer for the random seed callback.
    119           *
    120           * @param       pCBFcn - function pointer of the random seed callback
    121           *
    122           * @return      none
    123           **************************************************************************************************
    124           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    125          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn)
   \                     MAC_SetRandomSeedCB:
    126          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    127            pRandomSeedCB = pCBFcn;
   \   000004   90....       MOV       DPTR,#pRandomSeedCB
   \   000007   EA           MOV       A,R2
   \   000008   F0           MOVX      @DPTR,A
   \   000009   A3           INC       DPTR
   \   00000A   EB           MOV       A,R3
   \   00000B   F0           MOVX      @DPTR,A
    128          }
   \   00000C   80..         SJMP      ??Subroutine7_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine7_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    129          
    130          /**************************************************************************************************
    131           * @fn          macMcuInit
    132           *
    133           * @brief       Initialize the MCU.
    134           *
    135           * @param       none
    136           *
    137           * @return      none
    138           **************************************************************************************************
    139           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine6_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine7_0
   \   000003                ; // Fall through to label ??Subroutine7_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    140          MAC_INTERNAL_API void macMcuInit(void)
   \                     macMcuInit:
    141          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 16
   \   000004   74F0         MOV       A,#-0x10
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    142            halIntState_t  s;
    143          
    144            /* This CORR_THR value should be changed to 0x14 before attempting RX. Testing has shown that
    145             * too many false frames are received if the reset value is used. Make it more likely to detect
    146             * sync by removing the requirement that both symbols in the SFD must have a correlation value
    147             * above the correlation threshold, and make sync word detection less likely by raising the
    148             * correlation threshold.
    149             */
    150            MDMCTRL1 = CORR_THR;
   \   000009   9061A9       MOV       DPTR,#0x61a9
   \   00000C   7414         MOV       A,#0x14
   \   00000E   F0           MOVX      @DPTR,A
    151          
    152            /* tuning adjustments for optimal radio performance; details available in datasheet */
    153            RXCTRL = 0x3F;
   \   00000F   9061AB       MOV       DPTR,#0x61ab
   \   000012   743F         MOV       A,#0x3f
   \   000014   F0           MOVX      @DPTR,A
    154          
    155            /* Raises the CCA threshold from about -108dBm to about -80 dBm input level.
    156             */
    157            CCACTRL0 = CCA_THR;
   \   000015   906196       MOV       DPTR,#0x6196
   \   000018   74F8         MOV       A,#-0x8
   \   00001A   F0           MOVX      @DPTR,A
    158          
    159            /* Makes sync word detection less likely by requiring two zero symbols before the sync word.
    160             * details available in datasheet.
    161             */
    162            MDMCTRL0 = 0x85;
   \   00001B   9061A8       MOV       DPTR,#0x61a8
   \   00001E   7485         MOV       A,#-0x7b
   \   000020   F0           MOVX      @DPTR,A
    163          
    164            /* Adjust current in synthesizer; details available in datasheet. */
    165            FSCTRL = 0x5A;
   \   000021   9061AC       MOV       DPTR,#0x61ac
   \   000024   745A         MOV       A,#0x5a
   \   000026   F0           MOVX      @DPTR,A
    166          
    167            /* Adjust current in VCO; details available in datasheet. */
    168            FSCAL1 = 0x00;
   \   000027   9061AE       MOV       DPTR,#0x61ae
   \   00002A   E4           CLR       A
   \   00002B   F0           MOVX      @DPTR,A
    169          
    170            /* Adjust target value for AGC control loop; details available in datasheet. */
    171            AGCCTRL1 = 0x15;
   \   00002C   9061B2       MOV       DPTR,#0x61b2
   \   00002F   7415         MOV       A,#0x15
   \   000031   F0           MOVX      @DPTR,A
    172          
    173            /* Disable source address matching an autopend for now */
    174            SRCMATCH = 0;
   \   000032   906182       MOV       DPTR,#0x6182
   \   000035   E4           CLR       A
   \   000036   F0           MOVX      @DPTR,A
    175          
    176            /* Tune ADC performance, details available in datasheet. */
    177            ADCTEST0 = 0x10;
   \   000037   9061B5       MOV       DPTR,#0x61b5
   \   00003A   7410         MOV       A,#0x10
   \   00003C   F0           MOVX      @DPTR,A
    178            ADCTEST1 = 0x0E;
   \   00003D   A3           INC       DPTR
   \   00003E   740E         MOV       A,#0xe
   \   000040   F0           MOVX      @DPTR,A
    179            ADCTEST2 = 0x03;
   \   000041   A3           INC       DPTR
   \   000042   7403         MOV       A,#0x3
   \   000044   F0           MOVX      @DPTR,A
    180          
    181            /* Sets TX anti-aliasing filter to appropriate bandwidth.
    182             * Reduces spurious emissions close to signal.
    183             */
    184            TXFILTCFG = TXFILTCFG_RESET_VALUE;
   \   000045   9061FA       MOV       DPTR,#0x61fa
   \   000048   7409         MOV       A,#0x9
   \   00004A   F0           MOVX      @DPTR,A
    185          
    186            /* disable the CSPT register compare function */
    187            CSPT = 0xFF;
   \   00004B   9061E5       MOV       DPTR,#0x61e5
   \   00004E   74FF         MOV       A,#-0x1
   \   000050   F0           MOVX      @DPTR,A
    188          
    189            /* enable general RF interrupts */
    190            IEN2 |= RFIE;
   \   000051   439A01       ORL       0x9a,#0x1
    191          
    192            /* enable general REERR interrupts */
    193            IEN0 |= RFERRIE;
   \   000054   D2A8         SETB      0xa8.0
    194          
    195            /* set RF interrupts one notch above lowest priority (four levels available) */
    196            IP0 |=  IP_RFERR_RF_DMA_BV;
   \   000056   43A901       ORL       0xa9,#0x1
    197            IP1 &= ~IP_RFERR_RF_DMA_BV;
   \   000059   53B9FE       ANL       0xb9,#0xfe
    198          
    199            /* set T2 interrupts one notch above lowest priority (four levels available)
    200             * This effectively turned off nested interrupt between T2 and RF.
    201             */
    202            IP0 |=  IP_RXTX0_T2_BV;
   \   00005C   43A904       ORL       0xa9,#0x4
    203            IP1 &= ~IP_RXTX0_T2_BV;
   \   00005F   53B9FB       ANL       0xb9,#0xfb
    204          
    205            /* read chip version */
    206            macChipVersion = CHVER;
   \   000062   906249       MOV       DPTR,#0x6249
   \   000065   E0           MOVX      A,@DPTR
   \   000066   90....       MOV       DPTR,#macChipVersion
   \   000069   F0           MOVX      @DPTR,A
    207          
    208            /*-------------------------------------------------------------------------------
    209             *  Initialize MAC timer.
    210             */
    211          
    212            /* set timer rollover */
    213            HAL_ENTER_CRITICAL_SECTION(s);
   \   00006A   A8A8         MOV       R0,0xa8+0x0
   \   00006C   C2AF         CLR       0xa8.7
    214            MAC_MCU_T2_ACCESS_PERIOD_VALUE();
   \   00006E   75C302       MOV       0xc3,#0x2
    215            T2M0 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() & 0xFF;
   \   000071   75A200       MOV       0xa2,#0x0
    216            T2M1 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() >> 8;
   \   000074   75A328       MOV       0xa3,#0x28
    217            HAL_EXIT_CRITICAL_SECTION(s);
   \   000077   E8           MOV       A,R0
   \   000078   A2E7         MOV       C,0xE0 /* A   */.7
   \   00007A   92AF         MOV       0xa8.7,C
    218          
    219            /* start timer */
    220            MAC_RADIO_TIMER_WAKE_UP();
   \                     ??macMcuInit_0:
   \   00007C   E59E         MOV       A,0x9e
   \   00007E   70FC         JNZ       ??macMcuInit_0
   \   000080   439401       ORL       0x94,#0x1
   \                     ??macMcuInit_1:
   \   000083   E594         MOV       A,0x94
   \   000085   A2E2         MOV       C,0xE0 /* A   */.2
   \   000087   50FA         JNC       ??macMcuInit_1
    221          
    222            /* Enable latch mode */
    223            T2CTRL |= LATCH_MODE;
   \   000089   439408       ORL       0x94,#0x8
    224          
    225            /* enable timer interrupts */
    226            T2IE = 1;
   \   00008C   D2BA         SETB      0xb8.2
    227          
    228           /*----------------------------------------------------------------------------------------------
    229            *  Initialize random seed value.
    230            */
    231          
    232            /*
    233             *  Set radio for infinite reception.  Once radio reaches this state,
    234             *  it will stay in receive mode regardless RF activity.
    235             */
    236            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_INFINITE_RECEPTION;
   \   00008E   906189       MOV       DPTR,#0x6189
   \   000091   7448         MOV       A,#0x48
   \   000093   F0           MOVX      @DPTR,A
    237          
    238            /* turn on the receiver */
    239            macRxOn();
   \   000094                ; Setup parameters for call to function macRxOn
   \   000094   12....       LCALL     `??macRxOn::?relay`; Banked call to: macRxOn
    240          
    241            /*
    242             *  Wait for radio to reach infinite reception state by checking RSSI valid flag.
    243             *  Once it does, the least significant bit of ADTSTH should be pretty random.
    244             */
    245            while (!(RSSISTAT & 0x01));
   \                     ??macMcuInit_2:
   \   000097   906199       MOV       DPTR,#0x6199
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   A2E0         MOV       C,0xE0 /* A   */.0
   \   00009D   50F8         JNC       ??macMcuInit_2
    246          
    247            /* put 16 random bits into the seed value */
    248            {
    249              uint16 rndSeed;
    250              uint8  i;
    251          
    252              rndSeed = 0;
   \   00009F   7800         MOV       R0,#0x0
   \   0000A1   7900         MOV       R1,#0x0
    253          
    254              for(i=0; i<16; i++)
   \   0000A3   7A10         MOV       R2,#0x10
    255              {
    256                /* use most random bit of analog to digital receive conversion to populate the random seed */
    257                rndSeed = (rndSeed << 1) | (RFRND & 0x01);
   \                     ??macMcuInit_3:
   \   0000A5   E8           MOV       A,R0
   \   0000A6   25E0         ADD       A,0xE0 /* A   */
   \   0000A8   F8           MOV       R0,A
   \   0000A9   E9           MOV       A,R1
   \   0000AA   33           RLC       A
   \   0000AB   F9           MOV       R1,A
   \   0000AC   9061A7       MOV       DPTR,#0x61a7
   \   0000AF   E0           MOVX      A,@DPTR
   \   0000B0   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000B2   E4           CLR       A
   \   0000B3   33           RLC       A
   \   0000B4   FC           MOV       R4,A
   \   0000B5   E8           MOV       A,R0
   \   0000B6   4C           ORL       A,R4
   \   0000B7   F8           MOV       R0,A
    258              }
   \   0000B8   DAEB         DJNZ      R2,??macMcuInit_3
    259          
    260              /*
    261               *  The seed value must not be zero or 0x0380 (0x8003 in the polynomial).  If it is, the psuedo
    262               *  random sequence won’t be random.  There is an extremely small chance this seed could randomly
    263               *  be zero or 0x0380.  The following check makes sure this does not happen.
    264               */
    265              if (rndSeed == 0x0000 || rndSeed == 0x0380)
   \   0000BA   E8           MOV       A,R0
   \   0000BB   49           ORL       A,R1
   \   0000BC   600A         JZ        ??macMcuInit_4
   \   0000BE   7480         MOV       A,#-0x80
   \   0000C0   68           XRL       A,R0
   \   0000C1   7003         JNZ       ??macMcuInit_5
   \   0000C3   7403         MOV       A,#0x3
   \   0000C5   69           XRL       A,R1
   \                     ??macMcuInit_5:
   \   0000C6   7004         JNZ       ??macMcuInit_6
    266              {
    267                rndSeed = 0xBABE; /* completely arbitrary "random" value */
   \                     ??macMcuInit_4:
   \   0000C8   78BE         MOV       R0,#-0x42
   \   0000CA   79BA         MOV       R1,#-0x46
    268              }
    269          
    270              /*
    271               *  Two writes to RNDL will set the random seed.  A write to RNDL copies current contents
    272               *  of RNDL to RNDH before writing new the value to RNDL.
    273               */
    274              RNDL = rndSeed & 0xFF;
   \                     ??macMcuInit_6:
   \   0000CC   E8           MOV       A,R0
   \   0000CD   F5BC         MOV       0xbc,A
    275              RNDL = rndSeed >> 8;
   \   0000CF   E9           MOV       A,R1
   \   0000D0   F5BC         MOV       0xbc,A
    276            }
    277          
    278            /* Read 16*8 random bits and store them in flash for future use in random
    279               key generation for CBKE key establishment */
    280            if( pRandomSeedCB )
   \   0000D2   90....       MOV       DPTR,#pRandomSeedCB
   \   0000D5   E0           MOVX      A,@DPTR
   \   0000D6   F8           MOV       R0,A
   \   0000D7   A3           INC       DPTR
   \   0000D8   E0           MOVX      A,@DPTR
   \   0000D9   F9           MOV       R1,A
   \   0000DA   E8           MOV       A,R0
   \   0000DB   49           ORL       A,R1
   \   0000DC   6042         JZ        ??macMcuInit_7
    281            {
    282              uint8 randomSeed[MAC_RANDOM_SEED_LEN];
    283              uint8 i,j;
    284          
    285              for(i = 0; i < 16; i++)
   \   0000DE   7900         MOV       R1,#0x0
    286              {
    287                uint8 rndByte = 0;
   \                     ??macMcuInit_8:
   \   0000E0   7800         MOV       R0,#0x0
    288                for(j = 0; j < 8; j++)
   \   0000E2   7A08         MOV       R2,#0x8
    289                {
    290                  /* use most random bit of analog to digital receive conversion to
    291                     populate the random seed */
    292                  rndByte = (rndByte << 1) | (RFRND & 0x01);
   \                     ??macMcuInit_9:
   \   0000E4   9061A7       MOV       DPTR,#0x61a7
   \   0000E7   E0           MOVX      A,@DPTR
   \   0000E8   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000EA   E4           CLR       A
   \   0000EB   33           RLC       A
   \   0000EC   FB           MOV       R3,A
   \   0000ED   E8           MOV       A,R0
   \   0000EE   33           RLC       A
   \   0000EF   4B           ORL       A,R3
   \   0000F0   F8           MOV       R0,A
    293                }
   \   0000F1   DAF1         DJNZ      R2,??macMcuInit_9
    294                randomSeed[i] = rndByte;
   \   0000F3   E9           MOV       A,R1
   \   0000F4   FA           MOV       R2,A
   \   0000F5   85..82       MOV       DPL,?XSP + 0
   \   0000F8   85..83       MOV       DPH,?XSP + 1
   \   0000FB   E582         MOV       A,DPL
   \   0000FD   2A           ADD       A,R2
   \   0000FE   F582         MOV       DPL,A
   \   000100   E4           CLR       A
   \   000101   3583         ADDC      A,DPH
   \   000103   F583         MOV       DPH,A
   \   000105   E8           MOV       A,R0
   \   000106   F0           MOVX      @DPTR,A
    295          
    296              }
   \   000107   09           INC       R1
   \   000108   E9           MOV       A,R1
   \   000109   C3           CLR       C
   \   00010A   9410         SUBB      A,#0x10
   \   00010C   40D2         JC        ??macMcuInit_8
    297              pRandomSeedCB( randomSeed );
   \   00010E                ; Setup parameters for indirect call
   \   00010E   AA..         MOV       R2,?XSP + 0
   \   000110   AB..         MOV       R3,?XSP + 1
   \   000112   90....       MOV       DPTR,#pRandomSeedCB
   \   000115   E0           MOVX      A,@DPTR
   \   000116   F8           MOV       R0,A
   \   000117   A3           INC       DPTR
   \   000118   E0           MOVX      A,@DPTR
   \   000119   F583         MOV       DPH,A
   \   00011B   8882         MOV       DPL,R0
   \   00011D   12....       LCALL     ?CALL_IND
    298            }
    299          
    300            /* turn off the receiver */
    301            macRxOff();
   \                     ??macMcuInit_7:
   \   000120                ; Setup parameters for call to function macRxOff
   \   000120   12....       LCALL     `??macRxOff::?relay`; Banked call to: macRxOff
    302          
    303            /* take receiver out of infinite reception mode; set back to normal operation */
    304            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_NORMAL_OPERATION;
   \   000123   906189       MOV       DPTR,#0x6189
   \   000126   7440         MOV       A,#0x40
   \   000128   F0           MOVX      @DPTR,A
    305          
    306            /* Turn on autoack */
    307            MAC_RADIO_TURN_ON_AUTO_ACK();
   \   000129   E0           MOVX      A,@DPTR
   \   00012A   D2E5         SETB      0xE0 /* A   */.5
   \   00012C   F0           MOVX      @DPTR,A
    308          
    309            /* Initialize SRCEXTPENDEN and SRCSHORTPENDEN to zeros */
    310            MAC_RADIO_SRC_MATCH_INIT_EXTPENDEN();
   \   00012D   906164       MOV       DPTR,#0x6164
   \   000130   E4           CLR       A
   \   000131   F0           MOVX      @DPTR,A
   \   000132   A3           INC       DPTR
   \   000133   F0           MOVX      @DPTR,A
   \   000134   A3           INC       DPTR
   \   000135   F0           MOVX      @DPTR,A
    311            MAC_RADIO_SRC_MATCH_INIT_SHORTPENDEN();
   \   000136   A3           INC       DPTR
   \   000137   F0           MOVX      @DPTR,A
   \   000138   A3           INC       DPTR
   \   000139   F0           MOVX      @DPTR,A
   \   00013A   A3           INC       DPTR
   \   00013B   F0           MOVX      @DPTR,A
    312          }
   \   00013C   7410         MOV       A,#0x10
   \   00013E   02....       LJMP      ??Subroutine6_0 & 0xFFFF
   \   000141                REQUIRE IEN2
   \   000141                REQUIRE _A_IEN0
   \   000141                REQUIRE IP0
   \   000141                REQUIRE IP1
   \   000141                REQUIRE T2MSEL
   \   000141                REQUIRE T2M0
   \   000141                REQUIRE T2M1
   \   000141                REQUIRE CLKCONSTA
   \   000141                REQUIRE T2CTRL
   \   000141                REQUIRE _A_IEN1
   \   000141                REQUIRE RNDL
    313          
    314          
    315          /**************************************************************************************************
    316           * @fn          macMcuRandomByte
    317           *
    318           * @brief       Returns a random byte using a special hardware feature that generates new
    319           *              random values based on the truly random seed set earlier.
    320           *
    321           * @param       none
    322           *
    323           * @return      a random byte
    324           **************************************************************************************************
    325           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    326          MAC_INTERNAL_API uint8 macMcuRandomByte(void)
   \                     macMcuRandomByte:
    327          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    328            /* clock the random generator to get a new random value */
    329            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   E5B4         MOV       A,0xb4
   \   000002   54F3         ANL       A,#0xf3
   \   000004   4404         ORL       A,#0x4
   \   000006   F5B4         MOV       0xb4,A
    330          
    331            /* return new randomized value from hardware */
    332            return(RNDH);
   \   000008   E5BD         MOV       A,0xbd
   \   00000A   F9           MOV       R1,A
   \   00000B   02....       LJMP      ?BRET
   \   00000E                REQUIRE ADCCON1
   \   00000E                REQUIRE RNDH
    333          }
    334          
    335          
    336          /**************************************************************************************************
    337           * @fn          macMcuRandomWord
    338           *
    339           * @brief       Returns a random word using a special hardware feature that generates new
    340           *              random values based on the truly random seed set earlier.
    341           *
    342           * @param       none
    343           *
    344           * @return      a random word
    345           **************************************************************************************************
    346           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    347          MAC_INTERNAL_API uint16 macMcuRandomWord(void)
   \                     macMcuRandomWord:
    348          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    349            uint16 random_word;
    350          
    351            /* clock the random generator to get a new random value */
    352            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   E5B4         MOV       A,0xb4
   \   000002   54F3         ANL       A,#0xf3
   \   000004   4404         ORL       A,#0x4
   \   000006   F5B4         MOV       0xb4,A
    353          
    354            /* read random word */
    355            random_word  = (RNDH << 8);
   \   000008   E5BD         MOV       A,0xbd+0x0
    356            random_word +=  RNDL;
    357          
    358            /* return new randomized value from hardware */
    359            return(random_word);
   \   00000A   F9           MOV       R1,A
   \   00000B   E5BC         MOV       A,0xbc
   \   00000D   FA           MOV       R2,A
   \   00000E   E9           MOV       A,R1
   \   00000F   FB           MOV       R3,A
   \   000010   02....       LJMP      ?BRET
   \   000013                REQUIRE ADCCON1
   \   000013                REQUIRE RNDH
   \   000013                REQUIRE RNDL
    360          }
    361          
    362          
    363          /**************************************************************************************************
    364           * @fn          macMcuTimerForceDelay
    365           *
    366           * @brief       Delay the timer by the requested number of ticks.
    367           *
    368           * @param       none
    369           *
    370           * @return      none
    371           **************************************************************************************************
    372           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    373          MAC_INTERNAL_API void macMcuTimerForceDelay(uint16 x)
   \                     macMcuTimerForceDelay:
    374          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    375            halIntState_t  s;
    376          
    377            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   A8A8         MOV       R0,0xa8+0x0
   \   000002   C2AF         CLR       0xa8.7
    378            MAC_MCU_T2_ACCESS_COUNT_VALUE();
   \   000004   75C300       MOV       0xc3,#0x0
    379            T2M0 = (x) & 0xFF;
   \   000007   EA           MOV       A,R2
   \   000008   F5A2         MOV       0xa2,A
    380            T2M1 = (x) >> 8;
   \   00000A   EB           MOV       A,R3
   \   00000B   F5A3         MOV       0xa3,A
    381            HAL_EXIT_CRITICAL_SECTION(s);
   \   00000D   E8           MOV       A,R0
   \   00000E   A2E7         MOV       C,0xE0 /* A   */.7
   \   000010   92AF         MOV       0xa8.7,C
    382          }
   \   000012   02....       LJMP      ?BRET
   \   000015                REQUIRE _A_IEN0
   \   000015                REQUIRE T2MSEL
   \   000015                REQUIRE T2M0
   \   000015                REQUIRE T2M1
    383          
    384          /**************************************************************************************************
    385           * @fn          macMcuTimerCapture
    386           *
    387           * @brief       Returns the last timer capture.  This capture should have occurred at the
    388           *              receive time of the last frame (the last time SFD transitioned to active).
    389           *
    390           * @param       none
    391           *
    392           * @return      last capture of hardware timer (full 16-bit value)
    393           **************************************************************************************************
    394           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    395          MAC_INTERNAL_API uint16 macMcuTimerCapture(void)
   \                     macMcuTimerCapture:
    396          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    397            uint16         timerCapture;
    398            halIntState_t  s;
    399          
    400            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   A9A8         MOV       R1,0xa8+0x0
   \   000002   C2AF         CLR       0xa8.7
    401            MAC_MCU_T2_ACCESS_CAPTURE_VALUE();
   \   000004   75C301       MOV       0xc3,#0x1
    402            timerCapture = T2M1 << 8;
   \   000007   A8A3         MOV       R0,0xa3+0x0
    403            timerCapture |= T2M0;
   \   000009   AAA2         MOV       R2,0xa2+0x0
    404            HAL_EXIT_CRITICAL_SECTION(s);
   \   00000B   E9           MOV       A,R1
   \   00000C   A2E7         MOV       C,0xE0 /* A   */.7
   \   00000E   92AF         MOV       0xa8.7,C
    405          
    406            return (timerCapture);
   \   000010   E8           MOV       A,R0
   \   000011   FB           MOV       R3,A
   \   000012   02....       LJMP      ?BRET
   \   000015                REQUIRE _A_IEN0
   \   000015                REQUIRE T2MSEL
   \   000015                REQUIRE T2M1
   \   000015                REQUIRE T2M0
    407          }
    408          
    409          
    410          /**************************************************************************************************
    411           * @fn          macMcuOverflowCount
    412           *
    413           * @brief       Returns the value of the overflow counter which is a special hardware feature.
    414           *              The overflow count actually is 24 bits of information.
    415           *
    416           * @param       none
    417           *
    418           * @return      value of overflow counter
    419           **************************************************************************************************
    420           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E5A4         MOV       A,0xa4
   \   000002   85..82       MOV       DPL,?XSP + 0
   \   000005   85..83       MOV       DPH,?XSP + 1
   \   000008   F0           MOVX      @DPTR,A
   \   000009   E5A5         MOV       A,0xa5
   \   00000B   C0E0         PUSH      A
   \   00000D   7401         MOV       A,#0x1
   \   00000F   12....       LCALL     ?XSTACK_DISP0_8
   \   000012   D0E0         POP       A
   \   000014   F0           MOVX      @DPTR,A
   \   000015   E5A6         MOV       A,0xa6
   \   000017   C0E0         PUSH      A
   \   000019   7402         MOV       A,#0x2
   \   00001B   12....       LCALL     ?XSTACK_DISP0_8
   \   00001E   D0E0         POP       A
   \   000020   F0           MOVX      @DPTR,A
   \   000021   7403         MOV       A,#0x3
   \   000023   12....       LCALL     ?XSTACK_DISP0_8
   \   000026   E4           CLR       A
   \   000027   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00002A   12....       LCALL     ?XLOAD_R2345
   \   00002D   7404         MOV       A,#0x4
   \   00002F                REQUIRE ??Subroutine6_0
   \   00002F                ; // Fall through to label ??Subroutine6_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    421          MAC_INTERNAL_API uint32 macMcuOverflowCount(void)
   \                     macMcuOverflowCount:
    422          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV       A,#-0x4
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    423            uint32         overflowCount;
    424            halIntState_t  s;
    425          
    426            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    427          
    428            HAL_ENTER_CRITICAL_SECTION(s);
   \   000009   A8A8         MOV       R0,0xa8+0x0
   \   00000B   C2AF         CLR       0xa8.7
    429          
    430            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    431            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   00000D   75C300       MOV       0xc3,#0x0
    432          
    433            /* Latch the entire T2MOVFx first by reading T2M0. */
    434            T2M0;
   \   000010   E5A2         MOV       A,0xa2
    435            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
   \   000012   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   000015                REQUIRE _A_IEN0
   \   000015                REQUIRE T2MSEL
   \   000015                REQUIRE T2M0
   \   000015                REQUIRE T2MOVF0
   \   000015                REQUIRE T2MOVF1
   \   000015                REQUIRE T2MOVF2
    436            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
    437            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2MOVF2;
    438            ((uint8 *)&overflowCount)[UINT32_NDX3] = 0;
    439            HAL_EXIT_CRITICAL_SECTION(s);
    440          
    441            return (overflowCount);
    442          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   E8           MOV       A,R0
   \   000002   A2E7         MOV       C,0xE0 /* A   */.7
   \   000004   92AF         MOV       0xa8.7,C
   \   000006   85..82       MOV       DPL,?XSP + 0
   \   000009   85..83       MOV       DPH,?XSP + 1
   \   00000C   22           RET
    443          
    444          
    445          /**************************************************************************************************
    446           * @fn          macMcuOverflowCapture
    447           *
    448           * @brief       Returns the last capture of the overflow counter.  A special hardware feature
    449           *              captures the overflow counter when the regular hardware timer is captured.
    450           *
    451           * @param       none
    452           *
    453           * @return      last capture of overflow count
    454           **************************************************************************************************
    455           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    456          MAC_INTERNAL_API uint32 macMcuOverflowCapture(void)
   \                     macMcuOverflowCapture:
    457          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV       A,#-0x4
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    458            uint32         overflowCapture;
    459            halIntState_t  s;
    460          
    461            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    462            HAL_ENTER_CRITICAL_SECTION(s);
   \   000009   A8A8         MOV       R0,0xa8+0x0
   \   00000B   C2AF         CLR       0xa8.7
    463            MAC_MCU_T2_ACCESS_OVF_CAPTURE_VALUE();
   \   00000D   75C310       MOV       0xc3,#0x10
    464            ((uint8 *)&overflowCapture)[UINT32_NDX0] = T2MOVF0;
   \   000010   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   000013                REQUIRE _A_IEN0
   \   000013                REQUIRE T2MSEL
   \   000013                REQUIRE T2MOVF0
   \   000013                REQUIRE T2MOVF1
   \   000013                REQUIRE T2MOVF2
    465            ((uint8 *)&overflowCapture)[UINT32_NDX1] = T2MOVF1;
    466            ((uint8 *)&overflowCapture)[UINT32_NDX2] = T2MOVF2;
    467            ((uint8 *)&overflowCapture)[UINT32_NDX3] = 0;
    468            HAL_EXIT_CRITICAL_SECTION(s);
    469          
    470            return (overflowCapture);
    471          }
    472          
    473          
    474          /**************************************************************************************************
    475           * @fn          macMcuOverflowSetCount
    476           *
    477           * @brief       Sets the value of the hardware overflow counter.
    478           *
    479           * @param       count - new overflow count value
    480           *
    481           * @return      none
    482           **************************************************************************************************
    483           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          MAC_INTERNAL_API void macMcuOverflowSetCount(uint32 count)
   \                     macMcuOverflowSetCount:
    485          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   12....       LCALL     ?Subroutine5 & 0xFFFF
    486            halIntState_t  s;
    487          
    488            MAC_ASSERT(! (count >> 24) );   /* illegal count value */
   \                     ??CrossCallReturnLabel_4:
   \   00000D   85..82       MOV       DPL,?XSP + 0
   \   000010   85..83       MOV       DPH,?XSP + 1
   \   000013   78..         MOV       R0,#?V0
   \   000015   12....       LCALL     ?L_MOV_X
   \   000018   90....       MOV       DPTR,#__Constant_ff000000
   \   00001B   78..         MOV       R0,#?V0
   \   00001D   12....       LCALL     ?L_AND_X
   \   000020   E5..         MOV       A,?V0
   \   000022   45..         ORL       A,?V1
   \   000024   45..         ORL       A,?V2
   \   000026   45..         ORL       A,?V3
   \   000028   6003         JZ        ??macMcuOverflowSetCount_0
   \   00002A                ; Setup parameters for call to function halAssertHandler
   \   00002A   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    489          
    490            /* save the current overflow count */
    491            accumulatedOverflowCount += macMcuOverflowCount();
    492          
    493            /* deduct the initial count */
    494            accumulatedOverflowCount -= count;
   \                     ??macMcuOverflowSetCount_0:
   \   00002D   90....       MOV       DPTR,#accumulatedOverflowCount
   \   000030   C082         PUSH      DPL
   \   000032   C083         PUSH      DPH
   \   000034                ; Setup parameters for call to function macMcuOverflowCount
   \   000034   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000037   D083         POP       DPH
   \   000039   D082         POP       DPL
   \   00003B   78..         MOV       R0,#?V0
   \   00003D   12....       LCALL     ?L_ADD_X
   \   000040   85..82       MOV       DPL,?XSP + 0
   \   000043   85..83       MOV       DPH,?XSP + 1
   \   000046   78..         MOV       R0,#?V0
   \   000048   12....       LCALL     ?L_SUB_X
   \   00004B   90....       MOV       DPTR,#accumulatedOverflowCount
   \   00004E   78..         MOV       R0,#?V0
   \   000050   12....       LCALL     ?L_MOV_TO_X
    495          
    496            HAL_ENTER_CRITICAL_SECTION(s);
   \   000053   A8A8         MOV       R0,0xa8+0x0
   \   000055   C2AF         CLR       0xa8.7
    497            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   000057   75C300       MOV       0xc3,#0x0
    498          
    499            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    500            /* T2OF2 must be written last */
    501            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   00005A   85..82       MOV       DPL,?XSP + 0
   \   00005D   85..83       MOV       DPH,?XSP + 1
   \   000060   E0           MOVX      A,@DPTR
   \   000061   F5A4         MOV       0xa4,A
    502            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   000063   7401         MOV       A,#0x1
   \   000065   12....       LCALL     ?XSTACK_DISP0_8
   \   000068   E0           MOVX      A,@DPTR
   \   000069   F5A5         MOV       0xa5,A
    503            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   00006B   7402         MOV       A,#0x2
   \   00006D   12....       LCALL     ?XSTACK_DISP0_8
   \   000070   E0           MOVX      A,@DPTR
   \   000071   F5A6         MOV       0xa6,A
    504            HAL_EXIT_CRITICAL_SECTION(s);
   \   000073   E8           MOV       A,R0
   \   000074   A2E7         MOV       C,0xE0 /* A   */.7
   \   000076   02....       LJMP      ?Subroutine1 & 0xFFFF
   \   000079                REQUIRE _A_IEN0
   \   000079                REQUIRE T2MSEL
   \   000079                REQUIRE T2MOVF0
   \   000079                REQUIRE T2MOVF1
   \   000079                REQUIRE T2MOVF2
    505          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   EA           MOV       A,R2
   \   000007   F0           MOVX      @DPTR,A
   \   000008   A3           INC       DPTR
   \   000009   EB           MOV       A,R3
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   A3           INC       DPTR
   \   00000C   EC           MOV       A,R4
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   A3           INC       DPTR
   \   00000F   ED           MOV       A,R5
   \   000010   F0           MOVX      @DPTR,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL     `??macMcuOverflowCount::?relay`; Banked call to: macMcuOverflowCount
   \   000003   8A..         MOV       ?V0,R2
   \   000005   8B..         MOV       ?V1,R3
   \   000007   8C..         MOV       ?V2,R4
   \   000009   8D..         MOV       ?V3,R5
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   92AF         MOV       0xa8.7,C
   \   000002                REQUIRE ??Subroutine8_0
   \   000002                ; // Fall through to label ??Subroutine8_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine8_0:
   \   000000   7404         MOV       A,#0x4
   \   000002                REQUIRE ??Subroutine9_0
   \   000002                ; // Fall through to label ??Subroutine9_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine9_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F04         MOV       R7,#0x4
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA
    506          
    507          
    508          /**************************************************************************************************
    509           * @fn          macMcuOverflowSetCompare
    510           *
    511           * @brief       Set overflow count compare value.  An interrupt is triggered when the overflow
    512           *              count equals this compare value.
    513           *
    514           * @param       count - overflow count compare value
    515           *
    516           * @return      none
    517           **************************************************************************************************
    518           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    519          MAC_INTERNAL_API void macMcuOverflowSetCompare(uint32 count)
   \                     macMcuOverflowSetCompare:
    520          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   12....       LCALL     ?Subroutine5 & 0xFFFF
    521            halIntState_t  s;
    522            uint8 enableCompareInt = 0;
   \                     ??CrossCallReturnLabel_5:
   \   00000D   C2..         CLR       ?VB.0
    523          
    524            MAC_ASSERT( !(count >> 24) );   /* illegal count value */
   \   00000F   85..82       MOV       DPL,?XSP + 0
   \   000012   85..83       MOV       DPH,?XSP + 1
   \   000015   78..         MOV       R0,#?V0
   \   000017   12....       LCALL     ?L_MOV_X
   \   00001A   90....       MOV       DPTR,#__Constant_ff000000
   \   00001D   78..         MOV       R0,#?V0
   \   00001F   12....       LCALL     ?L_AND_X
   \   000022   E5..         MOV       A,?V0
   \   000024   45..         ORL       A,?V1
   \   000026   45..         ORL       A,?V2
   \   000028   45..         ORL       A,?V3
   \   00002A   6003         JZ        ??macMcuOverflowSetCompare_0
   \   00002C                ; Setup parameters for call to function halAssertHandler
   \   00002C   12....       LCALL     `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    525          
    526            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_0:
   \   00002F   A2AF         MOV       C,0xa8.7
   \   000031   E4           CLR       A
   \   000032   33           RLC       A
   \   000033   F8           MOV       R0,A
   \   000034   C2AF         CLR       0xa8.7
    527          
    528            /*  Disable overflow compare interrupts. */
    529            if (T2IRQM & TIMER2_OVF_COMPARE1M)
   \   000036   E5A7         MOV       A,0xa7
   \   000038   A2E4         MOV       C,0xE0 /* A   */.4
   \   00003A   5005         JNC       ??macMcuOverflowSetCompare_1
    530            {
    531              enableCompareInt = 1;
   \   00003C   D2..         SETB      ?VB.0
    532              T2IRQM &= ~TIMER2_OVF_COMPARE1M;
   \   00003E   53A7EF       ANL       0xa7,#0xef
    533            }
    534          
    535            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
   \                     ??macMcuOverflowSetCompare_1:
   \   000041   75C330       MOV       0xc3,#0x30
    536          
    537            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    538            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   000044   85..82       MOV       DPL,?XSP + 0
   \   000047   85..83       MOV       DPH,?XSP + 1
   \   00004A   E0           MOVX      A,@DPTR
   \   00004B   F5A4         MOV       0xa4,A
    539            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   00004D   7401         MOV       A,#0x1
   \   00004F   12....       LCALL     ?XSTACK_DISP0_8
   \   000052   E0           MOVX      A,@DPTR
   \   000053   F5A5         MOV       0xa5,A
    540            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   000055   7402         MOV       A,#0x2
   \   000057   12....       LCALL     ?XSTACK_DISP0_8
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   F5A6         MOV       0xa6,A
    541          
    542            /*
    543             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    544             *  in case a false match was generated as the multi-byte compare value was written.
    545             */
    546            T2IRQF = ~TIMER2_OVF_COMPARE1F;
   \   00005D   75A1EF       MOV       0xa1,#-0x11
    547          
    548            /* re-enable overflow compare interrupts if they were previously enabled */
    549            if (enableCompareInt)
   \   000060   A2..         MOV       C,?VB.0
   \   000062   5003         JNC       ??macMcuOverflowSetCompare_2
    550            {
    551              T2IRQM |= TIMER2_OVF_COMPARE1M;
   \   000064   43A710       ORL       0xa7,#0x10
    552            }
    553          
    554            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_2:
   \   000067   E8           MOV       A,R0
   \   000068   A2E0         MOV       C,0xE0 /* A   */.0
   \   00006A   02....       LJMP      ?Subroutine1 & 0xFFFF
   \   00006D                REQUIRE _A_IEN0
   \   00006D                REQUIRE T2IRQM
   \   00006D                REQUIRE T2MSEL
   \   00006D                REQUIRE T2MOVF0
   \   00006D                REQUIRE T2MOVF1
   \   00006D                REQUIRE T2MOVF2
   \   00006D                REQUIRE T2IRQF
    555          }
    556          
    557          
    558          /**************************************************************************************************
    559           * @fn          macMcuOverflowGetCompare
    560           *
    561           * @brief       Get overflow count compare value.
    562           *
    563           * @param       none
    564           *
    565           * @return      overflow count compare value
    566           **************************************************************************************************
    567           */
    568          MAC_INTERNAL_API uint32 macMcuOverflowGetCompare(void)
    569          {
    570            halIntState_t  s;
    571            uint32         compare;
    572          
    573            HAL_ENTER_CRITICAL_SECTION(s);
    574          
    575            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
    576          
    577            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    578            ((uint8 *)&compare)[UINT32_NDX0] = T2MOVF0;
    579            ((uint8 *)&compare)[UINT32_NDX1] = T2MOVF1;
    580            ((uint8 *)&compare)[UINT32_NDX2] = T2MOVF2;
    581            ((uint8 *)&compare)[UINT32_NDX3] = 0;
    582          
    583            HAL_EXIT_CRITICAL_SECTION(s);
    584          
    585            return(compare);
    586          }
    587          
    588          
    589          /**************************************************************************************************
    590           * @fn          macMcuTimer2Isr
    591           *
    592           * @brief       Interrupt service routine for timer2, the MAC timer.
    593           *
    594           * @param       none
    595           *
    596           * @return      none
    597           **************************************************************************************************
    598           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    599          HAL_ISR_FUNCTION( macMcuTimer2Isr, T2_VECTOR )
   \                     macMcuTimer2Isr:
    600          {
   \   000000   C0E0         PUSH      A
   \   000002   74F2         MOV       A,#-0xe
   \   000004   12....       LCALL     ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    601            uint8 t2irqm;
    602            uint8 t2irqf;
    603            
    604            HAL_ENTER_ISR();
   \   000007   A2AF         MOV       C,0xa8.7
   \   000009   E4           CLR       A
   \   00000A   33           RLC       A
   \   00000B   FE           MOV       R6,A
   \   00000C   D2AF         SETB      0xa8.7
    605          
    606            t2irqm = T2IRQM;
   \   00000E   A9A7         MOV       R1,0xa7+0x0
    607            t2irqf = T2IRQF;
   \   000010   A8A1         MOV       R0,0xa1+0x0
    608          
    609            /*------------------------------------------------------------------------------------------------
    610             *  Overflow compare interrupt - triggers when then overflow counter is
    611             *  equal to the overflow compare register.
    612             */
    613            if ((t2irqf & TIMER2_OVF_COMPARE1F) & t2irqm)
   \   000012   E8           MOV       A,R0
   \   000013   59           ANL       A,R1
   \   000014   5410         ANL       A,#0x10
   \   000016   6008         JZ        ??macMcuTimer2Isr_0
    614            {
    615          
    616              /* call function for dealing with the timer compare interrupt */
    617              macBackoffTimerCompareIsr();
   \   000018                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   000018   12....       LCALL     `??macBackoffTimerCompareIsr::?relay`; Banked call to: macBackoffTimerCompareIsr
    618          
    619              /* clear overflow compare interrupt flag */
    620              T2IRQF = ~TIMER2_OVF_COMPARE1F;
   \   00001B   75A1EF       MOV       0xa1,#-0x11
   \   00001E   8023         SJMP      ??macMcuTimer2Isr_1
    621            }
    622          
    623            /*------------------------------------------------------------------------------------------------
    624             *  Overflow interrupt - triggers when the hardware timer rolls over.
    625             */
    626            else if ((t2irqf & TIMER2_PERF) & t2irqm)
   \                     ??macMcuTimer2Isr_0:
   \   000020   E8           MOV       A,R0
   \   000021   A2E0         MOV       C,0xE0 /* A   */.0
   \   000023   92F0         MOV       B.0,C
   \   000025   E9           MOV       A,R1
   \   000026   A2E0         MOV       C,0xE0 /* A   */.0
   \   000028   82F0         ANL       C,B.0
   \   00002A   5017         JNC       ??macMcuTimer2Isr_1
    627            {
    628              /* call energy detect interrupt function, this interrupt not used for any other functionality */
    629              mcuRecordMaxRssiIsr();
   \   00002C   906198       MOV       DPTR,#0x6198
   \   00002F   E0           MOVX      A,@DPTR
   \   000030   F8           MOV       R0,A
   \   000031   90....       MOV       DPTR,#maxRssi
   \   000034   E0           MOVX      A,@DPTR
   \   000035   C3           CLR       C
   \   000036   98           SUBB      A,R0
   \   000037   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000039   65D0         XRL       A,PSW
   \   00003B   33           RLC       A
   \   00003C   5002         JNC       ??macMcuTimer2Isr_2
   \   00003E   E8           MOV       A,R0
   \   00003F   F0           MOVX      @DPTR,A
    630          
    631              /* clear the interrupt flag */
    632              T2IRQF = ~TIMER2_PERF;
   \                     ??macMcuTimer2Isr_2:
   \   000040   75A1FE       MOV       0xa1,#-0x2
    633            }
    634            
    635            CLEAR_SLEEP_MODE();
    636            HAL_EXIT_ISR();  
   \                     ??macMcuTimer2Isr_1:
   \   000043                REQUIRE ?Subroutine2
   \   000043                REQUIRE _A_IEN0
   \   000043                REQUIRE T2IRQM
   \   000043                REQUIRE T2IRQF
   \   000043                ; // Fall through to label ?Subroutine2
    637          }

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   EE           MOV       A,R6
   \   000001   A2E0         MOV       C,0xE0 /* A   */.0
   \   000003   92AF         MOV       0xa8.7,C
   \   000005   7F01         MOV       R7,#0x1
   \   000007   02....       LJMP      ?INTERRUPT_LEAVE_XSP
    638          
    639          
    640          /**************************************************************************************************
    641           * @fn          macMcuTimer2OverflowWorkaround
    642           *
    643           * @brief       For CC2530, T2 interrupt won’t be generated when the current count is greater than
    644           *              the comparator. The interrupt is only generated when the current count is equal to
    645           *              the comparator. When the CC2530 is waking up from sleep, there is a small window
    646           *              that the count may be grater than the comparator, therefore, missing the interrupt.
    647           *              This workaround will call the T2 ISR when the current T2 count is greater than the
    648           *              comparator.
    649           *
    650           * @param       none
    651           *
    652           * @return      none
    653           **************************************************************************************************
    654           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    655          void macMcuTimer2OverflowWorkaround(void)
   \                     macMcuTimer2OverflowWorkaround:
    656          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    657            if (T2IRQM & TIMER2_OVF_COMPARE1F)
   \   00000A   E5A7         MOV       A,0xa7
   \   00000C   A2E4         MOV       C,0xE0 /* A   */.4
   \   00000E   5050         JNC       ??macMcuTimer2OverflowWorkaround_0
    658            {
    659              /* T2 comapre 1 interrupt is enabled but T2 compare 1 intererrupt is not generated */
    660              if (!(T2IRQF & TIMER2_OVF_COMPARE1F))
   \   000010   E5A1         MOV       A,0xa1
   \   000012   A2E4         MOV       C,0xE0 /* A   */.4
   \   000014   404A         JC        ??macMcuTimer2OverflowWorkaround_0
    661              {
    662                if (MAC_RADIO_BACKOFF_COUNT() > macMcuOverflowGetCompare())
   \   000016   A8A8         MOV       R0,0xa8+0x0
   \   000018   C2AF         CLR       0xa8.7
   \   00001A   75C330       MOV       0xc3,#0x30
   \   00001D   E5A4         MOV       A,0xa4
   \   00001F   85..82       MOV       DPL,?XSP + 0
   \   000022   85..83       MOV       DPH,?XSP + 1
   \   000025   F0           MOVX      @DPTR,A
   \   000026   E5A5         MOV       A,0xa5
   \   000028   C0E0         PUSH      A
   \   00002A   7401         MOV       A,#0x1
   \   00002C   12....       LCALL     ?XSTACK_DISP0_8
   \   00002F   D0E0         POP       A
   \   000031   F0           MOVX      @DPTR,A
   \   000032   E5A6         MOV       A,0xa6
   \   000034   C0E0         PUSH      A
   \   000036   7402         MOV       A,#0x2
   \   000038   12....       LCALL     ?XSTACK_DISP0_8
   \   00003B   D0E0         POP       A
   \   00003D   F0           MOVX      @DPTR,A
   \   00003E   7403         MOV       A,#0x3
   \   000040   12....       LCALL     ?XSTACK_DISP0_8
   \   000043   E4           CLR       A
   \   000044   F0           MOVX      @DPTR,A
   \   000045   E8           MOV       A,R0
   \   000046   A2E7         MOV       C,0xE0 /* A   */.7
   \   000048   92AF         MOV       0xa8.7,C
   \   00004A                ; Setup parameters for call to function macMcuOverflowCount
   \   00004A   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00004D   85..82       MOV       DPL,?XSP + 0
   \   000050   85..83       MOV       DPH,?XSP + 1
   \   000053   78..         MOV       R0,#?V0
   \   000055   12....       LCALL     ?UL_GT_X
   \   000058   5006         JNC       ??macMcuTimer2OverflowWorkaround_0
    663                {
    664                  /* Set the flag to trigger the timer compare interrupt */
    665                  macBackoffTimerCompareIsr();
   \   00005A                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   00005A   12....       LCALL     `??macBackoffTimerCompareIsr::?relay`; Banked call to: macBackoffTimerCompareIsr
    666                  T2IRQF = ~TIMER2_OVF_COMPARE1F;
   \   00005D   75A1EF       MOV       0xa1,#-0x11
    667                }
    668              }
    669            }
    670          }
   \                     ??macMcuTimer2OverflowWorkaround_0:
   \   000060   80..         SJMP      ??Subroutine8_0
   \   000062                REQUIRE T2IRQM
   \   000062                REQUIRE T2IRQF
   \   000062                REQUIRE _A_IEN0
   \   000062                REQUIRE T2MSEL
   \   000062                REQUIRE T2MOVF0
   \   000062                REQUIRE T2MOVF1
   \   000062                REQUIRE T2MOVF2
    671          
    672          
    673          /**************************************************************************************************
    674           * @fn          macMcuPrecisionCount
    675           *
    676           * @brief       This function is used by higher layer to read a free running counter driven by
    677           *              MAC timer.
    678           *
    679           * @param       none
    680           *
    681           * @return      overflowCount
    682           **************************************************************************************************
    683           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    684          uint16 macMcuPrecisionCount(void)
   \                     macMcuPrecisionCount:
    685          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    686            uint16         overflowCount;
    687            halIntState_t  s;
    688          
    689            HAL_ENTER_CRITICAL_SECTION(s);
   \   00000A   A8A8         MOV       R0,0xa8+0x0
   \   00000C   C2AF         CLR       0xa8.7
    690          
    691            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    692            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   00000E   75C300       MOV       0xc3,#0x0
    693          
    694            /* Latch the entire T2MOVFx first by reading T2M0.
    695             * T2M0 and T2MOVF2 are discarded.
    696             */
    697            T2M0;
   \   000011   E5A2         MOV       A,0xa2
    698            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
   \   000013   E5A4         MOV       A,0xa4
   \   000015   85..82       MOV       DPL,?XSP + 0
   \   000018   85..83       MOV       DPH,?XSP + 1
   \   00001B   F0           MOVX      @DPTR,A
    699            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
   \   00001C   E5A5         MOV       A,0xa5
   \   00001E   C0E0         PUSH      A
   \   000020   7401         MOV       A,#0x1
   \   000022   12....       LCALL     ?XSTACK_DISP0_8
   \   000025   D0E0         POP       A
   \   000027   12....       LCALL     ?Subroutine3 & 0xFFFF
    700            HAL_EXIT_CRITICAL_SECTION(s);
    701          
    702            /* the overflowCount needs to account for the accumulated overflow count in Beacon mode.
    703             * It's okay to let it overflow since only LSBs are used.
    704             */
    705            overflowCount += (uint16)accumulatedOverflowCount;
    706          
    707            return(overflowCount);
   \                     ??CrossCallReturnLabel_1:
   \   00002A   C082         PUSH      DPL
   \   00002C   C083         PUSH      DPH
   \   00002E   90....       MOV       DPTR,#accumulatedOverflowCount
   \   000031   78..         MOV       R0,#?V0
   \   000033   12....       LCALL     ?L_MOV_X
   \   000036   D083         POP       DPH
   \   000038   D082         POP       DPL
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   25..         ADD       A,?V0
   \   00003D   FA           MOV       R2,A
   \   00003E   A3           INC       DPTR
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   35..         ADDC      A,?V1
   \   000042   FB           MOV       R3,A
   \   000043   7402         MOV       A,#0x2
   \   000045   80..         SJMP      ??Subroutine9_0
   \   000047                REQUIRE _A_IEN0
   \   000047                REQUIRE T2MSEL
   \   000047                REQUIRE T2M0
   \   000047                REQUIRE T2MOVF0
   \   000047                REQUIRE T2MOVF1
    708          }
    709          
    710          
    711          /**************************************************************************************************
    712           * @fn          macMcuRfIsr
    713           *
    714           * @brief       Interrupt service routine that handles all RF interrupts.  There are a number
    715           *              of conditions "ganged" onto this one ISR so each condition must be tested for.
    716           *
    717           * @param       none
    718           *
    719           * @return      none
    720           **************************************************************************************************
    721           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    722          HAL_ISR_FUNCTION( macMcuRfIsr, RF_VECTOR )
   \                     macMcuRfIsr:
    723          {
   \   000000   C0E0         PUSH      A
   \   000002   74F2         MOV       A,#-0xe
   \   000004   12....       LCALL     ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    724            uint8 rfim;
    725            
    726            HAL_ENTER_ISR();
   \   000007   A2AF         MOV       C,0xa8.7
   \   000009   E4           CLR       A
   \   00000A   33           RLC       A
   \   00000B   FE           MOV       R6,A
   \   00000C   D2AF         SETB      0xa8.7
    727          
    728            rfim = RFIRQM1;
   \   00000E   9061A4       MOV       DPTR,#0x61a4
   \   000011   E0           MOVX      A,@DPTR
   \   000012   F8           MOV       R0,A
    729          
    730            /*  The CPU level RF interrupt flag must be cleared here (before clearing RFIRQFx).
    731             *  to allow the interrupts to be nested.
    732             */
    733            S1CON = 0x00;
   \   000013   759B00       MOV       0x9b,#0x0
    734          
    735            if ((RFIRQF1 & IRQ_CSP_MANINT) & rfim)
   \   000016   E591         MOV       A,0x91
   \   000018   58           ANL       A,R0
   \   000019   5408         ANL       A,#0x8
   \   00001B   6008         JZ        ??macMcuRfIsr_0
    736            {
    737              /*
    738               *  Important!  Because of how the CSP programs are written, CSP_INT interrupts should
    739               *  be processed before CSP_STOP interrupts.  This becomes an issue when there are
    740               *  long critical sections.
    741               */
    742              /* clear flag */
    743              RFIRQF1 = ~IRQ_CSP_MANINT;
   \   00001D   7591F7       MOV       0x91,#-0x9
    744              macCspTxIntIsr();
   \   000020                ; Setup parameters for call to function macCspTxIntIsr
   \   000020   12....       LCALL     `??macCspTxIntIsr::?relay`; Banked call to: macCspTxIntIsr
   \   000023   8023         SJMP      ??macMcuRfIsr_1
    745            }
    746            else if ((RFIRQF1 & IRQ_CSP_STOP) & rfim)
   \                     ??macMcuRfIsr_0:
   \   000025   E591         MOV       A,0x91
   \   000027   58           ANL       A,R0
   \   000028   5410         ANL       A,#0x10
   \   00002A   6008         JZ        ??macMcuRfIsr_2
    747            {
    748              /* clear flag */
    749              RFIRQF1 = ~IRQ_CSP_STOP;
   \   00002C   7591EF       MOV       0x91,#-0x11
    750              macCspTxStopIsr();
   \   00002F                ; Setup parameters for call to function macCspTxStopIsr
   \   00002F   12....       LCALL     `??macCspTxStopIsr::?relay`; Banked call to: macCspTxStopIsr
   \   000032   8014         SJMP      ??macMcuRfIsr_1
    751            }
    752            else if ((RFIRQF1 & IRQ_TXACKDONE) & rfim)
   \                     ??macMcuRfIsr_2:
   \   000034   E591         MOV       A,0x91
   \   000036   A2E0         MOV       C,0xE0 /* A   */.0
   \   000038   92F0         MOV       B.0,C
   \   00003A   E8           MOV       A,R0
   \   00003B   A2E0         MOV       C,0xE0 /* A   */.0
   \   00003D   82F0         ANL       C,B.0
   \   00003F   5007         JNC       ??macMcuRfIsr_1
    753            {
    754              /* disable interrupt - set up is for "one shot" operation */
    755              RFIRQM1 &= ~IM_TXACKDONE;
   \   000041   E0           MOVX      A,@DPTR
   \   000042   C2E0         CLR       0xE0 /* A   */.0
   \   000044   F0           MOVX      @DPTR,A
    756              macRxAckTxDoneCallback();
   \   000045                ; Setup parameters for call to function macRxAckTxDoneCallback
   \   000045   12....       LCALL     `??macRxAckTxDoneCallback::?relay`; Banked call to: macRxAckTxDoneCallback
    757            }
    758          
    759            rfim = RFIRQM0;
   \                     ??macMcuRfIsr_1:
   \   000048   9061A3       MOV       DPTR,#0x61a3
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   F8           MOV       R0,A
    760          
    761            /* process RFIRQF0 next */
    762            if ((RFIRQF0 & IRQ_FIFOP) & rfim)
   \   00004D   E5E9         MOV       A,0xe9
   \   00004F   58           ANL       A,R0
   \   000050   5404         ANL       A,#0x4
   \   000052   600E         JZ        ??macMcuRfIsr_3
    763            {
    764              /* continue to execute interrup                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        t handler as long as FIFOP is active */
    765              do
    766              {
    767                macRxThresholdIsr();
   \                     ??macMcuRfIsr_4:
   \   000054                ; Setup parameters for call to function macRxThresholdIsr
   \   000054   12....       LCALL     `??macRxThresholdIsr::?relay`; Banked call to: macRxThresholdIsr
    768                RFIRQF0 = ~IRQ_FIFOP;
   \   000057   75E9FB       MOV       0xe9,#-0x5
    769              } while (FSMSTAT1 & FIFOP);
   \   00005A   906193       MOV       DPTR,#0x6193
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   A2E6         MOV       C,0xE0 /* A   */.6
   \   000060   40F2         JC        ??macMcuRfIsr_4
    770            }
    771            
    772            CLEAR_SLEEP_MODE();
    773            HAL_EXIT_ISR();  
   \                     ??macMcuRfIsr_3:
   \   000062   80..         SJMP      ?Subroutine2
   \   000064                REQUIRE _A_IEN0
   \   000064                REQUIRE S1CON
   \   000064                REQUIRE RFIRQF1
   \   000064                REQUIRE RFIRQF0
    774          }
    775          
    776          
    777          /**************************************************************************************************
    778           * @fn          macMcuRfErrIsr
    779           *
    780           * @brief       Interrupt service routine that handles all RF Error interrupts.  Only the RX FIFO
    781           *              overflow condition is handled.
    782           *
    783           * @param       none
    784           *
    785           * @return      none
    786           **************************************************************************************************
    787           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    788          HAL_ISR_FUNCTION( macMcuRfErrIsr, RFERR_VECTOR )
   \                     macMcuRfErrIsr:
    789          {
   \   000000   C0E0         PUSH      A
   \   000002   74F2         MOV       A,#-0xe
   \   000004   12....       LCALL     ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    790            uint8 rferrm;
    791            
    792            HAL_ENTER_ISR();
   \   000007   A2AF         MOV       C,0xa8.7
   \   000009   E4           CLR       A
   \   00000A   33           RLC       A
   \   00000B   FE           MOV       R6,A
   \   00000C   D2AF         SETB      0xa8.7
    793            
    794            rferrm = RFERRM;
   \   00000E   9061A5       MOV       DPTR,#0x61a5
   \   000011   E0           MOVX      A,@DPTR
   \   000012   F8           MOV       R0,A
    795          
    796            if ((RFERRF & RFERR_RXOVERF) & rferrm)
   \   000013   E5BF         MOV       A,0xbf
   \   000015   58           ANL       A,R0
   \   000016   5404         ANL       A,#0x4
   \   000018   6006         JZ        ??macMcuRfErrIsr_0
    797            {
    798              RFERRF = ~RFERR_RXOVERF;
   \   00001A   75BFFB       MOV       0xbf,#-0x5
    799              macRxFifoOverflowIsr();
   \   00001D                ; Setup parameters for call to function macRxFifoOverflowIsr
   \   00001D   12....       LCALL     `??macRxFifoOverflowIsr::?relay`; Banked call to: macRxFifoOverflowIsr
    800            }
    801          
    802            CLEAR_SLEEP_MODE();
    803            HAL_EXIT_ISR();  
   \                     ??macMcuRfErrIsr_0:
   \   000020   02....       LJMP      ?Subroutine2
   \   000023                REQUIRE _A_IEN0
   \   000023                REQUIRE RFERRF
    804          }
    805          
    806          
    807          /**************************************************************************************************
    808           * @fn          macMcuRecordMaxRssiStart
    809           *
    810           * @brief       Starts recording of the maximum received RSSI value.
    811           *
    812           * @param       none
    813           *
    814           * @return      none
    815           **************************************************************************************************
    816           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    817          MAC_INTERNAL_API void macMcuRecordMaxRssiStart(void)
   \                     macMcuRecordMaxRssiStart:
    818          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    819            /* start maximum recorded value at the lowest possible value */
    820            maxRssi = -128;
   \   000004   90....       MOV       DPTR,#maxRssi
   \   000007   7480         MOV       A,#-0x80
   \   000009   F0           MOVX      @DPTR,A
    821          
    822            /* enable timer overflow interrupt */
    823            T2IRQM |= TIMER2_PERM;
   \   00000A   43A701       ORL       0xa7,#0x1
    824          }
   \   00000D   02....       LJMP      ??Subroutine7_0 & 0xFFFF
   \   000010                REQUIRE T2IRQM
    825          
    826          
    827          /**************************************************************************************************
    828           * @fn          macMcuRecordMaxRssiStop
    829           *
    830           * @brief       Stops recording of the maximum received RSSI.  It returns the maximum value
    831           *              received since starting the recording.
    832           *
    833           * @param       none
    834           *
    835           * @return      maximum received RSSI value
    836           **************************************************************************************************
    837           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    838          MAC_INTERNAL_API int8 macMcuRecordMaxRssiStop(void)
   \                     macMcuRecordMaxRssiStop:
    839          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    840            /* disable timer overflow interrupt */
    841            T2IRQM &= ~TIMER2_PERM;
   \   000004   53A7FE       ANL       0xa7,#0xfe
    842          
    843            return(maxRssi);
   \   000007   90....       MOV       DPTR,#maxRssi
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   F9           MOV       R1,A
   \   00000C   02....       LJMP      ??Subroutine7_0 & 0xFFFF
   \   00000F                REQUIRE T2IRQM
    844          }

   \                                 In  segment INTVEC, offset 0x3, root
   \                     `??macMcuRfErrIsr::??INTVEC 3`:
   \   000003   02....       LJMP       (macMcuRfErrIsr)

   \                                 In  segment INTVEC, offset 0x53, root
   \                     `??macMcuTimer2Isr::??INTVEC 83`:
   \   000053   02....       LJMP       (macMcuTimer2Isr)

   \                                 In  segment INTVEC, offset 0x83, root
   \                     `??macMcuRfIsr::??INTVEC 131`:
   \   000083   02....       LJMP       (macMcuRfIsr)

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ff000000:
   \   000000   000000FF     DD 4278190080

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MAC_SetRandomSeedCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MAC_SetRandomSeedCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuRandomByte::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRandomByte

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuRandomWord::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRandomWord

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuTimerForceDelay::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerForceDelay

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuTimerCapture::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuOverflowCount::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuOverflowCapture::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuOverflowSetCount::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuOverflowSetCompare::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCompare

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuTimer2OverflowWorkaround::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimer2OverflowWorkaround

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuPrecisionCount::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuPrecisionCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuRecordMaxRssiStart::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStart

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuRecordMaxRssiStop::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStop
    845          
    846          
    847          /*=================================================================================================
    848           * @fn          macMcuRecordMaxRssiIsr
    849           *
    850           * @brief       Interrupt service routine called during recording of max RSSI value.
    851           *
    852           * @param       none
    853           *
    854           * @return      none
    855           *=================================================================================================
    856           */
    857          static void mcuRecordMaxRssiIsr(void)
    858          {
    859            int8 rssi;
    860          
    861            /* read latest RSSI value */
    862            rssi = RSSI;
    863          
    864            /* if new RSSI value is greater than the maximum already received, it is the new maximum */
    865            if (rssi > maxRssi)
    866            {
    867              maxRssi = rssi;
    868            }
    869          }
    870          
    871          
    872          /**************************************************************************************************
    873           *                                  Compile Time Integrity Checks
    874           **************************************************************************************************
    875           */
    876          #if ((IRQ_SFD != IM_SFD) || (IRQ_FIFOP != IM_FIFOP) || (IRQ_TXACKDONE != IM_TXACKDONE))
    877          #error "ERROR: Compile time error with RFIRQFx vs RFIRQMx register defines."
    878          #endif
    879          
    880          /**************************************************************************************************
    881          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2      0   MAC_SetRandomSeedCB
      3     16   macMcuInit
        2     16   -> macRxOff
        2     16   -> macRxOn
      3      4   macMcuOverflowCapture
      3     20   macMcuOverflowCount
      0     16   macMcuOverflowSetCompare
        0     16   -> halAssertHandler
      2     16   macMcuOverflowSetCount
        0     16   -> halAssertHandler
        2     16   -> macMcuOverflowCount
      2     14   macMcuPrecisionCount
      0      0   macMcuRandomByte
      0      0   macMcuRandomWord
      2      0   macMcuRecordMaxRssiStart
      2      0   macMcuRecordMaxRssiStop
      0     14   macMcuRfErrIsr
        0     14   -> macRxFifoOverflowIsr
      0     14   macMcuRfIsr
        0     14   -> macCspTxIntIsr
        0     14   -> macCspTxStopIsr
        0     14   -> macRxAckTxDoneCallback
        0     14   -> macRxThresholdIsr
      0     14   macMcuTimer2Isr
        0     14   -> macBackoffTimerCompareIsr
      1     16   macMcuTimer2OverflowWorkaround
        0     16   -> macBackoffTimerCompareIsr
        0     16   -> macMcuOverflowCount
      0      0   macMcuTimerCapture
      0      0   macMcuTimerForceDelay


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       3  ??Subroutine6_0
       7  ??Subroutine7_0
       2  ??Subroutine8_0
       8  ??Subroutine9_0
      47  ?Subroutine0
       2  ?Subroutine1
      10  ?Subroutine2
      13  ?Subroutine3
      12  ?Subroutine4
      18  ?Subroutine5
       1  ADCCON1
       1  CLKCONSTA
       1  IEN2
       1  IP0
       1  IP1
      14  MAC_SetRandomSeedCB
       6  MAC_SetRandomSeedCB::?relay
       1  RFERRF
       1  RFIRQF0
       1  RFIRQF1
       1  RNDH
       1  RNDL
       1  S1CON
       1  T2CTRL
       1  T2IRQF
       1  T2IRQM
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
       1  T2MOVF2
       1  T2MSEL
       1  _A_IEN0
       1  _A_IEN1
       4  __Constant_ff000000
       4  accumulatedOverflowCount
       1  macChipVersion
     321  macMcuInit
       6  macMcuInit::?relay
      19  macMcuOverflowCapture
       6  macMcuOverflowCapture::?relay
      21  macMcuOverflowCount
       6  macMcuOverflowCount::?relay
     109  macMcuOverflowSetCompare
       6  macMcuOverflowSetCompare::?relay
     121  macMcuOverflowSetCount
       6  macMcuOverflowSetCount::?relay
      71  macMcuPrecisionCount
       6  macMcuPrecisionCount::?relay
      14  macMcuRandomByte
       6  macMcuRandomByte::?relay
      19  macMcuRandomWord
       6  macMcuRandomWord::?relay
      16  macMcuRecordMaxRssiStart
       6  macMcuRecordMaxRssiStart::?relay
      15  macMcuRecordMaxRssiStop
       6  macMcuRecordMaxRssiStop::?relay
      35  macMcuRfErrIsr
       3  macMcuRfErrIsr::??INTVEC 3
     100  macMcuRfIsr
       3  macMcuRfIsr::??INTVEC 131
      67  macMcuTimer2Isr
       3  macMcuTimer2Isr::??INTVEC 83
      98  macMcuTimer2OverflowWorkaround
       6  macMcuTimer2OverflowWorkaround::?relay
      21  macMcuTimerCapture
       6  macMcuTimerCapture::?relay
      21  macMcuTimerForceDelay
       6  macMcuTimerForceDelay::?relay
       1  maxRssi
       2  pRandomSeedCB

 
 992 bytes in segment BANKED_CODE
  84 bytes in segment BANK_RELAYS
   9 bytes in segment INTVEC
 212 bytes in segment NEAR_CODE
  22 bytes in segment SFR_AN
   4 bytes in segment XDATA_ROM_C
   8 bytes in segment XDATA_Z
 
 296 bytes of CODE     memory (+  9 bytes shared)
   0 bytes of CONST    memory (+  4 bytes shared)
   0 bytes of DATA     memory (+ 22 bytes shared)
 992 bytes of HUGECODE memory
   8 bytes of XDATA    memory

Errors: none
Warnings: none
