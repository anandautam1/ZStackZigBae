###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                08/Jun/2011  10:49:52 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Component #
#                          s\hal\target\CC2530EB\hal_sleep.c                  #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proje #
#                          cts\zstack\Samples\SampleApp\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wCoord.cfg" (-DCPU32MHZ              #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proje #
#                          cts\zstack\Samples\SampleApp\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wConfig.cfg" (-DSECURE=0             #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.3.1\Components\hal\tar #
#                          get\CC2530EB\hal_sleep.c" -D BUILD_ALL_DEVICES -D  #
#                          HOLD_AUTO_START -D LCD_SUPPORTED -D                #
#                          HAL_UART=FALSE -lC "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\DemoEB\List\" -lA         #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\DemoEB\List\"   #
#                          --diag_suppress Pe001,Pa010 -o "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\DemoEB\Obj\" -e           #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\" -I "C:\Texas            #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\SOURCE\" -I "C:\Texas  #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\" #
#                           -I "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\MT\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \HAL\INCLUDE\" -I "C:\Texas                        #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \HAL\TARGET\CC2530EB\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \OSAL\MCU\CCSOC\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \OSAL\INCLUDE\" -I "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\AF\" -I "C:\Texas                           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\NWK\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SEC\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SAPI\" -I "C:\Texas                         #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SYS\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\ZDO\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \ZMAC\F8W\" -I "C:\Texas                           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \ZMAC\" -I "C:\Texas Instruments\ZStack-CC2530-2.3 #
#                          .1\Projects\zstack\Samples\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\SERVICES\SADDR\" -I          #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\SERVICES\SDATA\" -I "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\INCLUDE\" -I "C:\Texas                        #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\HIGH_LEVEL\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\LOW_LEVEL\srf04\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program  #
#                          Files\IAR Systems\Embedded Workbench               #
#                          5.3\8051\INC\" -I "C:\Program Files\IAR            #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\DemoEB\List\hal_ #
#                          sleep.lst                                          #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\DemoEB\Obj\hal_s #
#                          leep.r51                                           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.3.1\Components\hal\target\CC2530EB\hal_sleep.c
      1          /**************************************************************************************************
      2            Filename:       hal_sleep.c
      3            Revised:        $Date: 2010-07-22 09:47:19 -0700 (Thu, 22 Jul 2010) $
      4            Revision:       $Revision: 23100 $
      5          
      6            Description:    This module contains the HAL power management procedures for the CC2530.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          #include "hal_types.h"
     45          #include "hal_mcu.h"
     46          #include "hal_board.h"
     47          #include "hal_sleep.h"
     48          #include "hal_led.h"
     49          #include "hal_key.h"
     50          #include "mac_api.h"
     51          #include "OSAL.h"
     52          #include "OSAL_Timers.h"
     53          #include "OSAL_Tasks.h"
     54          #include "OSAL_PwrMgr.h"
     55          #include "OnBoard.h"
     56          #include "hal_drivers.h"
     57          #include "hal_assert.h"
     58          #include "mac_mcu.h"
     59          
     60          #ifndef ZG_BUILD_ENDDEVICE_TYPE
     61          # define ZG_BUILD_ENDDEVICE_TYPE FALSE
     62          #endif
     63          
     64          #if ZG_BUILD_ENDDEVICE_TYPE && defined (NWK_AUTO_POLL)
     65          #include "nwk_globals.h"
     66          #include "ZGlobals.h"
     67          #endif
     68          
     69          /* ------------------------------------------------------------------------------------------------
     70           *                                           Macros
     71           * ------------------------------------------------------------------------------------------------
     72           */
     73          
     74          /* POWER CONSERVATION DEFINITIONS
     75           * Sleep mode H/W definitions (enabled with POWER_SAVING compile option)
     76           */
     77          #define CC2530_PM0            0  /* PM0, Clock oscillators on, voltage regulator on */
     78          #define CC2530_PM1            1  /* PM1, 32.768 kHz oscillators on, voltage regulator on */
     79          #define CC2530_PM2            2  /* PM2, 32.768 kHz oscillators on, voltage regulator off */
     80          #define CC2530_PM3            3  /* PM3, All clock oscillators off, voltage regulator off */
     81          
     82          /* HAL power management mode is set according to the power management state. The default
     83           * setting is HAL_SLEEP_OFF. The actual value is tailored to different HW platform. Both
     84           * HAL_SLEEP_TIMER and HAL_SLEEP_DEEP selections will:
     85           *   1. turn off the system clock, and
     86           *   2. halt the MCU.
     87           * HAL_SLEEP_TIMER can be woken up by sleep timer interrupt, I/O interrupt and reset.
     88           * HAL_SLEEP_DEEP can be woken up by I/O interrupt and reset.
     89           */
     90          #define HAL_SLEEP_OFF         CC2530_PM0
     91          #define HAL_SLEEP_TIMER       CC2530_PM2
     92          #define HAL_SLEEP_DEEP        CC2530_PM3
     93          
     94          /* MAX_SLEEP_TIME calculation:
     95           *   Sleep timer maximum duration = 0xFFFF7F / 32768 Hz = 511.996 seconds
     96           *   Round it to 510 seconds or 510000 ms
     97           */
     98          #define MAX_SLEEP_TIME                   510000             /* maximum time to sleep allowed by ST */
     99          
    100          
    101          /* minimum time to sleep, this macro is to:
    102           * 1. avoid thrashing in-and-out of sleep with short OSAL timer (~2ms)
    103           * 2. define minimum safe sleep period
    104           */
    105          #if !defined (PM_MIN_SLEEP_TIME)
    106          #define PM_MIN_SLEEP_TIME                14                 /* default to minimum safe sleep time minimum CAP */
    107          #endif
    108          
    109          /* The PCON instruction must be 4-byte aligned. The following code may cause excessive power
    110           * consumption if not aligned. See linker file ".xcl" for actual placement.
    111           */
    112          #pragma location = "SLEEP_CODE"
    113          void halSetSleepMode(void);
    114          
    115          /* This value is used to adjust the sleep timer compare value such that the sleep timer
    116           * compare takes into account the amount of processing time spent in function halSleep().
    117           * The first value is determined by measuring the number of sleep timer ticks it from
    118           * the beginning of the function to entering sleep mode or more precisely, when
    119           * MAC_PwrNextTimeout() is called.  The second value is determined by measuring the number
    120           * of sleep timer ticks from exit of sleep mode to the call to MAC_PwrOnReq() where the
    121           * MAC timer is restarted.
    122           */
    123          #define HAL_SLEEP_ADJ_TICKS   (11 + 12)
    124          
    125          #ifndef HAL_SLEEP_DEBUG_POWER_MODE
    126          /* set CC2530 power mode; always use PM2 */
    127          #define HAL_SLEEP_PREP_POWER_MODE(mode)     st( SLEEPCMD &= ~PMODE; /* clear mode bits */    \
    128                                                          SLEEPCMD |= mode;   /* set mode bits   */    \
    129                                                          while (!(STLOAD & LDRDY));                   \
    130                                                          halSleepPconValue = PCON_IDLE;               \
    131                                                        )
    132          #define HAL_SLEEP_PREP_IDLE_MODE()          st( SLEEPCMD &= ~PMODE; /* clear mode bits */    \
    133                                                          halSleepPconValue = PCON_IDLE;               \
    134                                                        )
    135          #define HAL_SLEEP_SET_POWER_MODE()          halSetSleepMode()
    136          #else
    137          /* Debug: don't set power mode, just block until sleep timer interrupt */
    138          #define HAL_SLEEP_PREP_POWER_MODE(mode)
    139          #define HAL_SLEEP_PREP_IDLE_MODE(mode)
    140          #define HAL_SLEEP_SET_POWER_MODE()          st( while(halSleepInt == FALSE); \
    141                                                          halSleepInt = FALSE;         \
    142                                                          HAL_DISABLE_INTERRUPTS();    \
    143                                                        )
    144          #endif
    145          
    146          /* sleep and external interrupt port masks */
    147          #define STIE_BV                             BV(5)
    148          #define P0IE_BV                             BV(5)
    149          #define P1IE_BV                             BV(4)
    150          #define P2IE_BV                             BV(1)
    151          
    152          /* sleep timer interrupt control */
    153          #define HAL_SLEEP_TIMER_ENABLE_INT()        st(IEN0 |= STIE_BV;)     /* enable sleep timer interrupt */
    154          #define HAL_SLEEP_TIMER_DISABLE_INT()       st(IEN0 &= ~STIE_BV;)    /* disable sleep timer interrupt */
    155          #define HAL_SLEEP_TIMER_CLEAR_INT()         st(STIF = 0;)            /* clear sleep interrupt flag */
    156          
    157          /* backup interrupt enable registers before sleep */
    158          #define HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2) st(ien0  = IEN0;    /* backup IEN0 register */ \
    159                                                                       ien1  = IEN1;    /* backup IEN1 register */ \
    160                                                                       ien2  = IEN2;    /* backup IEN2 register */ \
    161                                                                       IEN0 &= STIE_BV; /* disable IEN0 except STIE */ \
    162                                                                       IEN1 &= P0IE_BV; /* disable IEN1 except P0IE */ \
    163                                                                       IEN2 &= (P1IE_BV|P2IE_BV);) /* disable IEN2 except P1IE, P2IE */
    164          
    165          /* restore interrupt enable registers before sleep */
    166          #define HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2) st(IEN0 = ien0;   /* restore IEN0 register */ \
    167                                                            IEN1 = ien1;   /* restore IEN1 register */ \
    168                                                            IEN2 = ien2;)  /* restore IEN2 register */
    169          
    170          /* convert msec to 320 usec units with round */
    171          #define HAL_SLEEP_MS_TO_320US(ms)           (((((uint32) (ms)) * 100) + 31) / 32)
    172          
    173          /* for optimized indexing of uint32's */
    174          #if HAL_MCU_LITTLE_ENDIAN()
    175          #define UINT32_NDX0   0
    176          #define UINT32_NDX1   1
    177          #define UINT32_NDX2   2
    178          #define UINT32_NDX3   3
    179          #else
    180          #define UINT32_NDX0   3
    181          #define UINT32_NDX1   2
    182          #define UINT32_NDX2   1
    183          #define UINT32_NDX3   0
    184          #endif
    185          
    186          /* ------------------------------------------------------------------------------------------------
    187           *                                        Global Variables
    188           * ------------------------------------------------------------------------------------------------
    189           */
    190          /* PCON register value to program when setting power mode */
    191          volatile __data uint8 halSleepPconValue = PCON_IDLE;
    192          
    193          /* ------------------------------------------------------------------------------------------------
    194           *                                        Local Variables
    195           * ------------------------------------------------------------------------------------------------
    196           */
    197          
    198          /* HAL power management mode is set according to the power management state.
    199           */
    200          static uint8 halPwrMgtMode = HAL_SLEEP_OFF;
    201          
    202          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    203          static bool halSleepInt = FALSE;
    204          #endif
    205          
    206          /* ------------------------------------------------------------------------------------------------
    207           *                                      Function Prototypes
    208           * ------------------------------------------------------------------------------------------------
    209           */
    210          
    211          void halSleepSetTimer(uint32 timeout);
    212          void halSleepEnterIdleMode(uint32 timeout);
    213          
    214          /**************************************************************************************************
    215           * @fn          halSleep
    216           *
    217           * @brief       This function put the CC2530 to sleep. The PCON instruction must be 4-byte aligned.
    218           *              The following code may cause excessive power consumption if not aligned. See linker
    219           *              file ".xcl" for actual placement.
    220           *
    221           * input parameters
    222           *
    223           * @param       None.
    224           *
    225           * output parameters
    226           *
    227           * None.
    228           *
    229           * @return      None.
    230           **************************************************************************************************
    231           */
    232          void halSetSleepMode(void)
    233          {
    234            PCON = halSleepPconValue;
    235            asm("NOP");
    236          }
    237          
    238          /**************************************************************************************************
    239           * @fn          halSleep
    240           *
    241           * @brief       This function is called from the OSAL task loop using and existing OSAL
    242           *              interface.  It sets the low power mode of the MAC and the CC2530.
    243           *
    244           * input parameters
    245           *
    246           * @param       osal_timeout - Next OSAL timer timeout.
    247           *
    248           * output parameters
    249           *
    250           * None.
    251           *
    252           * @return      None.
    253           **************************************************************************************************
    254           */
    255          void halSleep( uint16 osal_timeout )
    256          {
    257            uint32        timeout;
    258            uint32        macTimeout = 0;
    259          
    260            /* get next OSAL timer expiration converted to 320 usec units */
    261            timeout = HAL_SLEEP_MS_TO_320US(osal_timeout);
    262            if (timeout == 0)
    263            {
    264              timeout = MAC_PwrNextTimeout();
    265            }
    266            else
    267            {
    268              /* get next MAC timer expiration */
    269              macTimeout = MAC_PwrNextTimeout();
    270          
    271              /* get lesser of two timeouts */
    272              if ((macTimeout != 0) && (macTimeout < timeout))
    273              {
    274                timeout = macTimeout;
    275              }
    276            }
    277          
    278            /* HAL_SLEEP_PM2 is entered only if the timeout is zero and
    279             * the device is a stimulated device.
    280             */
    281            halPwrMgtMode = (timeout == 0) ? HAL_SLEEP_DEEP : HAL_SLEEP_TIMER;
    282          
    283            /* DEEP sleep can only be entered when zgPollRate == 0.
    284             * This is to eliminate any possibility of entering PM3 between
    285             * two network timers.
    286             */
    287          #if ZG_BUILD_ENDDEVICE_TYPE && defined (NWK_AUTO_POLL)
    288            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    289                (timeout == 0 && zgPollRate == 0))
    290          #else
    291            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    292                (timeout == 0))
    293          #endif
    294            {
    295              halIntState_t ien0, ien1, ien2;
    296          
    297              HAL_ASSERT(HAL_INTERRUPTS_ARE_ENABLED());
    298              HAL_DISABLE_INTERRUPTS();
    299          
    300              /* always use "deep sleep" to turn off radio VREG on CC2530 */
    301              if (halSleepPconValue != 0 && MAC_PwrOffReq(MAC_PWR_SLEEP_DEEP) == MAC_SUCCESS)
    302              {
    303                /* The PCON value is not zero. There is no interrupt overriding the 
    304                 * sleep decision. Also, the radio granted the sleep request.
    305                 */
    306          
    307          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    308                /* get peripherals ready for sleep */
    309                HalKeyEnterSleep();
    310          #endif
    311          
    312          #ifdef HAL_SLEEP_DEBUG_LED
    313                HAL_TURN_OFF_LED3();
    314          #else
    315                /* use this to turn LEDs off during sleep */
    316                HalLedEnterSleep();
    317          #endif
    318          
    319                /* enable sleep timer interrupt */
    320                if (timeout != 0)
    321                {
    322                  if (timeout > HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ))
    323                  {
    324                    timeout -= HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME );
    325                    halSleepSetTimer(HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ));
    326                  }
    327                  else
    328                  {
    329                    /* set sleep timer */
    330                    halSleepSetTimer(timeout);
    331                  }
    332          
    333                  /* set up sleep timer interrupt */
    334                  HAL_SLEEP_TIMER_CLEAR_INT();
    335                  HAL_SLEEP_TIMER_ENABLE_INT();
    336                }
    337          
    338          #ifdef HAL_SLEEP_DEBUG_LED
    339                if (halPwrMgtMode == CC2530_PM1)
    340                {
    341                  HAL_TURN_ON_LED1();
    342                }
    343                else
    344                {
    345                  HAL_TURN_OFF_LED1();
    346                }
    347          #endif
    348          
    349                /* Prep CC2530 power mode */
    350                HAL_SLEEP_PREP_POWER_MODE(halPwrMgtMode);
    351          
    352                /* save interrupt enable registers and disable all interrupts */
    353                HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2);
    354                HAL_ENABLE_INTERRUPTS();
    355          
    356                /* set CC2530 power mode, interrupt is disabled after this function
    357                 * Note that an ISR (that could wake up from power mode) which runs
    358                 * between the previous instruction enabling interrupts and before
    359                 * power mode is set would switch the halSleepPconValue so that
    360                 * power mode shall not be entered in such a case. 
    361                 */
    362                HAL_SLEEP_SET_POWER_MODE();
    363          
    364                /* Disable interrupt immediately */
    365                HAL_DISABLE_INTERRUPTS();
    366          
    367                /* restore interrupt enable registers */
    368                HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2);
    369          
    370                /* disable sleep timer interrupt */
    371                HAL_SLEEP_TIMER_DISABLE_INT();
    372          
    373          #ifdef HAL_SLEEP_DEBUG_LED
    374                HAL_TURN_ON_LED3();
    375          #else
    376                /* use this to turn LEDs back on after sleep */
    377                HalLedExitSleep();
    378          #endif
    379          
    380          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    381                /* handle peripherals */
    382                (void)HalKeyExitSleep();
    383          #endif
    384          
    385                /* power on the MAC; blocks until completion */
    386                MAC_PwrOnReq();
    387          
    388                HAL_ENABLE_INTERRUPTS();
    389          
    390                /* For CC2530, T2 interrupt won’t be generated when the current count is greater than
    391                 * the comparator. The interrupt is only generated when the current count is equal to
    392                 * the comparator. When the CC2530 is waking up from sleep, there is a small window
    393                 * that the count may be grater than the comparator, therefore, missing the interrupt.
    394                 * This workaround will call the T2 ISR when the current T2 count is greater than the
    395                 * comparator. The problem only occurs when POWER_SAVING is turned on, i.e. the 32KHz
    396                 * drives the chip in sleep and SYNC start is used.
    397                 */
    398                macMcuTimer2OverflowWorkaround();
    399              }
    400              else
    401              {
    402                /* Sleep request is not granted. Check PCON value to see why the sleep is not granted. */
    403                if (halSleepPconValue == 0)
    404                {
    405                  /* An interrupt may have changed the sleep decision. Do not sleep at all. Turn on 
    406                   * the interrupt, exit normally, and the next sleep will be allowed.
    407                   */
    408                  HAL_ENABLE_INTERRUPTS();
    409                }
    410                else
    411                {
    412                  /* PCON value is okay but Radio cannot enter power mode hence just put CPU to idle mode.
    413                   * Interrupt will be enabled in halSleepEnterIdleMode().
    414                   */
    415                  halSleepEnterIdleMode(timeout);
    416                }
    417              }
    418            }
    419            else
    420            {
    421              /* Timeout is too close to enter power mode. Try idle mode. */
    422              HAL_DISABLE_INTERRUPTS();
    423          
    424              /* Interrupt will be enabled in halSleepEnterIdleMode(). */
    425              halSleepEnterIdleMode(timeout);
    426            }
    427          }
    428          
    429          /**************************************************************************************************
    430           * @fn          halSleepSetTimer
    431           *
    432           * @brief       This function sets the CC2530 sleep timer compare value.  First it reads and
    433           *              stores the value of the sleep timer; this value is used later to update OSAL
    434           *              timers.  Then the timeout value is converted from 320 usec units to 32 kHz
    435           *              period units and the compare value is set to the timeout.
    436           *
    437           * input parameters
    438           *
    439           * @param       timeout - Timeout value in 320 usec units.  The sleep timer compare is set to
    440           *                        this value.
    441           *
    442           * output parameters
    443           *
    444           * None.
    445           *
    446           * @return      None.
    447           **************************************************************************************************
    448           */
    449          void halSleepSetTimer(uint32 timeout)
    450          {
    451            uint32 ticks;
    452          
    453            /* read the sleep timer; ST0 must be read first */
    454            ((uint8 *) &ticks)[UINT32_NDX0] = ST0;
    455            ((uint8 *) &ticks)[UINT32_NDX1] = ST1;
    456            ((uint8 *) &ticks)[UINT32_NDX2] = ST2;
    457            ((uint8 *) &ticks)[UINT32_NDX3] = 0;
    458          
    459            /* Compute sleep timer compare value.  The ratio of 32 kHz ticks to 320 usec ticks
    460             * is 32768/3125 = 10.48576.  This is nearly 671/64 = 10.484375.
    461             */
    462            ticks += (timeout * 671) / 64;
    463          
    464            /* subtract the processing time spent in function halSleep() */
    465            ticks -= HAL_SLEEP_ADJ_TICKS;
    466          
    467            /* set sleep timer compare; ST0 must be written last */
    468            ST2 = ((uint8 *) &ticks)[UINT32_NDX2];
    469            ST1 = ((uint8 *) &ticks)[UINT32_NDX1];
    470            ST0 = ((uint8 *) &ticks)[UINT32_NDX0];
    471          }
    472          
    473          /**************************************************************************************************
    474           * @fn          halSleepEnterIdleMode
    475           *
    476           * @brief       This function puts the device into idle mode.
    477           *              Note that interrupts must have been disabled before this function call.
    478           *
    479           * input parameters
    480           *
    481           * @param       timeout - Timeout value in 320 usec units.  The sleep timer compare is set to
    482           *                        this value.
    483           *
    484           * output parameters
    485           *
    486           * None.
    487           *
    488           * @return      None.
    489           **************************************************************************************************
    490           */
    491          void halSleepEnterIdleMode(uint32 timeout)
    492          {
    493            /* enable sleep timer interrupt */
    494            if (timeout != 0)
    495            {
    496              if (timeout > HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME ))
    497              {
    498                timeout = HAL_SLEEP_MS_TO_320US( MAX_SLEEP_TIME );
    499              }
    500              /* set sleep timer */
    501              halSleepSetTimer(timeout);
    502              
    503              /* set up sleep timer interrupt */
    504              HAL_SLEEP_TIMER_CLEAR_INT();
    505              HAL_SLEEP_TIMER_ENABLE_INT();
    506            }
    507            HAL_SLEEP_PREP_IDLE_MODE();
    508            HAL_ENABLE_INTERRUPTS();
    509            HAL_SLEEP_SET_POWER_MODE();
    510          }
    511          
    512          /**************************************************************************************************
    513           * @fn          TimerElapsed
    514           *
    515           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.
    516           *              Deprecated for CC2530 and CC2430 SoC.
    517           *
    518           * input parameters
    519           *
    520           * @param       None.
    521           *
    522           * output parameters
    523           *
    524           * None.
    525           *
    526           * @return      Number of timer ticks elapsed during sleep.
    527           **************************************************************************************************
    528           */
    529          uint32 TimerElapsed( void )
    530          {
    531            /* Stubs */
    532            return (0);
    533          }
    534          
    535          /**************************************************************************************************
    536           * @fn          halRestoreSleepLevel
    537           *
    538           * @brief       Restore the deepest timer sleep level.
    539           *
    540           * input parameters
    541           *
    542           * @param       None
    543           *
    544           * output parameters
    545           *
    546           *              None.
    547           *
    548           * @return      None.
    549           **************************************************************************************************
    550           */
    551          void halRestoreSleepLevel( void )
    552          {
    553            /* Stubs */
    554          }
    555          
    556          /**************************************************************************************************
    557           * @fn          halSleepTimerIsr
    558           *
    559           * @brief       Sleep timer ISR.
    560           *
    561           * input parameters
    562           *
    563           * None.
    564           *
    565           * output parameters
    566           *
    567           * None.
    568           *
    569           * @return      None.
    570           **************************************************************************************************
    571           */
    572          HAL_ISR_FUNCTION(halSleepTimerIsr, ST_VECTOR)
    573          {
    574            HAL_ENTER_ISR();
    575            HAL_SLEEP_TIMER_CLEAR_INT();
    576          
    577          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    578            halSleepInt = TRUE;
    579          #endif
    580            
    581            CLEAR_SLEEP_MODE();
    582            HAL_EXIT_ISR();
    583          }
    584          

Errors: 1
Warnings: none
