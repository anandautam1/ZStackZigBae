###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                08/Jun/2011  10:49:48 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Component #
#                          s\stack\zdo\ZDSecMgr.c                             #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proje #
#                          cts\zstack\Samples\SampleApp\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wCoord.cfg" (-DCPU32MHZ              #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proje #
#                          cts\zstack\Samples\SampleApp\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wConfig.cfg" (-DSECURE=0             #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.3.1\Components\stack\z #
#                          do\ZDSecMgr.c" -D BUILD_ALL_DEVICES -D             #
#                          HOLD_AUTO_START -D LCD_SUPPORTED -D                #
#                          HAL_UART=FALSE -lC "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\DemoEB\List\" -lA         #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\DemoEB\List\"   #
#                          --diag_suppress Pe001,Pa010 -o "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\DemoEB\Obj\" -e           #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\" -I "C:\Texas            #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\SOURCE\" -I "C:\Texas  #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\" #
#                           -I "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\MT\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \HAL\INCLUDE\" -I "C:\Texas                        #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \HAL\TARGET\CC2530EB\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \OSAL\MCU\CCSOC\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \OSAL\INCLUDE\" -I "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\AF\" -I "C:\Texas                           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\NWK\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SEC\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SAPI\" -I "C:\Texas                         #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SYS\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\ZDO\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \ZMAC\F8W\" -I "C:\Texas                           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \ZMAC\" -I "C:\Texas Instruments\ZStack-CC2530-2.3 #
#                          .1\Projects\zstack\Samples\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\SERVICES\SADDR\" -I          #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\SERVICES\SDATA\" -I "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\INCLUDE\" -I "C:\Texas                        #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\HIGH_LEVEL\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\LOW_LEVEL\srf04\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program  #
#                          Files\IAR Systems\Embedded Workbench               #
#                          5.3\8051\INC\" -I "C:\Program Files\IAR            #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\DemoEB\List\ZDSe #
#                          cMgr.lst                                           #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\DemoEB\Obj\ZDSec #
#                          Mgr.r51                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.3.1\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2010-08-20 15:30:00 -0700 (Fri, 20 Aug 2010) $
      4            Revision:       $Revision: 23463 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          // Total number of preconfigured trust center link key
     93          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     94            #define ZDSECMGR_TC_DEVICE_MAX 1
     95          #endif
     96            
     97          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     98            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     99          #endif
    100            
    101          #define ZDSECMGR_CTRL_NONE       0
    102          #define ZDSECMGR_CTRL_INIT       1
    103          #define ZDSECMGR_CTRL_TK_MASTER  2
    104          #define ZDSECMGR_CTRL_SKKE_INIT  3
    105          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    106          #define ZDSECMGR_CTRL_SKKE_DONE  5
    107          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    108          #define ZDSECMGR_CTRL_TK_NWK     7
    109          
    110          #define ZDSECMGR_CTRL_BASE_CNTR      1
    111          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    112          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    113          
    114          // set SKA slot maximum
    115          #define ZDSECMGR_SKA_SLOT_MAX 1
    116          
    117          // APSME Stub Implementations
    118          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    119          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    120          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
    121          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    122          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
    123          
    124          /******************************************************************************
    125           * TYPEDEFS
    126           */
    127          typedef struct
    128          {
    129            uint8 extAddr[Z_EXTADDR_LEN];
    130            uint8 key[SEC_KEY_LEN];
    131          } ZDSecMgrPreConfigData_t;
    132          
    133          typedef struct
    134          {
    135            uint16 ami;
    136            uint8  key[SEC_KEY_LEN];
    137          } ZDSecMgrMasterKeyData_t;
    138          
    139          typedef struct
    140          {
    141            uint16            ami;
    142            uint16            keyNvId;   // index to the Link Key table in NV
    143            ZDSecMgr_Authentication_Option authenticateOption;
    144          } ZDSecMgrEntry_t;
    145          
    146          typedef struct
    147          {
    148            ZDSecMgrEntry_t* entry;
    149            uint16           parentAddr;
    150            uint8            secure;
    151            uint8            state;
    152            uint8            cntr;
    153          } ZDSecMgrCtrl_t;
    154          
    155          typedef struct
    156          {
    157            uint16          nwkAddr;
    158            uint8*          extAddr;
    159            uint16          parentAddr;
    160            uint8           secure;
    161            uint8           devStatus;
    162            ZDSecMgrCtrl_t* ctrl;
    163          } ZDSecMgrDevice_t;
    164          
    165          /******************************************************************************
    166           * LOCAL VARIABLES
    167           */
    168          #if 0 // Taken out because the following functionality is only used for test
    169                // purpose. A more efficient (above) way is used. It can be put
    170                // back in if customers request for a white/black list feature.
    171          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    172          {
    173            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    174            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    175            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    176          };
    177          #endif
    178          
    179          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
    180            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    181          
    182          // Key data is put in CONST area for security reasons
    183          CONST uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
    184            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    185             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    186          
    187          uint8 ZDSecMgrTCAuthenticated = FALSE;
    188          uint8 ZDSecMgrTCDataLoaded    = FALSE;
    189          
    190          //devtag.pro.security - remove this
    191          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    192          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    193          {
    194            //---------------------------------------------------------------------------
    195            // DEVICE A
    196            //---------------------------------------------------------------------------
    197            {
    198              // extAddr
    199              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    200          
    201              // key
    202              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    203               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    204            },
    205            //---------------------------------------------------------------------------
    206            // DEVICE B
    207            //---------------------------------------------------------------------------
    208            {
    209              // extAddr
    210              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    211          
    212              // key
    213              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    214               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    215            },
    216            //---------------------------------------------------------------------------
    217            // DEVICE C
    218            //---------------------------------------------------------------------------
    219            {
    220              // extAddr
    221              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    222          
    223              // key
    224              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    225               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    226            },
    227          };
    228          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    229          
    230          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
    231          ZDSecMgrCtrl_t*  ZDSecMgrCtrlData = NULL;
    232          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    233          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    234          
    235          uint8 ZDSecMgrPermitJoiningEnabled;
    236          uint8 ZDSecMgrPermitJoiningTimed;
    237          
    238          APSME_TCLinkKey_t TrustCenterLinkKey;
    239          
    240          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
    241          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
    242          
    243          /******************************************************************************
    244           * PRIVATE FUNCTIONS
    245           *
    246           *   ZDSecMgrMasterKeyInit
    247           *   ZDSecMgrAddrStore
    248           *   ZDSecMgrExtAddrStore
    249           *   ZDSecMgrExtAddrLookup
    250           *   ZDSecMgrMasterKeyLookup
    251           *   ZDSecMgrMasterKeyStore
    252           *   ZDSecMgrEntryInit
    253           *   ZDSecMgrEntryLookup
    254           *   ZDSecMgrEntryLookupAMI
    255           *   ZDSecMgrEntryLookupExt
    256           *   ZDSecMgrEntryLookupExtGetIndex
    257           *   ZDSecMgrEntryFree
    258           *   ZDSecMgrEntryNew
    259           *   ZDSecMgrCtrlInit
    260           *   ZDSecMgrCtrlRelease
    261           *   ZDSecMgrCtrlLookup
    262           *   ZDSecMgrCtrlSet
    263           *   ZDSecMgrCtrlAdd
    264           *   ZDSecMgrCtrlTerm
    265           *   ZDSecMgrCtrlReset
    266           *   ZDSecMgrMasterKeyLoad
    267           *   ZDSecMgrAppKeyGet
    268           *   ZDSecMgrAppKeyReq
    269           *   ZDSecMgrEstablishKey
    270           *   ZDSecMgrSendMasterKey
    271           *   ZDSecMgrSendNwkKey
    272           *   ZDSecMgrDeviceEntryRemove
    273           *   ZDSecMgrDeviceEntryAdd
    274           *   ZDSecMgrDeviceCtrlHandler
    275           *   ZDSecMgrDeviceCtrlSetup
    276           *   ZDSecMgrDeviceCtrlUpdate
    277           *   ZDSecMgrDeviceRemove
    278           *   ZDSecMgrDeviceValidateSKKE
    279           *   ZDSecMgrDeviceValidateRM
    280           *   ZDSecMgrDeviceValidateCM
    281           *   ZDSecMgrDeviceValidate
    282           *   ZDSecMgrDeviceJoin
    283           *   ZDSecMgrDeviceJoinDirect
    284           *   ZDSecMgrDeviceJoinFwd
    285           *   ZDSecMgrDeviceNew
    286           *   ZDSecMgrAssocDeviceAuth
    287           *   ZDSecMgrAuthInitiate
    288           *   ZDSecMgrAuthNwkKey
    289           *   APSME_TCLinkKeyInit
    290           *   APSME_IsDefaultTCLK
    291           */
    292          //-----------------------------------------------------------------------------
    293          // master key data
    294          //-----------------------------------------------------------------------------
    295          void ZDSecMgrMasterKeyInit( void );
    296          
    297          //-----------------------------------------------------------------------------
    298          // address management
    299          //-----------------------------------------------------------------------------
    300          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    301          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    302          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    303          
    304          //-----------------------------------------------------------------------------
    305          // MASTER key data
    306          //-----------------------------------------------------------------------------
    307          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId );
    308          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    309          
    310          //-----------------------------------------------------------------------------
    311          // entry data
    312          //-----------------------------------------------------------------------------
    313          void ZDSecMgrEntryInit(uint8 state);
    314          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    315          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    316          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    318          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    319          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    320          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    321          void ZDSecMgrApsLinkKeyInit(void);
    322          #if defined NV_RESTORE
    323          static void ZDSecMgrWriteNV(void);
    324          static void ZDSecMgrRestoreFromNV(void);
    325          #endif
    326          
    327          //-----------------------------------------------------------------------------
    328          // control data
    329          //-----------------------------------------------------------------------------
    330          void ZDSecMgrCtrlInit( void );
    331          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    332          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    333          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    334                                ZDSecMgrEntry_t*  entry,
    335                                ZDSecMgrCtrl_t*   ctrl );
    336          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    337          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    338          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    339                                       ZDSecMgrEntry_t*  entry );
    340          
    341          //-----------------------------------------------------------------------------
    342          // key support
    343          //-----------------------------------------------------------------------------
    344          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    345          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    346                                       uint8*  initExtAddr,
    347                                       uint16  partNwkAddr,
    348                                       uint8*  partExtAddr,
    349                                       uint8** key,
    350                                       uint8*  keyType );
    351          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    352          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    353          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    354          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    355          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    356          
    357          //-----------------------------------------------------------------------------
    358          // device entry
    359          //-----------------------------------------------------------------------------
    360          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    361          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    362          
    363          //-----------------------------------------------------------------------------
    364          // device control
    365          //-----------------------------------------------------------------------------
    366          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    367          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    368          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    369          
    370          //-----------------------------------------------------------------------------
    371          // device management
    372          //-----------------------------------------------------------------------------
    373          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    374          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    375          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    376          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    377          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    378          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    379          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    382          
    383          //-----------------------------------------------------------------------------
    384          // association management
    385          //-----------------------------------------------------------------------------
    386          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    387          
    388          //-----------------------------------------------------------------------------
    389          // authentication management
    390          //-----------------------------------------------------------------------------
    391          void ZDSecMgrAuthInitiate( uint8* responder );
    392          void ZDSecMgrAuthNwkKey( void );
    393          
    394          //-----------------------------------------------------------------------------
    395          // APSME function
    396          //-----------------------------------------------------------------------------
    397          void APSME_TCLinkKeyInit( uint8 setDefault );
    398          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    399          
    400          /******************************************************************************
    401           * @fn          ZDSecMgrMasterKeyInit                     ]
    402           *
    403           * @brief       Initialize master key data in NV
    404           *
    405           * @param       none
    406           *
    407           * @return      none
    408           */
    409          void ZDSecMgrMasterKeyInit( void )
    410          {
    411            uint16 index;
    412            ZDSecMgrMasterKeyData_t   masterKeyData;
    413          
    414            masterKeyData.ami = INVALID_NODE_ADDR;
    415          
    416            osal_memset( &masterKeyData.key, 0x00, SEC_KEY_LEN );
    417          
    418            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    419            {
    420              if ( osal_nv_item_init( (ZCD_NV_MASTER_KEY_DATA_START + index), 
    421                                 sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData) == SUCCESS)
    422              {
    423                // the item already exists in NV just needs to be set to default values
    424                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    425                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
    426              }
    427            }
    428          }
    429          
    430          /******************************************************************************
    431           * @fn          ZDSecMgrAddrStore
    432           *
    433           * @brief       Store device addresses.
    434           *
    435           * @param       nwkAddr - [in] NWK address
    436           * @param       extAddr - [in] EXT address
    437           * @param       ami     - [out] Address Manager index
    438           *
    439           * @return      ZStatus_t
    440           */
    441          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
    442          {
    443            ZStatus_t      status;
    444            AddrMgrEntry_t entry;
    445          
    446          
    447            // add entry
    448            entry.user    = ADDRMGR_USER_SECURITY;
    449            entry.nwkAddr = nwkAddr;
    450            AddrMgrExtAddrSet( entry.extAddr, extAddr );
    451          
    452            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
    453            {
    454              // return successful results
    455              *ami   = entry.index;
    456              status = ZSuccess;
    457            }
    458            else
    459            {
    460              // return failed results
    461              *ami   = entry.index;
    462              status = ZNwkUnknownDevice;
    463            }
    464          
    465            return status;
    466          }
    467          
    468          /******************************************************************************
    469           * @fn          ZDSecMgrExtAddrStore
    470           *
    471           * @brief       Store EXT address.
    472           *
    473           * @param       extAddr - [in] EXT address
    474           * @param       ami     - [out] Address Manager index
    475           *
    476           * @return      ZStatus_t
    477           */
    478          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
    479          {
    480            ZStatus_t      status;
    481            AddrMgrEntry_t entry;
    482          
    483          
    484            // add entry
    485            entry.user    = ADDRMGR_USER_SECURITY;
    486            entry.nwkAddr = nwkAddr;
    487            AddrMgrExtAddrSet( entry.extAddr, extAddr );
    488          
    489            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
    490            {
    491              // return successful results
    492              *ami   = entry.index;
    493              status = ZSuccess;
    494            }
    495            else
    496            {
    497              // return failed results
    498              *ami   = entry.index;
    499              status = ZNwkUnknownDevice;
    500            }
    501          
    502            return status;
    503          }
    504          
    505          /******************************************************************************
    506           * @fn          ZDSecMgrExtAddrLookup
    507           *
    508           * @brief       Lookup index for specified EXT address.
    509           *
    510           * @param       extAddr - [in] EXT address
    511           * @param       ami     - [out] Address Manager index
    512           *
    513           * @return      ZStatus_t
    514           */
    515          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
    516          {
    517            ZStatus_t      status;
    518            AddrMgrEntry_t entry;
    519          
    520          
    521            // lookup entry
    522            entry.user = ADDRMGR_USER_SECURITY;
    523            AddrMgrExtAddrSet( entry.extAddr, extAddr );
    524          
    525            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
    526            {
    527              // return successful results
    528              *ami   = entry.index;
    529              status = ZSuccess;
    530            }
    531            else
    532            {
    533              // return failed results
    534              *ami   = entry.index;
    535              status = ZNwkUnknownDevice;
    536            }
    537          
    538            return status;
    539          }
    540          
    541          /******************************************************************************
    542           * @fn          ZDSecMgrMasterKeyLookup
    543           *
    544           * @brief       Lookup MASTER key for specified address index.
    545           *
    546           * @param       ami - [in] Address Manager index
    547           * @param       pKeyNvId - [out] MASTER key NV ID
    548           *
    549           * @return      ZStatus_t
    550           */
    551          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId )
    552          {
    553            uint16 index;
    554            ZDSecMgrMasterKeyData_t masterKeyData;
    555          
    556            
    557            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
    558            {  
    559              // Read entry index of the Master key table from NV
    560              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    561                            sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
    562              
    563              if ( masterKeyData.ami == ami )
    564              {
    565                // return successful results
    566                *pKeyNvId   = ZCD_NV_MASTER_KEY_DATA_START + index;
    567                
    568                // clear copy of key in RAM
    569                osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
    570                
    571                return ZSuccess;
    572              }
    573            }
    574            
    575            *pKeyNvId = SEC_NO_KEY_NV_ID;
    576          
    577            // clear copy of key in RAM
    578            osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
    579          
    580            return ZNwkUnknownDevice;
    581          }
    582          
    583          /******************************************************************************
    584           * @fn          ZDSecMgrMasterKeyStore
    585           *
    586           * @brief       Store MASTER key for specified address index.
    587           *
    588           * @param       ami - [in] Address Manager index
    589           * @param       key - [in] valid key to store
    590           *
    591           * @return      ZStatus_t
    592           */
    593          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
    594          {
    595            uint16    index;
    596            ZDSecMgrMasterKeyData_t   masterKeyData;
    597            
    598          
    599            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
    600            {
    601              // Read entry index of the Master key table from NV
    602              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    603                             sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
    604          
    605              if ( masterKeyData.ami == INVALID_NODE_ADDR )
    606              {
    607                // store EXT address index
    608                masterKeyData.ami = ami;
    609          
    610                if ( key != NULL )
    611                {
    612                  osal_memcpy( masterKeyData.key, key,  SEC_KEY_LEN );
    613                }
    614                else
    615                {
    616                  osal_memset( masterKeyData.key, 0, SEC_KEY_LEN );
    617                }
    618          
    619                // set new values in NV      
    620                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    621                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
    622                 
    623                // clear copy of key in RAM
    624                osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
    625          
    626                // return successful results
    627                return ZSuccess;
    628              }
    629            }
    630            
    631            // clear copy of key in RAM
    632            osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
    633            
    634            return ZNwkUnknownDevice;
    635          }
    636          
    637          /******************************************************************************
    638           * @fn          ZDSecMgrEntryInit
    639           *
    640           * @brief       Initialize entry sub module
    641           *
    642           * @param       state - device initialization state
    643           *
    644           * @return      none
    645           */
    646          void ZDSecMgrEntryInit(uint8 state)
    647          {
    648            if (ZDSecMgrEntries == NULL)
    649            {
    650              uint16 index;
    651          
    652              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
    653              {
    654                return;
    655              }
    656          
    657              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
    658              {
    659                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
    660                
    661                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
    662              }
    663            }
    664          
    665          #if defined NV_RESTORE
    666            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    667            {
    668              ZDSecMgrRestoreFromNV();
    669            }
    670          #else
    671            (void)state;
    672          #endif
    673          }
    674          
    675          /******************************************************************************
    676           * @fn          ZDSecMgrEntryLookup
    677           *
    678           * @brief       Lookup entry index using specified NWK address.
    679           *
    680           * @param       nwkAddr - [in] NWK address
    681           * @param       entry   - [out] valid entry
    682           *
    683           * @return      ZStatus_t
    684           */
    685          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
    686          {
    687            ZStatus_t      status;
    688            uint16         index;
    689            AddrMgrEntry_t addrMgrEntry;
    690          
    691          
    692            // initialize results
    693            *entry = NULL;
    694            status = ZNwkUnknownDevice;
    695          
    696            // verify data is available
    697            if ( ZDSecMgrEntries != NULL )
    698            {
    699              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
    700              addrMgrEntry.nwkAddr = nwkAddr;
    701          
    702              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
    703              {
    704                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
    705                {
    706                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
    707                  {
    708                    // return successful results
    709                    *entry = &ZDSecMgrEntries[index];
    710                    status = ZSuccess;
    711          
    712                    // break from loop
    713                    return status;
    714                  }
    715                }
    716              }
    717            }
    718          
    719            return status;
    720          }
    721          
    722          /******************************************************************************
    723           * @fn          ZDSecMgrEntryLookupAMI
    724           *
    725           * @brief       Lookup entry using specified address index
    726           *
    727           * @param       ami   - [in] Address Manager index
    728           * @param       entry - [out] valid entry
    729           *
    730           * @return      ZStatus_t
    731           */
    732          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
    733          {
    734            ZStatus_t status;
    735            uint16    index;
    736          
    737          
    738            // initialize results
    739            *entry = NULL;
    740            status = ZNwkUnknownDevice;
    741          
    742            // verify data is available
    743            if ( ZDSecMgrEntries != NULL )
    744            {
    745              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
    746              {
    747                if ( ZDSecMgrEntries[index].ami == ami )
    748                {
    749                  // return successful results
    750                  *entry = &ZDSecMgrEntries[index];
    751                  status = ZSuccess;
    752          
    753                  // break from loop
    754                  return status;
    755                }
    756              }
    757            }
    758          
    759            return status;
    760          }
    761          
    762          /******************************************************************************
    763           * @fn          ZDSecMgrEntryLookupExt
    764           *
    765           * @brief       Lookup entry index using specified EXT address.
    766           *
    767           * @param       extAddr - [in] EXT address
    768           * @param       entry   - [out] valid entry
    769           *
    770           * @return      ZStatus_t
    771           */
    772          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
    773          {
    774            ZStatus_t status;
    775            uint16    ami;
    776          
    777          
    778            // initialize results
    779            *entry = NULL;
    780            status = ZNwkUnknownDevice;
    781          
    782            // lookup address index
    783            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
    784            {
    785              status = ZDSecMgrEntryLookupAMI( ami, entry );
    786            }
    787          
    788            return status;
    789          }
    790          
    791          /******************************************************************************
    792           * @fn          ZDSecMgrEntryLookupExtGetIndex
    793           *
    794           * @brief       Lookup entry index using specified EXT address.
    795           *
    796           * @param       extAddr - [in] EXT address
    797           * @param       entryIndex - [out] valid index to the entry table
    798           *
    799           * @return      ZStatus_t
    800           */
    801          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
    802          {
    803            ZStatus_t status;
    804            uint16    ami;
    805            uint16    index;
    806          
    807            // initialize results
    808            status = ZNwkUnknownDevice;
    809          
    810            // lookup address index
    811            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
    812            {  
    813              // verify data is available
    814              if ( ZDSecMgrEntries != NULL )
    815              {
    816                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
    817                {
    818                  if ( ZDSecMgrEntries[index].ami == ami )
    819                  {
    820                    // return successful results
    821                    *entry = &ZDSecMgrEntries[index];
    822                    *entryIndex = index;
    823                    status = ZSuccess;
    824                    
    825                    return status;
    826                  }
    827                }
    828              }
    829            }
    830          
    831            return status;
    832          }
    833          
    834          /******************************************************************************
    835           * @fn          ZDSecMgrEntryFree
    836           *
    837           * @brief       Free entry.
    838           *
    839           * @param       entry - [in] valid entry
    840           *
    841           * @return      ZStatus_t
    842           */
    843          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
    844          {
    845            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
    846            
    847            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
    848          
    849            if (pApsLinkKey != NULL)
    850            {
    851              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
    852          
    853              // Clear the APS Link key in NV
    854              osal_nv_write( entry->keyNvId, 0,
    855                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
    856          
    857              // set entry to invalid Key
    858              entry->keyNvId = SEC_NO_KEY_NV_ID;
    859              
    860              osal_mem_free(pApsLinkKey);
    861            }
    862          
    863            // marking the entry as INVALID_NODE_ADDR
    864            entry->ami = INVALID_NODE_ADDR;
    865          }
    866          
    867          /******************************************************************************
    868           * @fn          ZDSecMgrEntryNew
    869           *
    870           * @brief       Get a new entry.
    871           *
    872           * @param       entry - [out] valid entry
    873           *
    874           * @return      ZStatus_t
    875           */
    876          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
    877          {
    878            ZStatus_t status;
    879            uint16    index;
    880          
    881          
    882            // initialize results
    883            *entry = NULL;
    884            status = ZNwkUnknownDevice;
    885          
    886            // verify data is available
    887            if ( ZDSecMgrEntries != NULL )
    888            {
    889              // find available entry
    890              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
    891              {
    892                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
    893                {
    894                  // return successful result
    895                  *entry = &ZDSecMgrEntries[index];
    896                  status = ZSuccess;
    897          
    898                  // Set the authentication option to default
    899                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
    900          
    901                  // break from loop
    902                  index = ZDSECMGR_ENTRY_MAX;
    903                }
    904              }
    905            }
    906          
    907            return status;
    908          }
    909          
    910          /******************************************************************************
    911           * @fn          ZDSecMgrCtrlInit
    912           *
    913           * @brief       Initialize control sub module
    914           *
    915           * @param       none
    916           *
    917           * @return      none
    918           */
    919          void ZDSecMgrCtrlInit( void )
    920          {
    921            uint16 size;
    922            uint16 index;
    923          
    924            // allocate entry data
    925            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    926          
    927            ZDSecMgrCtrlData = osal_mem_alloc( size );
    928          
    929            // initialize data
    930            if ( ZDSecMgrCtrlData != NULL )
    931            {
    932              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
    933              {
    934                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
    935              }
    936            }
    937          }
    938          
    939          /******************************************************************************
    940           * @fn          ZDSecMgrCtrlRelease
    941           *
    942           * @brief       Release control data.
    943           *
    944           * @param       ctrl - [in] valid control data
    945           *
    946           * @return      none
    947           */
    948          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
    949          {
    950            // should always be enough entry control data
    951            ctrl->state = ZDSECMGR_CTRL_NONE;
    952          }
    953          
    954          /******************************************************************************
    955           * @fn          ZDSecMgrCtrlLookup
    956           *
    957           * @brief       Lookup control data.
    958           *
    959           * @param       entry - [in] valid entry data
    960           * @param       ctrl  - [out] control data - NULL if not found
    961           *
    962           * @return      none
    963           */
    964          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
    965          {
    966            uint16 index;
    967          
    968          
    969            // initialize search results
    970            *ctrl = NULL;
    971          
    972            // verify data is available
    973            if ( ZDSecMgrCtrlData != NULL )
    974            {
    975              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
    976              {
    977                // make sure control data is in use
    978                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
    979                {
    980                  // check for entry match
    981                  if ( ZDSecMgrCtrlData[index].entry == entry )
    982                  {
    983                    // return this control data
    984                    *ctrl = &ZDSecMgrCtrlData[index];
    985          
    986                    // break from loop
    987                    index = ZDSECMGR_CTRL_MAX;
    988                  }
    989                }
    990              }
    991            }
    992          }
    993          
    994          /******************************************************************************
    995           * @fn          ZDSecMgrCtrlSet
    996           *
    997           * @brief       Set control data.
    998           *
    999           * @param       device - [in] valid device data
   1000           * @param       entry  - [in] valid entry data
   1001           * @param       ctrl   - [in] valid control data
   1002           *
   1003           * @return      none
   1004           */
   1005          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   1006                                ZDSecMgrEntry_t*  entry,
   1007                                ZDSecMgrCtrl_t*   ctrl )
   1008          {
   1009            // set control date
   1010            ctrl->parentAddr = device->parentAddr;
   1011            ctrl->secure     = device->secure;
   1012            ctrl->entry      = entry;
   1013            ctrl->state      = ZDSECMGR_CTRL_INIT;
   1014            ctrl->cntr       = 0;
   1015          
   1016            // set device pointer
   1017            device->ctrl = ctrl;
   1018          }
   1019          
   1020          /******************************************************************************
   1021           * @fn          ZDSecMgrCtrlAdd
   1022           *
   1023           * @brief       Add control data.
   1024           *
   1025           * @param       device - [in] valid device data
   1026           * @param       entry  - [in] valid entry data
   1027           *
   1028           * @return      ZStatus_t
   1029           */
   1030          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   1031          {
   1032            ZStatus_t status;
   1033            uint16    index;
   1034          
   1035          
   1036            // initialize results
   1037            status = ZNwkUnknownDevice;
   1038          
   1039            // verify data is available
   1040            if ( ZDSecMgrCtrlData != NULL )
   1041            {
   1042              // look for an empty slot
   1043              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   1044              {
   1045                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   1046                {
   1047                  // return successful results
   1048                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   1049          
   1050                  status = ZSuccess;
   1051          
   1052                  // break from loop
   1053                  index = ZDSECMGR_CTRL_MAX;
   1054                }
   1055              }
   1056            }
   1057          
   1058            return status;
   1059          }
   1060          
   1061          /******************************************************************************
   1062           * @fn          ZDSecMgrCtrlTerm
   1063           *
   1064           * @brief       Terminate device control.
   1065           *
   1066           * @param       entry - [in] valid entry data
   1067           *
   1068           * @return      none
   1069           */
   1070          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   1071          {
   1072            ZDSecMgrCtrl_t* ctrl;
   1073          
   1074            // remove device from control data
   1075            ZDSecMgrCtrlLookup ( entry, &ctrl );
   1076          
   1077            if ( ctrl != NULL )
   1078            {
   1079              ZDSecMgrCtrlRelease ( ctrl );
   1080            }
   1081          }
   1082          
   1083          /******************************************************************************
   1084           * @fn          ZDSecMgrCtrlReset
   1085           *
   1086           * @brief       Reset control data.
   1087           *
   1088           * @param       device - [in] valid device data
   1089           * @param       entry  - [in] valid entry data
   1090           *
   1091           * @return      ZStatus_t
   1092           */
   1093          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   1094          {
   1095            ZStatus_t       status;
   1096            ZDSecMgrCtrl_t* ctrl;
   1097          
   1098          
   1099            // initialize results
   1100            status = ZNwkUnknownDevice;
   1101          
   1102            // look for a match for the entry
   1103            ZDSecMgrCtrlLookup( entry, &ctrl );
   1104          
   1105            if ( ctrl != NULL )
   1106            {
   1107              ZDSecMgrCtrlSet( device, entry, ctrl );
   1108          
   1109              status = ZSuccess;
   1110            }
   1111            else
   1112            {
   1113              status = ZDSecMgrCtrlAdd( device, entry );
   1114            }
   1115          
   1116            return status;
   1117          }
   1118          
   1119          /******************************************************************************
   1120           * @fn          ZDSecMgrMasterKeyLoad
   1121           *
   1122           * @brief       Load the MASTER key for device with specified EXT
   1123           *              address.
   1124           *
   1125           * @param       extAddr - [in] EXT address of device
   1126           * @param       key     - [in] MASTER key shared with device
   1127           *
   1128           * @return      ZStatus_t
   1129           */
   1130          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   1131          {
   1132            ZStatus_t status;
   1133            uint16 ami;
   1134            uint16 keyNvId;
   1135          
   1136          
   1137            // set status based on policy
   1138            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   1139          
   1140            if ( status == ZSuccess )
   1141            {
   1142              // get the address NV ID
   1143              if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) == ZSuccess )
   1144              {
   1145                // overwrite old key in NV
   1146                osal_nv_write( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   1147                               SEC_KEY_LEN, key );
   1148              }
   1149              else
   1150              {
   1151                // store new key -- NULL will zero key
   1152                status = ZDSecMgrMasterKeyStore( ami, key );
   1153              }
   1154            }
   1155          
   1156            return status;
   1157          }
   1158          
   1159          /******************************************************************************
   1160           * @fn          ZDSecMgrAppKeyGet
   1161           *
   1162           * @brief       get an APP key - option APP(MASTER or LINK) key
   1163           *
   1164           * @param       initNwkAddr - [in] NWK address of initiator device
   1165           * @param       initExtAddr - [in] EXT address of initiator device
   1166           * @param       partNwkAddr - [in] NWK address of partner device
   1167           * @param       partExtAddr - [in] EXT address of partner device
   1168           * @param       key         - [out] APP(MASTER or LINK) key
   1169           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1170           *
   1171           * @return      ZStatus_t
   1172           */
   1173          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   1174                                                           // to KEY_TYPE_APP_LINK since
   1175                                                           // only specific requirement
   1176                                                           // right now comes from SE profile
   1177          
   1178          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   1179                                       uint8*  initExtAddr,
   1180                                       uint16  partNwkAddr,
   1181                                       uint8*  partExtAddr,
   1182                                       uint8** key,
   1183                                       uint8*  keyType )
   1184          {
   1185            // Intentionally unreferenced parameters
   1186            (void)initNwkAddr;
   1187            (void)initExtAddr;
   1188            (void)partNwkAddr;
   1189            (void)partExtAddr;
   1190            
   1191            //---------------------------------------------------------------------------
   1192            // note:
   1193            // should use a robust mechanism to generate keys, for example
   1194            // combine EXT addresses and call a hash function
   1195            //---------------------------------------------------------------------------
   1196            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   1197          
   1198            *keyType = ZDSecMgrAppKeyType;
   1199          
   1200            return ZSuccess;
   1201          }
   1202          
   1203          /******************************************************************************
   1204           * @fn          ZDSecMgrAppKeyReq
   1205           *
   1206           * @brief       Process request for APP key between two devices.
   1207           *
   1208           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1209           *
   1210           * @return      none
   1211           */
   1212          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   1213          {
   1214            APSME_TransportKeyReq_t req;
   1215            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1216            uint16                  partNwkAddr;
   1217            uint8                   key[SEC_KEY_LEN];
   1218          
   1219          
   1220            // validate initiator and partner
   1221            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1222                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   1223            {
   1224              // point the key to some memory
   1225              req.key = key;
   1226          
   1227              // get an APP key - option APP (MASTER or LINK) key
   1228              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1229                                      initExtAddr,
   1230                                      partNwkAddr,
   1231                                      ind->partExtAddr,
   1232                                      &req.key,
   1233                                      &req.keyType ) == ZSuccess )
   1234              {
   1235                // always secure
   1236                req.nwkSecure = TRUE;
   1237                req.apsSecure = TRUE;
   1238                req.tunnel    = NULL;
   1239          
   1240                // send key to initiator device
   1241                req.dstAddr   = ind->srcAddr;
   1242                req.extAddr   = ind->partExtAddr;
   1243                req.initiator = TRUE;
   1244                APSME_TransportKeyReq( &req );
   1245          
   1246                // send key to partner device
   1247                req.dstAddr   = partNwkAddr;
   1248                req.extAddr   = initExtAddr;
   1249                req.initiator = FALSE;
   1250          
   1251                APSME_TransportKeyReq( &req );
   1252                
   1253                // clear copy of key in RAM
   1254                osal_memset( key, 0x00, SEC_KEY_LEN);
   1255          
   1256              }
   1257            }
   1258          }
   1259          
   1260          /******************************************************************************
   1261           * @fn          ZDSecMgrEstablishKey
   1262           *
   1263           * @brief       Start SKKE with device joining network.
   1264           *
   1265           * @param       device - [in] ZDSecMgrDevice_t, device info
   1266           *
   1267           * @return      ZStatus_t
   1268           */
   1269          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   1270          {
   1271            ZStatus_t               status;
   1272            APSME_EstablishKeyReq_t req;
   1273          
   1274          
   1275            req.respExtAddr = device->extAddr;
   1276            req.method      = APSME_SKKE_METHOD;
   1277          
   1278            if ( device->parentAddr == NLME_GetShortAddr() )
   1279            {
   1280              req.dstAddr   = device->nwkAddr;
   1281              //devtag.0604.todo - remove obsolete
   1282              req.apsSecure = FALSE;
   1283              req.nwkSecure = FALSE;
   1284            }
   1285            else
   1286            {
   1287              req.dstAddr   = device->parentAddr;
   1288              //devtag.0604.todo - remove obsolete
   1289              req.apsSecure = TRUE;
   1290              req.nwkSecure = TRUE;
   1291            }
   1292          
   1293            status = APSME_EstablishKeyReq( &req );
   1294          
   1295            return status;
   1296          }
   1297          
   1298          /******************************************************************************
   1299           * @fn          ZDSecMgrSendMasterKey
   1300           *
   1301           * @brief       Send MASTER key to device joining network.
   1302           *
   1303           * @param       device - [in] ZDSecMgrDevice_t, device info
   1304           *
   1305           * @return      ZStatus_t
   1306           */
   1307          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   1308          {
   1309            ZStatus_t status;
   1310            APSME_TransportKeyReq_t req;
   1311            uint16 keyNvId;
   1312            uint8 masterKey[SEC_KEY_LEN];
   1313          
   1314          
   1315            req.keyType = KEY_TYPE_TC_MASTER;
   1316            req.extAddr = device->extAddr;
   1317            req.tunnel  = NULL;
   1318          
   1319            if ( ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &keyNvId ) == ZSuccess )
   1320            {
   1321              osal_nv_read( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   1322                            SEC_KEY_LEN, masterKey );
   1323            }
   1324            else
   1325            {
   1326              // in case read from NV fails
   1327              osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   1328            }
   1329          
   1330            req.key = masterKey;
   1331          
   1332            //check if using secure hop to to parent
   1333            if ( device->parentAddr != NLME_GetShortAddr() )
   1334            {
   1335              //send to parent with security
   1336              req.dstAddr   = device->parentAddr;
   1337              req.nwkSecure = TRUE;
   1338              req.apsSecure = TRUE;
   1339            }
   1340            else
   1341            {
   1342              //direct with no security
   1343              req.dstAddr   = device->nwkAddr;
   1344              req.nwkSecure = FALSE;
   1345              req.apsSecure = FALSE;
   1346            }
   1347          
   1348            status = APSME_TransportKeyReq( &req );
   1349          
   1350            // clear copy of key in RAM
   1351            osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   1352          
   1353            return status;
   1354          }
   1355          
   1356          /******************************************************************************
   1357           * @fn          ZDSecMgrSendNwkKey
   1358           *
   1359           * @brief       Send NWK key to device joining network.
   1360           *
   1361           * @param       device - [in] ZDSecMgrDevice_t, device info
   1362           *
   1363           * @return      ZStatus_t
   1364           */
   1365          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   1366          {
   1367            ZStatus_t status;
   1368            APSME_TransportKeyReq_t req;
   1369            APSDE_FrameTunnel_t tunnel;
   1370            nwkKeyDesc tmpKey;
   1371              
   1372            req.dstAddr   = device->nwkAddr;
   1373            req.extAddr   = device->extAddr;
   1374          
   1375            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1376              req.keyType   = KEY_TYPE_NWK_HIGH;
   1377            else
   1378              req.keyType   = KEY_TYPE_NWK;
   1379          
   1380            // get the Active Key into a local variable 
   1381            if( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
   1382                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   1383            {
   1384              // set key data to all 0s if NV read fails
   1385              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   1386            }
   1387            
   1388            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1389                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1390            {
   1391              // set values
   1392              req.keySeqNum = tmpKey.keySeqNum;
   1393              req.key       = tmpKey.key;
   1394          
   1395              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1396              //key isn't used to secure the frame at the APS layer -- since the receiving
   1397              //device may not have a NWK key yet
   1398              req.apsSecure = TRUE;
   1399          
   1400              // check if using secure hop to to parent
   1401              if ( device->parentAddr == NLME_GetShortAddr() )
   1402              {
   1403                req.nwkSecure = FALSE;
   1404                req.tunnel    = NULL;
   1405              }
   1406              else
   1407              {
   1408                req.nwkSecure   = TRUE;
   1409                req.tunnel      = &tunnel;
   1410                req.tunnel->tna = device->parentAddr;
   1411                req.tunnel->dea = device->extAddr;
   1412              }
   1413            }
   1414            else
   1415            {
   1416              // default values
   1417              //devtag.0604.verify
   1418              req.nwkSecure = TRUE;
   1419              req.apsSecure = FALSE;
   1420              req.tunnel    = NULL;
   1421          
   1422              if ( device->parentAddr != NLME_GetShortAddr() )
   1423              {
   1424                req.dstAddr = device->parentAddr;
   1425              }
   1426          
   1427              // special cases
   1428              //devtag.0604.todo - modify to preconfig flag
   1429              if ( device->secure == FALSE )
   1430              {
   1431                req.keySeqNum = tmpKey.keySeqNum;
   1432                req.key       = tmpKey.key;
   1433          
   1434                // check if using secure hop to to parent
   1435                if ( device->parentAddr == NLME_GetShortAddr() )
   1436                {
   1437                  req.nwkSecure = FALSE;
   1438                }
   1439              }
   1440              else
   1441              {
   1442                req.key       = NULL;
   1443                req.keySeqNum = 0;
   1444              }
   1445            }
   1446          
   1447            status = APSME_TransportKeyReq( &req );
   1448          
   1449            // clear copy of key in RAM before return
   1450            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   1451          
   1452            return status;
   1453          }
   1454          
   1455          /******************************************************************************
   1456           * @fn          ZDSecMgrDeviceEntryRemove
   1457           *
   1458           * @brief       Remove device entry.
   1459           *
   1460           * @param       entry - [in] valid entry
   1461           *
   1462           * @return      none
   1463           */
   1464          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   1465          {
   1466            // terminate device control
   1467            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1468            {
   1469              ZDSecMgrCtrlTerm( entry );
   1470            }
   1471          
   1472            // remove device from entry data
   1473            ZDSecMgrEntryFree( entry );
   1474          
   1475            // remove EXT address
   1476            //ZDSecMgrExtAddrRelease( aiOld );
   1477          }
   1478          
   1479          /******************************************************************************
   1480           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1481           *
   1482           * @brief       Remove device entry by its ext address.
   1483           *
   1484           * @param       pAddr - pointer to the extended address
   1485           *
   1486           * @return      ZStatus_t
   1487           */
   1488          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   1489          {
   1490            ZDSecMgrEntry_t *pEntry;
   1491            uint8           retValue;
   1492            
   1493            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   1494            
   1495            if( retValue == ZSuccess )
   1496            {
   1497              ZDSecMgrDeviceEntryRemove( pEntry );
   1498            }
   1499            
   1500            return retValue;
   1501          }
   1502          
   1503          /******************************************************************************
   1504           * @fn          ZDSecMgrDeviceEntryAdd
   1505           *
   1506           * @brief       Add entry.
   1507           *
   1508           * @param       device - [in] ZDSecMgrDevice_t, device info
   1509           * @param       ami    - [in] Address Manager index
   1510           *
   1511           * @return      ZStatus_t
   1512           */
   1513          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   1514          {
   1515            AddrMgrEntry_t entry;
   1516          
   1517            // get the ami data
   1518            entry.user  = ADDRMGR_USER_SECURITY;
   1519            entry.index = ami;
   1520          
   1521            AddrMgrEntryGet( &entry );
   1522          
   1523            // check if NWK address is same
   1524            if ( entry.nwkAddr != nwkAddr )
   1525            {
   1526              // update NWK address
   1527              entry.nwkAddr = nwkAddr;
   1528          
   1529              AddrMgrEntryUpdate( &entry );
   1530            }
   1531          }
   1532          
   1533          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   1534          {
   1535            ZStatus_t        status;
   1536            ZDSecMgrEntry_t* entry;
   1537          
   1538          
   1539            // initialize as unknown until completion
   1540            status = ZNwkUnknownDevice;
   1541          
   1542            device->ctrl = NULL;
   1543          
   1544            // make sure not already registered
   1545            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   1546            {
   1547              // verify that address index is same
   1548              if ( entry->ami != ami )
   1549              {
   1550                // remove conflicting entry
   1551                ZDSecMgrDeviceEntryRemove( entry );
   1552          
   1553                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   1554                {
   1555                  // update NWK address
   1556                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1557                }
   1558              }
   1559            }
   1560            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   1561            {
   1562              // update NWK address
   1563              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1564            }
   1565          
   1566            // check if a new entry needs to be created
   1567            if ( entry == NULL )
   1568            {
   1569              // get new entry
   1570              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   1571              {
   1572                // reset entry lkd
   1573          
   1574                // finish setting up entry
   1575                entry->ami = ami;
   1576          
   1577                // update NWK address
   1578                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1579          
   1580                // enter new device into device control
   1581                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1582                {
   1583                  status = ZDSecMgrCtrlAdd( device, entry );
   1584                }
   1585                else
   1586                {
   1587                  status = ZSuccess;
   1588                }
   1589              }
   1590            }
   1591            else
   1592            {
   1593              // reset entry lkd
   1594          
   1595              // reset entry in entry control
   1596              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1597              {
   1598                status = ZDSecMgrCtrlReset( device, entry );
   1599              }
   1600              else
   1601              {
   1602                status = ZSuccess;
   1603              }
   1604            }
   1605          
   1606            return status;
   1607          }
   1608          
   1609          /******************************************************************************
   1610           * @fn          ZDSecMgrDeviceCtrlHandler
   1611           *
   1612           * @brief       Device control handler.
   1613           *
   1614           * @param       device - [in] ZDSecMgrDevice_t, device info
   1615           *
   1616           * @return      none
   1617           */
   1618          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   1619          {
   1620            uint8 state;
   1621            uint8 cntr;
   1622          
   1623          
   1624            state = device->ctrl->state;
   1625            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1626          
   1627            switch ( state )
   1628            {
   1629              case ZDSECMGR_CTRL_TK_MASTER:
   1630                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   1631                {
   1632                  state = ZDSECMGR_CTRL_SKKE_INIT;
   1633                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   1634                }
   1635                break;
   1636          
   1637              case ZDSECMGR_CTRL_SKKE_INIT:
   1638                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   1639                {
   1640                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   1641                }
   1642                break;
   1643          
   1644              case ZDSECMGR_CTRL_SKKE_WAIT:
   1645                // continue to wait for SKA control timeout
   1646                break;
   1647          
   1648              case ZDSECMGR_CTRL_TK_NWK:
   1649                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   1650                {
   1651                  state = ZDSECMGR_CTRL_NONE;
   1652                }
   1653                break;
   1654          
   1655              default:
   1656                state = ZDSECMGR_CTRL_NONE;
   1657                break;
   1658            }
   1659          
   1660            if ( state != ZDSECMGR_CTRL_NONE )
   1661            {
   1662              device->ctrl->state = state;
   1663              device->ctrl->cntr  = cntr;
   1664          
   1665              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   1666            }
   1667            else
   1668            {
   1669              ZDSecMgrCtrlRelease( device->ctrl );
   1670            }
   1671          }
   1672          
   1673          /******************************************************************************
   1674           * @fn          ZDSecMgrDeviceCtrlSetup
   1675           *
   1676           * @brief       Setup device control.
   1677           *
   1678           * @param       device - [in] ZDSecMgrDevice_t, device info
   1679           *
   1680           * @return      ZStatus_t
   1681           */
   1682          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   1683          {
   1684            if ( device->ctrl != NULL )
   1685            {
   1686              if ( device->secure == FALSE )
   1687              {
   1688                // send the master key data to the joining device
   1689                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   1690              }
   1691              else
   1692              {
   1693                // start SKKE
   1694                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   1695              }
   1696          
   1697              ZDSecMgrDeviceCtrlHandler( device );
   1698            }
   1699          }
   1700          
   1701          /******************************************************************************
   1702           * @fn          ZDSecMgrDeviceCtrlUpdate
   1703           *
   1704           * @brief       Update control data.
   1705           *
   1706           * @param       extAddr - [in] EXT address
   1707           * @param       state   - [in] new control state
   1708           *
   1709           * @return      none
   1710           */
   1711          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   1712          {
   1713            ZDSecMgrEntry_t* entry;
   1714            ZDSecMgrCtrl_t*  ctrl;
   1715          
   1716          
   1717            // lookup device entry data
   1718            ZDSecMgrEntryLookupExt( extAddr, &entry );
   1719          
   1720            if ( entry != NULL )
   1721            {
   1722              // lookup device control data
   1723              ZDSecMgrCtrlLookup( entry, &ctrl );
   1724          
   1725              // make sure control data is valid
   1726              if ( ctrl != NULL )
   1727              {
   1728                // possible state transitions
   1729                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   1730                {
   1731                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   1732                  {
   1733                    // send the network key
   1734                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   1735                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1736                  }
   1737                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   1738                  {
   1739                    // force default timeout in order to cleanup control logic
   1740                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   1741                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1742                  }
   1743                }
   1744                // timer should be active
   1745              }
   1746            }
   1747          }
   1748          
   1749          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );
   1750          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   1751          {
   1752            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1753            {
   1754              if ( initiator == TRUE )
   1755              {
   1756                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1757              }
   1758            }
   1759          }
   1760          
   1761          /******************************************************************************
   1762           * @fn          ZDSecMgrDeviceRemove
   1763           *
   1764           * @brief       Remove device from network.
   1765           *
   1766           * @param       device - [in] ZDSecMgrDevice_t, device info
   1767           *
   1768           * @return      none
   1769           */
   1770          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   1771          {
   1772            APSME_RemoveDeviceReq_t remDevReq;
   1773            NLME_LeaveReq_t         leaveReq;
   1774            associated_devices_t*   assoc;
   1775          
   1776          
   1777            // check if parent, remove the device
   1778            if ( device->parentAddr == NLME_GetShortAddr() )
   1779            {
   1780              // this is the parent of the device
   1781              leaveReq.extAddr        = device->extAddr;
   1782              leaveReq.removeChildren = FALSE;
   1783              leaveReq.rejoin         = FALSE;
   1784          
   1785              // find child association
   1786              assoc = AssocGetWithExt( device->extAddr );
   1787          
   1788              if ( ( assoc != NULL                            ) &&
   1789                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1790                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   1791              {
   1792                // check if associated device is authenticated
   1793                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   1794                {
   1795                  leaveReq.silent = FALSE;
   1796                }
   1797                else
   1798                {
   1799                  leaveReq.silent = TRUE;
   1800                }
   1801          
   1802                NLME_LeaveReq( &leaveReq );
   1803              }
   1804            }
   1805            else
   1806            {
   1807              // this is not the parent of the device
   1808              remDevReq.parentAddr   = device->parentAddr;
   1809              remDevReq.childExtAddr = device->extAddr;
   1810          
   1811              APSME_RemoveDeviceReq( &remDevReq );
   1812            }
   1813          }
   1814          
   1815          /******************************************************************************
   1816           * @fn          ZDSecMgrDeviceValidateSKKE
   1817           *
   1818           * @brief       Decide whether device is allowed for SKKE.
   1819           *
   1820           * @param       device - [in] ZDSecMgrDevice_t, device info
   1821           *
   1822           * @return      ZStatus_t
   1823           */
   1824          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   1825          {
   1826            ZStatus_t status;
   1827            uint16 ami;
   1828            uint16 keyNvId;
   1829          
   1830          
   1831            // get EXT address
   1832            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1833          
   1834            if ( status == ZSuccess )
   1835            {
   1836              // get MASTER key
   1837              status = ZDSecMgrMasterKeyLookup( ami, &keyNvId );
   1838          
   1839              if ( status == ZSuccess )
   1840              {
   1841                status = ZDSecMgrDeviceEntryAdd( device, ami );
   1842              }
   1843            }
   1844          
   1845            return status;
   1846          }
   1847          
   1848          /******************************************************************************
   1849           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1850           *
   1851           * @brief       Decide whether device is allowed.
   1852           *
   1853           * @param       device - [in] ZDSecMgrDevice_t, device info
   1854           *
   1855           * @return      ZStatus_t
   1856           */
   1857          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   1858          {
   1859          
   1860            ZStatus_t status;
   1861            status = ZSuccess;
   1862          
   1863            (void)device;  // Intentionally unreferenced parameter
   1864            
   1865            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1866            // the trust center to reject any newly joining devices by sending
   1867            // Remove-device to the parents.
   1868            if ( zgSecurePermitJoin == false )
   1869            {
   1870              status = ZNwkUnknownDevice;
   1871            }
   1872          
   1873          
   1874          
   1875          #if 0  // Taken out because the following functionality is only used for test
   1876                 // purpose. A more efficient (above) way is used. It can be put
   1877                 // back in if customers request for a white/black list feature.
   1878                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1879          
   1880            // The following code processes the device black list (stored device list)
   1881            // If the joining device is not part of the forbidden device list
   1882            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1883            // will send Remove-device and ban the device from joining.
   1884          
   1885            uint8     index;
   1886            uint8*    restricted;
   1887          
   1888            // Look through the stored device list - used for restricted devices
   1889            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1890            {
   1891              restricted = ZDSecMgrStoredDeviceList[index];
   1892          
   1893              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1894              {
   1895                // return as unknown device in regards to validation
   1896                status = ZNwkUnknownDevice;
   1897          
   1898                // break from loop
   1899                index = ZDSECMGR_STORED_DEVICES;
   1900              }
   1901            }
   1902          
   1903          #endif
   1904          
   1905            return status;
   1906          }
   1907          
   1908          /******************************************************************************
   1909           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1910           *
   1911           * @brief       Decide whether device is allowed.
   1912           *
   1913           * @param       device - [in] ZDSecMgrDevice_t, device info
   1914           *
   1915           * @return      ZStatus_t
   1916           */
   1917          //devtag.pro.security
   1918          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   1919          {
   1920            ZStatus_t status;
   1921            uint16    ami;
   1922            uint8     key[SEC_KEY_LEN];
   1923          
   1924          
   1925            // implement EXT address and MASTER key policy here -- the total number of
   1926            // Security Manager entries should never exceed the number of EXT addresses
   1927            // and MASTER keys available
   1928            
   1929            // set status based on policy
   1930            //status = ZNwkUnknownDevice;
   1931            
   1932            // set status based on policy
   1933            status = ZSuccess; // ZNwkUnknownDevice;
   1934            
   1935            // get key based on policy
   1936            osal_memcpy( key, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   1937            
   1938            // if policy, store new EXT address
   1939            status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   1940            
   1941            // set the key
   1942            ZDSecMgrMasterKeyLoad( device->extAddr, key );
   1943            
   1944            // if EXT address and MASTER key available -- add device
   1945            if ( status == ZSuccess )
   1946            {
   1947              // add device to internal data - with control
   1948              status = ZDSecMgrDeviceEntryAdd( device, ami );
   1949            }
   1950          
   1951            // remove copy of key in RAM  
   1952            osal_memset( key, 0x00, SEC_KEY_LEN );
   1953          
   1954            return status;
   1955          }
   1956          
   1957          /******************************************************************************
   1958           * @fn          ZDSecMgrDeviceValidate
   1959           *
   1960           * @brief       Decide whether device is allowed.
   1961           *
   1962           * @param       device - [in] ZDSecMgrDevice_t, device info
   1963           *
   1964           * @return      ZStatus_t
   1965           */
   1966          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   1967          {
   1968            ZStatus_t status;
   1969          
   1970          
   1971            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   1972            {
   1973              // device may be joining with a secure flag but it is ultimately the Trust
   1974              // Center that decides -- check if expected pre configured device --
   1975              // override settings
   1976              if ( zgPreConfigKeys == TRUE )
   1977              {
   1978                device->secure = TRUE;
   1979              }
   1980              else
   1981              {
   1982                device->secure = FALSE;
   1983              }
   1984          
   1985              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1986              {
   1987                status = ZDSecMgrDeviceValidateCM( device );
   1988              }
   1989              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1990              {
   1991                status = ZDSecMgrDeviceValidateRM( device );
   1992              }
   1993            }
   1994            else
   1995            {
   1996              status = ZNwkUnknownDevice;
   1997            }
   1998          
   1999            return status;
   2000          }
   2001          
   2002          /******************************************************************************
   2003           * @fn          ZDSecMgrDeviceJoin
   2004           *
   2005           * @brief       Try to join this device.
   2006           *
   2007           * @param       device - [in] ZDSecMgrDevice_t, device info
   2008           *
   2009           * @return      ZStatus_t
   2010           */
   2011          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   2012          {
   2013            ZStatus_t status;
   2014            uint16    ami;
   2015          
   2016            // attempt to validate device
   2017            status = ZDSecMgrDeviceValidate( device );
   2018          
   2019            if ( status == ZSuccess )
   2020            {
   2021              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2022              {
   2023                ZDSecMgrDeviceCtrlSetup( device );
   2024              }
   2025              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2026              {
   2027                // Add the device to the address manager
   2028                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   2029                //send the nwk key data to the joining device
   2030                status = ZDSecMgrSendNwkKey( device );
   2031              }
   2032            }
   2033            else
   2034            {
   2035              // not allowed, remove the device
   2036              ZDSecMgrDeviceRemove( device );
   2037            }
   2038          
   2039            return status;
   2040          }
   2041          
   2042          /******************************************************************************
   2043           * @fn          ZDSecMgrDeviceJoinDirect
   2044           *
   2045           * @brief       Try to join this device as a direct child.
   2046           *
   2047           * @param       device - [in] ZDSecMgrDevice_t, device info
   2048           *
   2049           * @return      ZStatus_t
   2050           */
   2051          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   2052          {
   2053            ZStatus_t status;
   2054          
   2055            status = ZDSecMgrDeviceJoin( device );
   2056          
   2057            if ( status == ZSuccess )
   2058            {
   2059              // set association status to authenticated
   2060              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   2061            }
   2062          
   2063            return status;
   2064          }
   2065          
   2066          /******************************************************************************
   2067           * @fn          ZDSecMgrDeviceJoinFwd
   2068           *
   2069           * @brief       Forward join to Trust Center.
   2070           *
   2071           * @param       device - [in] ZDSecMgrDevice_t, device info
   2072           *
   2073           * @return      ZStatus_t
   2074           */
   2075          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   2076          {
   2077            ZStatus_t               status;
   2078            APSME_UpdateDeviceReq_t req;
   2079          
   2080          
   2081            // forward any joining device to the Trust Center -- the Trust Center will
   2082            // decide if the device is allowed to join
   2083            status = ZSuccess;
   2084          
   2085            // forward authorization to the Trust Center
   2086            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   2087            req.devAddr    = device->nwkAddr;
   2088            req.devExtAddr = device->extAddr;
   2089          
   2090            // set security status, option for router to reject if policy set
   2091            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   2092            {
   2093              if ( device->devStatus & DEV_REJOIN_STATUS )
   2094              {
   2095                if ( device->secure == TRUE )
   2096                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   2097                else
   2098                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   2099              }
   2100              else
   2101                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   2102            }
   2103            else
   2104            {
   2105              if ( device->devStatus & DEV_REJOIN_STATUS )
   2106              {
   2107                if ( device->secure == TRUE )
   2108                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   2109                else
   2110                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   2111              }
   2112              else
   2113                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   2114            }
   2115          
   2116            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2117              req.apsSecure = TRUE;
   2118            else
   2119              req.apsSecure = FALSE;
   2120          
   2121            // send and APSME_UPDATE_DEVICE request to the trust center
   2122            status = APSME_UpdateDeviceReq( &req );
   2123          
   2124            return status;
   2125          }
   2126          
   2127          /******************************************************************************
   2128           * @fn          ZDSecMgrDeviceNew
   2129           *
   2130           * @brief       Process a new device.
   2131           *
   2132           * @param       device - [in] ZDSecMgrDevice_t, device info
   2133           *
   2134           * @return      ZStatus_t
   2135           */
   2136          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   2137          {
   2138            ZStatus_t status;
   2139          
   2140            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2141            {
   2142              // try to join this device
   2143              status = ZDSecMgrDeviceJoinDirect( joiner );
   2144            }
   2145            else
   2146            {
   2147              status = ZDSecMgrDeviceJoinFwd( joiner );
   2148            }
   2149          
   2150            return status;
   2151          }
   2152          
   2153          /******************************************************************************
   2154           * @fn          ZDSecMgrAssocDeviceAuth
   2155           *
   2156           * @brief       Set associated device status to authenticated
   2157           *
   2158           * @param       assoc - [in, out] associated_devices_t
   2159           *
   2160           * @return      none
   2161           */
   2162          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   2163          {
   2164            if ( assoc != NULL )
   2165            {
   2166              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   2167            }
   2168          }
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrAuthInitiate
   2172           *
   2173           * @brief       Initiate entity authentication
   2174           *
   2175           * @param       responder - [in] responder EXT address
   2176           *
   2177           * @return      none
   2178           */
   2179          void ZDSecMgrAuthInitiate( uint8* responder )
   2180          {
   2181            APSME_AuthenticateReq_t req;
   2182          
   2183          
   2184            // make sure NWK address is available
   2185            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   2186            {
   2187              // set request fields
   2188              req.extAddr   = responder;
   2189              req.action    = APSME_EA_INITIATE;
   2190              req.challenge = NULL;
   2191          
   2192              // start EA processing
   2193              APSME_AuthenticateReq( &req );
   2194            }
   2195          }
   2196          
   2197          /******************************************************************************
   2198           * @fn          ZDSecMgrAuthNwkKey
   2199           *
   2200           * @brief       Handle next step in authentication process
   2201           *
   2202           * @param       none
   2203           *
   2204           * @return      none
   2205           */
   2206          void ZDSecMgrAuthNwkKey()
   2207          {
   2208            if ( devState == DEV_END_DEVICE_UNAUTH )
   2209            {
   2210              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2211              {
   2212                uint8 parent[Z_EXTADDR_LEN];
   2213          
   2214                // get parent's EXT address
   2215                NLME_GetCoordExtAddr( parent );
   2216          
   2217                // begin entity authentication with parent
   2218                ZDSecMgrAuthInitiate( parent );
   2219              }
   2220              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2221              {
   2222                // inform ZDO that device has been authenticated
   2223                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2224              }
   2225            }
   2226          }
   2227          
   2228          /******************************************************************************
   2229           * PUBLIC FUNCTIONS
   2230           */
   2231          /******************************************************************************
   2232           * @fn          ZDSecMgrInit
   2233           *
   2234           * @brief       Initialize ZigBee Device Security Manager.
   2235           *
   2236           * @param       state - device initialization state
   2237           *
   2238           * @return      none
   2239           */
   2240          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2241          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2242          void ZDSecMgrAddrMgrCB( uint8           update,
   2243                                  AddrMgrEntry_t* newEntry,
   2244                                  AddrMgrEntry_t* oldEntry )
   2245          {
   2246            (void)update;
   2247            (void)newEntry;
   2248            (void)oldEntry;
   2249          }
   2250          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2251          
   2252          void ZDSecMgrInit(uint8 state)
   2253          {
   2254            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2255                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2256            {
   2257              // initialize sub modules
   2258              ZDSecMgrEntryInit(state);
   2259          
   2260              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2261              {
   2262                ZDSecMgrCtrlInit();
   2263              }
   2264          
   2265              // register with Address Manager
   2266              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2267              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2268              #endif
   2269            }
   2270          
   2271            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2272            {
   2273              // configure SKA slot data
   2274              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2275            }
   2276            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2277            {
   2278              APSME_TCAddrSetup( zgTrustCenterAddr );    
   2279            }
   2280          
   2281            if ( ZG_SECURE_ENABLED )
   2282            {
   2283              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2284              {
   2285                // setup joining permissions
   2286                ZDSecMgrPermitJoiningEnabled = TRUE;
   2287                ZDSecMgrPermitJoiningTimed   = FALSE;
   2288              }
   2289            }
   2290          
   2291            
   2292            // configure security based on security mode and type of device
   2293            ZDSecMgrConfig();
   2294          }
   2295          
   2296          /******************************************************************************
   2297           * @fn          ZDSecMgrConfig
   2298           *
   2299           * @brief       Configure ZigBee Device Security Manager.
   2300           *
   2301           * @param       none
   2302           *
   2303           * @return      none
   2304           */
   2305          void ZDSecMgrConfig( void )
   2306          {
   2307            if ( ZG_SECURE_ENABLED )
   2308            {
   2309              SSP_Init();
   2310          
   2311              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2312                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2313              {
   2314                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2315                {
   2316                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2317                  APSME_SecurityCM_CD();
   2318                }
   2319                else if ( ZSTACK_ROUTER_BUILD )
   2320                {
   2321                  // COMMERCIAL MODE - ROUTER DEVICE
   2322                  APSME_SecurityCM_RD();
   2323                }
   2324                else
   2325                {
   2326                  // COMMERCIAL MODE - END DEVICE
   2327                  APSME_SecurityCM_ED();
   2328                }
   2329              }
   2330              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2331              {
   2332                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2333                {
   2334                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2335                  APSME_SecurityRM_CD();
   2336                }
   2337                else if ( ZSTACK_ROUTER_BUILD )
   2338                {
   2339                  // RESIDENTIAL MODE - ROUTER DEVICE
   2340                  APSME_SecurityRM_RD();
   2341                }
   2342                else
   2343                {
   2344                  // RESIDENTIAL MODE - END DEVICE
   2345                  APSME_SecurityRM_ED();
   2346                }
   2347              }
   2348            }
   2349            else
   2350            {
   2351              // NO SECURITY
   2352              APSME_SecurityNM();
   2353            }
   2354          }
   2355          
   2356          /******************************************************************************
   2357           * @fn          ZDSecMgrPermitJoining
   2358           *
   2359           * @brief       Process request to change joining permissions.
   2360           *
   2361           * @param       duration - [in] timed duration for join in seconds
   2362           *                         - 0x00 not allowed
   2363           *                         - 0xFF allowed without timeout
   2364           *
   2365           * @return      uint8 - success(TRUE:FALSE)
   2366           */
   2367          uint8 ZDSecMgrPermitJoining( uint8 duration )
   2368          {
   2369            uint8 accept;
   2370          
   2371          
   2372            ZDSecMgrPermitJoiningTimed = FALSE;
   2373          
   2374            if ( duration > 0 )
   2375            {
   2376              ZDSecMgrPermitJoiningEnabled = TRUE;
   2377          
   2378              if ( duration != 0xFF )
   2379              {
   2380                ZDSecMgrPermitJoiningTimed = TRUE;
   2381              }
   2382            }
   2383            else
   2384            {
   2385              ZDSecMgrPermitJoiningEnabled = FALSE;
   2386            }
   2387          
   2388            accept = TRUE;
   2389          
   2390            return accept;
   2391          }
   2392          
   2393          /******************************************************************************
   2394           * @fn          ZDSecMgrPermitJoiningTimeout
   2395           *
   2396           * @brief       Process permit joining timeout
   2397           *
   2398           * @param       none
   2399           *
   2400           * @return      none
   2401           */
   2402          void ZDSecMgrPermitJoiningTimeout( void )
   2403          {
   2404            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   2405            {
   2406              ZDSecMgrPermitJoiningEnabled = FALSE;
   2407              ZDSecMgrPermitJoiningTimed   = FALSE;
   2408            }
   2409          }
   2410          
   2411          /******************************************************************************
   2412           * @fn          ZDSecMgrNewDeviceEvent
   2413           *
   2414           * @brief       Process a the new device event, if found reset new device
   2415           *              event/timer.
   2416           *
   2417           * @param       none
   2418           *
   2419           * @return      uint8 - found(TRUE:FALSE)
   2420           */
   2421          uint8 ZDSecMgrNewDeviceEvent( void )
   2422          {
   2423            uint8                 found;
   2424            ZDSecMgrDevice_t      device;
   2425            AddrMgrEntry_t        addrEntry;
   2426            associated_devices_t* assoc;
   2427            ZStatus_t             status;
   2428          
   2429            // initialize return results
   2430            found = FALSE;
   2431          
   2432            // look for device in the security init state
   2433            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   2434          
   2435            if ( assoc != NULL )
   2436            {
   2437              // device found
   2438              found = TRUE;
   2439          
   2440              // check for preconfigured security
   2441              if ( zgPreConfigKeys == TRUE )
   2442              {
   2443                // set association status to authenticated
   2444                ZDSecMgrAssocDeviceAuth( assoc );
   2445              }
   2446          
   2447              // set up device info
   2448              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   2449              addrEntry.index = assoc->addrIdx;
   2450              AddrMgrEntryGet( &addrEntry );
   2451          
   2452              device.nwkAddr    = assoc->shortAddr;
   2453              device.extAddr    = addrEntry.extAddr;
   2454              device.parentAddr = NLME_GetShortAddr();
   2455              device.secure     = FALSE;
   2456              device.devStatus  = assoc->devStatus;
   2457          
   2458              // process new device
   2459              status = ZDSecMgrDeviceNew( &device );
   2460          
   2461              if ( status == ZSuccess )
   2462              {
   2463                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   2464              }
   2465              else if ( status == ZNwkUnknownDevice )
   2466              {
   2467                AssocRemove( addrEntry.extAddr );
   2468              }
   2469            }
   2470          
   2471            return found;
   2472          }
   2473          
   2474          /******************************************************************************
   2475           * @fn          ZDSecMgrEvent
   2476           *
   2477           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2478           *
   2479           * @param       none
   2480           *
   2481           * @return      none
   2482           */
   2483          void ZDSecMgrEvent( void )
   2484          {
   2485            uint8            action;
   2486            uint8            restart;
   2487            uint16           index;
   2488            AddrMgrEntry_t   entry;
   2489            ZDSecMgrDevice_t device;
   2490          
   2491          
   2492            // verify data is available
   2493            if ( ZDSecMgrCtrlData != NULL )
   2494            {
   2495              action  = FALSE;
   2496              restart = FALSE;
   2497          
   2498              // update all the counters
   2499              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   2500              {
   2501                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   2502                {
   2503                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   2504                  {
   2505                    ZDSecMgrCtrlData[index].cntr--;
   2506                  }
   2507          
   2508                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   2509                  {
   2510                    action = TRUE;
   2511          
   2512                    // update from control data
   2513                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   2514                    device.secure     = ZDSecMgrCtrlData[index].secure;
   2515                    device.ctrl       = &ZDSecMgrCtrlData[index];
   2516          
   2517                    // set the user and address index
   2518                    entry.user  = ADDRMGR_USER_SECURITY;
   2519                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   2520          
   2521                    // get the address data
   2522                    AddrMgrEntryGet( &entry );
   2523          
   2524                    // set device address data
   2525                    device.nwkAddr = entry.nwkAddr;
   2526                    device.extAddr = entry.extAddr;
   2527          
   2528                    // update from entry data
   2529                    ZDSecMgrDeviceCtrlHandler( &device );
   2530                  }
   2531                  else
   2532                  {
   2533                    restart = TRUE;
   2534                  }
   2535                }
   2536              }
   2537          
   2538              // check for timer restart
   2539              if ( restart == TRUE )
   2540              {
   2541                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   2542              }
   2543            }
   2544          }
   2545          
   2546          /******************************************************************************
   2547           * @fn          ZDSecMgrEstablishKeyCfm
   2548           *
   2549           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2550           *
   2551           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2552           *
   2553           * @return      none
   2554           */
   2555          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   2556          {
   2557            // send the NWK key
   2558            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2559            {
   2560              // update control for specified EXT address
   2561              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2562            }
   2563            else
   2564            {
   2565              // this should be done when receiving the NWK key
   2566              // if devState ==
   2567              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2568                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2569          
   2570              // if not in joining state -- this should trigger an event for an
   2571              // end point that requested SKKE
   2572              // if ( devState == DEV_END_DEVICE )
   2573             //       devState == DEV_ROUTER;
   2574          
   2575            }
   2576          }
   2577          
   2578          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );
   2579          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   2580          {
   2581            uint8  match;
   2582            uint8  lookup[Z_EXTADDR_LEN];
   2583          
   2584            match = FALSE;
   2585          
   2586            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   2587            {
   2588              match = AddrMgrExtAddrEqual( lookup, extAddr );
   2589            }
   2590          
   2591            return match;
   2592          }
   2593          
   2594          void ZDSecMgrTCDataLoad( uint8* extAddr );
   2595          void ZDSecMgrTCDataLoad( uint8* extAddr )
   2596          {
   2597            uint16 ami;
   2598            uint16 keyNvId;   
   2599            uint8 masterKey[SEC_KEY_LEN];
   2600          
   2601            if ( !ZDSecMgrTCDataLoaded )
   2602            {
   2603              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   2604              {
   2605                // if preconfigured load key
   2606                if ( zgPreConfigKeys == TRUE )
   2607                {
   2608                  if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) != ZSuccess )
   2609                  {
   2610                    // temporary copy
   2611                    osal_memcpy( masterKey, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   2612          
   2613                    ZDSecMgrMasterKeyStore( ami, masterKey );
   2614                      
   2615                    // remove copy of key in RAM  
   2616                    osal_memset( masterKey, 0x00, SEC_KEY_LEN );
   2617                  }
   2618                }
   2619              }
   2620          
   2621              ZDSecMgrTCDataLoaded = TRUE;
   2622            }
   2623          }
   2624          
   2625          /******************************************************************************
   2626           * @fn          ZDSecMgrEstablishKeyInd
   2627           *
   2628           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2629           *
   2630           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2631           *
   2632           * @return      none
   2633           */
   2634          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2635          {
   2636            ZDSecMgrDevice_t        device;
   2637            APSME_EstablishKeyRsp_t rsp;
   2638          
   2639          
   2640            // load Trust Center data if needed
   2641            ZDSecMgrTCDataLoad( ind->initExtAddr );
   2642          
   2643            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   2644            {
   2645              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2646              //OR
   2647              //!ZDSecMgrTCAuthenticated
   2648              //devtag.0604.critical
   2649                  //how is the parentAddr used here
   2650          
   2651              // initial SKKE from Trust Center via parent
   2652              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2653              device.parentAddr = ind->srcAddr;
   2654            }
   2655            else
   2656            {
   2657              // Trust Center direct or E2E SKKE
   2658              device.nwkAddr    = ind->srcAddr;
   2659              device.parentAddr = INVALID_NODE_ADDR;
   2660            }
   2661          
   2662            device.extAddr = ind->initExtAddr;
   2663            //devtag.pro.security.0724.todo - verify usage
   2664            device.secure  = ind->nwkSecure;
   2665          
   2666            // validate device for SKKE
   2667            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2668            {
   2669              rsp.accept = TRUE;
   2670            }
   2671            else
   2672            {
   2673              rsp.accept = FALSE;
   2674            }
   2675          
   2676            rsp.dstAddr     = ind->srcAddr;
   2677            rsp.initExtAddr = &ind->initExtAddr[0];
   2678            //devtag.0604.todo - remove obsolete
   2679            rsp.apsSecure   = ind->apsSecure;
   2680            rsp.nwkSecure   = ind->nwkSecure;
   2681          
   2682            APSME_EstablishKeyRsp( &rsp );
   2683          }
   2684          //devtag.pro.security
   2685          #if 0
   2686          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2687          {
   2688            ZDSecMgrDevice_t        device;
   2689            APSME_EstablishKeyRsp_t rsp;
   2690          
   2691          
   2692            device.extAddr = ind->initExtAddr;
   2693            device.secure  = ind->secure;
   2694          
   2695            if ( ind->secure == FALSE )
   2696            {
   2697              // SKKE from Trust Center is not secured between child and parent
   2698              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2699              device.parentAddr = ind->srcAddr;
   2700            }
   2701            else
   2702            {
   2703              // SKKE from initiator should be secured
   2704              device.nwkAddr    = ind->srcAddr;
   2705              device.parentAddr = INVALID_NODE_ADDR;
   2706            }
   2707          
   2708            rsp.dstAddr     = ind->srcAddr;
   2709            rsp.initExtAddr = &ind->initExtAddr[0];
   2710            rsp.secure      = ind->secure;
   2711          
   2712            // validate device for SKKE
   2713            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2714            {
   2715              rsp.accept = TRUE;
   2716            }
   2717            else
   2718            {
   2719              rsp.accept = FALSE;
   2720            }
   2721          
   2722            APSME_EstablishKeyRsp( &rsp );
   2723          }
   2724          #endif
   2725          
   2726          /******************************************************************************
   2727           * @fn          ZDSecMgrTransportKeyInd
   2728           *
   2729           * @brief       Process the ZDO_TransportKeyInd_t message.
   2730           *
   2731           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2732           *
   2733           * @return      none
   2734           */
   2735          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   2736          {
   2737            uint8 index;
   2738            uint8 zgPreConfigKey[SEC_KEY_LEN];
   2739          
   2740            // load Trust Center data if needed
   2741            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   2742          
   2743            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   2744            {
   2745              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2746              //ZDSecMgrTCMasterKey( ind );
   2747              {
   2748                if ( zgPreConfigKeys != TRUE )
   2749                {
   2750                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2751                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2752                }
   2753                else
   2754                {
   2755                  // error condition - reject key
   2756                }
   2757              }
   2758            }
   2759            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2760                      ( ind->keyType == 6                 ) ||
   2761                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   2762            {
   2763              // check for dummy NWK key (all zeros)
   2764              for ( index = 0;
   2765                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2766                    index++ );
   2767          
   2768              if ( index == SEC_KEY_LEN )
   2769              {
   2770                // load preconfigured key - once!!
   2771                if ( !_NIB.nwkKeyLoaded )
   2772                {
   2773                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   2774                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   2775                  SSP_SwitchNwkKey( 0 );
   2776                  
   2777                  // clear local copy of key
   2778                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   2779                }
   2780              }
   2781              else
   2782              {
   2783                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   2784                if ( !_NIB.nwkKeyLoaded )
   2785                {
   2786                  SSP_SwitchNwkKey( ind->keySeqNum );
   2787                }
   2788              }
   2789          
   2790              // handle next step in authentication process
   2791              ZDSecMgrAuthNwkKey();
   2792            }
   2793            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2794            {
   2795              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2796              {
   2797                // This should not happen because TCLK should not be Tx
   2798              }
   2799            }
   2800            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2801            {
   2802              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2803              {
   2804                uint16           ami;
   2805                AddrMgrEntry_t   entry;
   2806                ZDSecMgrEntry_t* entryZD;
   2807          
   2808                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2809          
   2810                if ( ind->initiator == TRUE )
   2811                {
   2812                  // get the ami data
   2813                  entry.user  = ADDRMGR_USER_SECURITY;
   2814                  entry.index = ami;
   2815                  AddrMgrEntryGet( &entry );
   2816          
   2817                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2818                  {
   2819                    APSME_EstablishKeyReq_t req;
   2820                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2821          
   2822                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2823          
   2824                    if ( entryZD == NULL )
   2825                    {
   2826                      // get new entry
   2827                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2828                      {
   2829                        // finish setting up entry
   2830                        entryZD->ami = ami;
   2831                      }
   2832                    }
   2833          
   2834                    req.respExtAddr = ind->srcExtAddr;
   2835                    req.method      = APSME_SKKE_METHOD;
   2836                    req.dstAddr     = entry.nwkAddr;
   2837                    req.apsSecure   = FALSE;
   2838                    req.nwkSecure   = TRUE;
   2839                    APSME_EstablishKeyReq( &req );
   2840                  }
   2841                }
   2842                else
   2843                {
   2844                  if ( ami == INVALID_NODE_ADDR )
   2845                  {
   2846                    // store new EXT address
   2847                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2848                  }
   2849          
   2850                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2851                }
   2852              }
   2853            }
   2854            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2855            {
   2856              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2857              {
   2858                uint16           ami;
   2859                ZDSecMgrEntry_t* entry;
   2860          
   2861                // get the address index
   2862                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2863                {
   2864                  // store new EXT address
   2865                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2866                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2867                }
   2868          
   2869                ZDSecMgrEntryLookupAMI( ami, &entry );
   2870          
   2871                if ( entry == NULL )
   2872                {
   2873                  // get new entry
   2874                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2875                  {
   2876                    // finish setting up entry
   2877                    entry->ami = ami;
   2878                  }
   2879                }
   2880          
   2881                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2882              }
   2883            }
   2884          }
   2885          
   2886          /******************************************************************************
   2887           * @fn          ZDSecMgrUpdateDeviceInd
   2888           *
   2889           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2890           *
   2891           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2892           *
   2893           * @return      none
   2894           */
   2895          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   2896          {
   2897            ZDSecMgrDevice_t device;
   2898          
   2899          
   2900            device.nwkAddr    = ind->devAddr;
   2901            device.extAddr    = ind->devExtAddr;
   2902            device.parentAddr = ind->srcAddr;
   2903          
   2904            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2905            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2906            //{
   2907            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2908            //  {
   2909            //    device.secure = TRUE;
   2910            //  }
   2911            //  else
   2912            //  {
   2913            //    device.secure = FALSE;
   2914            //  }
   2915          
   2916              // try to join this device
   2917              ZDSecMgrDeviceJoin( &device );
   2918            //}
   2919          }
   2920          
   2921          /******************************************************************************
   2922           * @fn          ZDSecMgrRemoveDeviceInd
   2923           *
   2924           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2925           *
   2926           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2927           *
   2928           * @return      none
   2929           */
   2930          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   2931          {
   2932            ZDSecMgrDevice_t device;
   2933          
   2934          
   2935            // only accept from Trust Center
   2936            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   2937            {
   2938              // look up NWK address
   2939              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   2940              {
   2941                device.parentAddr = NLME_GetShortAddr();
   2942                device.extAddr    = ind->childExtAddr;
   2943          
   2944                // remove device
   2945                ZDSecMgrDeviceRemove( &device );
   2946              }
   2947            }
   2948          }
   2949          
   2950          /******************************************************************************
   2951           * @fn          ZDSecMgrRequestKeyInd
   2952           *
   2953           * @brief       Process the ZDO_RequestKeyInd_t message.
   2954           *
   2955           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2956           *
   2957           * @return      none
   2958           */
   2959          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   2960          {
   2961            if ( ind->keyType == KEY_TYPE_NWK )
   2962            {
   2963            }
   2964            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2965            {
   2966              ZDSecMgrAppKeyReq( ind );
   2967            }
   2968            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2969            {
   2970            }
   2971            //else ignore
   2972          }
   2973          
   2974          /******************************************************************************
   2975           * @fn          ZDSecMgrSwitchKeyInd
   2976           *
   2977           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2978           *
   2979           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2980           *
   2981           * @return      none
   2982           */
   2983          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   2984          {
   2985            SSP_SwitchNwkKey( ind->keySeqNum );
   2986          
   2987            // Save if nv
   2988            ZDApp_NVUpdate();
   2989          }
   2990          
   2991          /******************************************************************************
   2992           * @fn          ZDSecMgrAuthenticateInd
   2993           *
   2994           * @brief       Process the ZDO_AuthenticateInd_t message.
   2995           *
   2996           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   2997           *
   2998           * @return      none
   2999           */
   3000          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   3001          {
   3002            APSME_AuthenticateReq_t req;
   3003            AddrMgrEntry_t          entry;
   3004          
   3005          
   3006            // update the address manager
   3007            //---------------------------------------------------------------------------
   3008            // note:
   3009            // required for EA processing, but ultimately EA logic could also use the
   3010            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3011            // table is supposed to have authentication states for neighbors
   3012            //---------------------------------------------------------------------------
   3013            entry.user    = ADDRMGR_USER_SECURITY;
   3014            entry.nwkAddr = ind->aps.initNwkAddr;
   3015            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   3016          
   3017            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   3018            {
   3019              // set request fields
   3020              req.nwkAddr   = ind->aps.initNwkAddr;
   3021              req.extAddr   = ind->aps.initExtAddr;
   3022              req.action    = APSME_EA_ACCEPT;
   3023              req.challenge = ind->aps.challenge;
   3024          
   3025              // start EA processing
   3026              APSME_AuthenticateReq( &req );
   3027            }
   3028          }
   3029          
   3030          /******************************************************************************
   3031           * @fn          ZDSecMgrAuthenticateCfm
   3032           *
   3033           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3034           *
   3035           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3036           *
   3037           * @return      none
   3038           */
   3039          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   3040          {
   3041            if ( cfm->aps.status == ZSuccess )
   3042            {
   3043              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   3044              {
   3045                // inform ZDO that device has been authenticated
   3046                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   3047              }
   3048            }
   3049          }
   3050          
   3051          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3052          /******************************************************************************
   3053           * @fn          ZDSecMgrUpdateNwkKey
   3054           *
   3055           * @brief       Load a new NWK key and trigger a network wide update.
   3056           *
   3057           * @param       key       - [in] new NWK key
   3058           * @param       keySeqNum - [in] new NWK key sequence number
   3059           *
   3060           * @return      ZStatus_t
   3061           */
   3062          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3063          {
   3064            ZStatus_t               status;
   3065            APSME_TransportKeyReq_t req;
   3066          
   3067            // initialize common elements of local variables
   3068            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3069              req.keyType   = KEY_TYPE_NWK_HIGH;
   3070            else
   3071              req.keyType   = KEY_TYPE_NWK;
   3072          
   3073            req.dstAddr   = dstAddr;
   3074            req.keySeqNum = keySeqNum;
   3075            req.key       = key;
   3076            req.extAddr   = NULL;
   3077            req.nwkSecure = TRUE;
   3078            req.apsSecure = TRUE;
   3079            req.tunnel    = NULL;
   3080          
   3081            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3082            {
   3083              ZDSecMgrEntry_t*        entry;
   3084              uint16                  index;
   3085              AddrMgrEntry_t          addrEntry;
   3086          
   3087              addrEntry.user = ADDRMGR_USER_SECURITY;
   3088          
   3089              status = ZFailure;
   3090          
   3091              // verify data is available
   3092              if ( ZDSecMgrEntries != NULL )
   3093              {
   3094                // find available entry
   3095                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3096                {
   3097                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3098                  {
   3099                    // return successful result
   3100                    entry = &ZDSecMgrEntries[index];
   3101          
   3102                    // get NWK address
   3103                    addrEntry.index = entry->ami;
   3104                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3105                    {
   3106                      req.dstAddr = addrEntry.nwkAddr;
   3107                      req.extAddr = addrEntry.extAddr;
   3108                      status = APSME_TransportKeyReq( &req );
   3109                    }
   3110                  }
   3111                }
   3112              }
   3113            }
   3114            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3115            {
   3116              status = APSME_TransportKeyReq( &req );
   3117            }
   3118          
   3119            SSP_UpdateNwkKey( key, keySeqNum );
   3120          
   3121            // Save if nv
   3122            ZDApp_NVUpdate();
   3123          
   3124            return status;
   3125          }
   3126          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3127          
   3128          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3129          /******************************************************************************
   3130           * @fn          ZDSecMgrSwitchNwkKey
   3131           *
   3132           * @brief       Causes the NWK key to switch via a network wide command.
   3133           *
   3134           * @param       keySeqNum - [in] new NWK key sequence number
   3135           *
   3136           * @return      ZStatus_t
   3137           */
   3138          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3139          {
   3140            ZStatus_t            status;
   3141            APSME_SwitchKeyReq_t req;
   3142          
   3143            // initialize common elements of local variables
   3144            req.dstAddr = dstAddr;
   3145            req.keySeqNum = keySeqNum;
   3146          
   3147            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3148            {
   3149              ZDSecMgrEntry_t*     entry;
   3150              uint16               index;
   3151              AddrMgrEntry_t       addrEntry;
   3152          
   3153              addrEntry.user = ADDRMGR_USER_SECURITY;
   3154          
   3155              status = ZFailure;
   3156          
   3157              // verify data is available
   3158              if ( ZDSecMgrEntries != NULL )
   3159              {
   3160                // find available entry
   3161                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3162                {
   3163                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3164                  {
   3165                    // return successful result
   3166                    entry = &ZDSecMgrEntries[index];
   3167          
   3168                    // get NWK address
   3169                    addrEntry.index = entry->ami;
   3170          
   3171                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3172                    {
   3173                      req.dstAddr = addrEntry.nwkAddr;
   3174                      status = APSME_SwitchKeyReq( &req );
   3175                    }
   3176                  }
   3177                }
   3178              }
   3179            }
   3180            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3181            {
   3182              status = APSME_SwitchKeyReq( &req );
   3183            }
   3184          
   3185            SSP_SwitchNwkKey( keySeqNum );
   3186          
   3187            // Save if nv
   3188            ZDApp_NVUpdate();
   3189          
   3190            return status;
   3191          }
   3192          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3193          
   3194          #if ( ZG_BUILD_JOINING_TYPE )
   3195          /******************************************************************************
   3196           * @fn          ZDSecMgrRequestAppKey
   3197           *
   3198           * @brief       Request an application key with partner.
   3199           *
   3200           * @param       partNwkAddr - [in] partner network address
   3201           *
   3202           * @return      ZStatus_t
   3203           */
   3204          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   3205          {
   3206            ZStatus_t             status;
   3207            APSME_RequestKeyReq_t req;
   3208            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3209          
   3210          
   3211            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   3212            {
   3213              req.dstAddr = 0;
   3214              req.keyType = KEY_TYPE_APP_MASTER;
   3215              req.partExtAddr = partExtAddr;
   3216              status = APSME_RequestKeyReq( &req );
   3217            }
   3218            else
   3219            {
   3220              status = ZFailure;
   3221            }
   3222          
   3223            return status;
   3224          }
   3225          #endif // ( ZG_BUILD_JOINING_TYPE )
   3226          
   3227          #if ( ZG_BUILD_JOINING_TYPE )
   3228          /******************************************************************************
   3229           * @fn          ZDSecMgrSetupPartner
   3230           *
   3231           * @brief       Setup for application key partner.
   3232           *
   3233           * @param       partNwkAddr - [in] partner network address
   3234           *
   3235           * @return      ZStatus_t
   3236           */
   3237          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   3238          {
   3239            AddrMgrEntry_t entry;
   3240            ZStatus_t      status;
   3241          
   3242            status = ZFailure;
   3243          
   3244            // update the address manager
   3245            entry.user    = ADDRMGR_USER_SECURITY;
   3246            entry.nwkAddr = partNwkAddr;
   3247            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   3248          
   3249            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   3250            {
   3251              status = ZSuccess;
   3252          
   3253              // check for address discovery
   3254              if ( partNwkAddr == INVALID_NODE_ADDR )
   3255              {
   3256                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   3257              }
   3258              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   3259              {
   3260                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   3261              }
   3262            }
   3263          
   3264            return status;
   3265          }
   3266          #endif // ( ZG_BUILD_JOINING_TYPE )
   3267          
   3268          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3269          /******************************************************************************
   3270           * @fn          ZDSecMgrAppKeyTypeSet
   3271           *
   3272           * @brief       Set application key type.
   3273           *
   3274           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3275           *                                                   KEY_TYPE_APP_LINK@3
   3276           *
   3277           * @return      ZStatus_t
   3278           */
   3279          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3280          {
   3281            if ( keyType == KEY_TYPE_APP_LINK )
   3282            {
   3283              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3284            }
   3285            else
   3286            {
   3287              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3288            }
   3289          
   3290            return ZSuccess;
   3291          }
   3292          #endif
   3293          
   3294          /******************************************************************************
   3295           * ZigBee Device Security Manager - Stub Implementations
   3296           */
   3297          /******************************************************************************
   3298           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3299           *
   3300           * @brief       Get MASTER key for specified EXT address.
   3301           *
   3302           * @param       extAddr - [in] EXT address
   3303           * @param       pKeyNvId - [out] MASTER key NV ID
   3304           *
   3305           * @return      ZStatus_t
   3306           */
   3307          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint16* pKeyNvId )
   3308          {
   3309            ZStatus_t status;
   3310            uint16 ami;
   3311          
   3312          
   3313            // lookup entry for specified EXT address
   3314            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   3315          
   3316            if ( status == ZSuccess )
   3317            {
   3318              ZDSecMgrMasterKeyLookup( ami, pKeyNvId );
   3319            }
   3320            else
   3321            {
   3322              *pKeyNvId = SEC_NO_KEY_NV_ID;
   3323            }
   3324          
   3325            return status;
   3326          }
   3327          
   3328          /******************************************************************************
   3329           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3330           *
   3331           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3332           *
   3333           * @param       extAddr - [in] EXT address
   3334           * @param       data    - [in] APSME_LinkKeyData_t
   3335           *
   3336           * @return      ZStatus_t
   3337           */
   3338          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   3339          {
   3340            ZStatus_t status;
   3341            ZDSecMgrEntry_t* entry;
   3342            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3343            uint16 Index;
   3344          
   3345            // lookup entry index for specified EXT address
   3346            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index ); 
   3347          
   3348            if ( status == ZSuccess )
   3349            {
   3350              // point to NV item
   3351              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   3352          
   3353              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3354          
   3355              if (pApsLinkKey != NULL)
   3356              {
   3357                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3358                osal_nv_read( entry->keyNvId, 0, 
   3359                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3360                
   3361                // set new values of the key 
   3362                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   3363                pApsLinkKey->rxFrmCntr = 0;
   3364                pApsLinkKey->txFrmCntr = 0;
   3365                
   3366                osal_nv_write( entry->keyNvId, 0, 
   3367                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3368                
   3369                // clear copy of key in RAM 
   3370                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   3371                
   3372                osal_mem_free(pApsLinkKey);
   3373                
   3374                // set initial values for counters in RAM
   3375                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   3376                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   3377              }
   3378            }
   3379          
   3380            return status;
   3381          }
   3382          
   3383          /******************************************************************************
   3384           * @fn          ZDSecMgrAuthenticationSet
   3385           *
   3386           * @brief       Mark the specific device as authenticated or not
   3387           *
   3388           * @param       extAddr - [in] EXT address
   3389           * @param       option  - [in] authenticated or not
   3390           *
   3391           * @return      ZStatus_t
   3392           */
   3393          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   3394          {
   3395            ZStatus_t        status;
   3396            ZDSecMgrEntry_t* entry;
   3397          
   3398          
   3399            // lookup entry index for specified EXT address
   3400            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   3401          
   3402            if ( status == ZSuccess )
   3403            {
   3404              entry->authenticateOption = option;
   3405            }
   3406          
   3407            return status;
   3408          }
   3409          
   3410          /******************************************************************************
   3411           * @fn          ZDSecMgrAuthenticationCheck
   3412           *
   3413           * @brief       Check if the specific device has been authenticated or not
   3414           *              For non-trust center device, always return true
   3415           *
   3416           * @param       shortAddr - [in] short address
   3417           *
   3418           * @return      TRUE @ authenticated with CBKE
   3419           *              FALSE @ not authenticated
   3420           */
   3421          
   3422          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   3423          {
   3424          #if defined (TC_LINKKEY_JOIN)
   3425          
   3426            ZDSecMgrEntry_t* entry;
   3427            uint8 extAddr[Z_EXTADDR_LEN];
   3428          
   3429            // If the local device is not the trust center, always return TRUE
   3430            if ( NLME_GetShortAddr() != TCshortAddr )
   3431            {
   3432              return TRUE;
   3433            }
   3434            // Otherwise, check the authentication option
   3435            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3436            {
   3437              // lookup entry index for specified EXT address
   3438              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3439              {
   3440                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3441                {
   3442                  return TRUE;
   3443                }
   3444                else
   3445                {
   3446                  return FALSE;
   3447                }
   3448              }
   3449            }
   3450            return FALSE;
   3451          
   3452          #else
   3453            (void)shortAddr;  // Intentionally unreferenced parameter
   3454            
   3455            // For non AMI/SE Profile, perform no check and always return true.
   3456            return TRUE;
   3457          
   3458          #endif // TC_LINKKEY_JOIN
   3459          }
   3460          
   3461          
   3462          /******************************************************************************
   3463           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   3464           *
   3465           * @brief       Get Key NV ID for specified NWK address.
   3466           *
   3467           * @param       extAddr - [in] EXT address
   3468           * @param       keyNvId - [out] NV ID
   3469           *
   3470           * @return      ZStatus_t
   3471           */
   3472          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   3473          {
   3474            ZStatus_t status;
   3475            ZDSecMgrEntry_t* entry;
   3476          
   3477            // lookup entry index for specified NWK address
   3478            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   3479          
   3480            if ( status == ZSuccess )
   3481            {
   3482              // return the index to the NV table
   3483              *pKeyNvId = entry->keyNvId;
   3484            }
   3485            else
   3486            {
   3487              *pKeyNvId = SEC_NO_KEY_NV_ID;
   3488            }
   3489          
   3490            return status;
   3491          }
   3492          
   3493          /******************************************************************************
   3494           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   3495           *
   3496           * @brief       Verifies if Link Key in NV has been set.
   3497           *
   3498           * @param       extAddr - [in] EXT address
   3499           *
   3500           * @return      TRUE - Link Key has been established
   3501           *              FALSE - Link Key in NV has default value.
   3502           */
   3503          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   3504          {
   3505            APSME_LinkKeyData_t *pKeyData = NULL;
   3506            uint16 apsLinkKeyNvId;
   3507            uint8 nullKey[SEC_KEY_LEN];
   3508            uint8 status = FALSE;
   3509          
   3510            // initialize default vealue to compare to
   3511            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   3512          
   3513            // check for APS link NV ID
   3514            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   3515          
   3516            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   3517            {
   3518              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3519              
   3520              if (pKeyData != NULL)
   3521              {
   3522                // retrieve key from NV
   3523                if ( osal_nv_read( apsLinkKeyNvId, 0, 
   3524                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   3525                {
   3526                  // if stored key is different than default value, then a key has been established
   3527                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   3528                  {
   3529                    status = TRUE;
   3530                  }
   3531                }
   3532              }
   3533            }
   3534          
   3535            return status;
   3536          }
   3537          
   3538          /******************************************************************************
   3539           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3540           *
   3541           * @brief       Verify and process key transportation to child.
   3542           *
   3543           * @param       ind - [in] APSME_TransportKeyInd_t
   3544           *
   3545           * @return      uint8 - success(TRUE:FALSE)
   3546           */
   3547          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   3548          {
   3549            uint8 success;
   3550          
   3551            success = FALSE;
   3552          
   3553            // verify from Trust Center
   3554            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   3555            {
   3556              success = TRUE;
   3557          
   3558              // check for initial NWK key
   3559              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3560                   ( ind->keyType == 6                 ) ||
   3561                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   3562              {
   3563                // set association status to authenticated
   3564                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   3565              }
   3566            }
   3567          
   3568            return success;
   3569          }
   3570          
   3571          /******************************************************************************
   3572           * @fn          ZDSecMgrAddLinkKey
   3573           *
   3574           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3575           *              as authenticated in the authenticateOption. Note that this function
   3576           *              is hardwared to CBKE right now.
   3577           *
   3578           * @param       shortAddr - short address of the partner device
   3579           * @param       extAddr - extended address of the partner device
   3580           * @param       key - link key
   3581           *
   3582           * @return      ZStatus_t
   3583           */
   3584          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   3585          {
   3586            uint16           ami;
   3587            ZDSecMgrEntry_t* entry;
   3588          
   3589            /* Store the device address in the addr manager */
   3590            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   3591            {
   3592              /* Adding to Addr Manager fails */
   3593              return ZFailure;
   3594            }
   3595          
   3596            /* Lookup entry using specified address index */
   3597            ZDSecMgrEntryLookupAMI( ami, &entry );
   3598          
   3599            // If no existing entry, create one
   3600            if ( entry == NULL )
   3601            {
   3602              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   3603              {
   3604                entry->ami = ami;
   3605              }
   3606              else
   3607              {
   3608                /* Security Manager full */
   3609                return ZBufferFull;
   3610              }
   3611            }
   3612            // Write the link key
   3613            APSME_LinkKeySet( extAddr, key );
   3614          
   3615          #if defined (TC_LINKKEY_JOIN)
   3616            // Mark the device as authenticated.
   3617            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3618          #endif
   3619          
   3620          #if defined NV_RESTORE
   3621            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3622          #endif
   3623            
   3624            return ZSuccess;
   3625          }
   3626          
   3627          #if defined ( NV_RESTORE )
   3628          /******************************************************************************
   3629           * @fn          ZDSecMgrInitNV
   3630           *
   3631           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   3632           *
   3633           * @param       none
   3634           *
   3635           * @return      uint8 - <osal_nv_item_init> return codes
   3636           */
   3637          uint8 ZDSecMgrInitNV(void)
   3638          {
   3639            
   3640            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE, 
   3641                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3642            
   3643            // If the item does not already exist, set all values to 0 
   3644            if (rtrn != SUCCESS)  
   3645            {
   3646              nvDeviceListHdr_t hdr;
   3647              hdr.numRecs = 0;
   3648              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3649            }
   3650          
   3651            return rtrn;
   3652          }
   3653          #endif // NV_RESTORE
   3654          
   3655          #if defined ( NV_RESTORE )
   3656          /*********************************************************************
   3657           * @fn      ZDSecMgrWriteNV()
   3658           *
   3659           * @brief   Save off the APS link key list to NV
   3660           *
   3661           * @param   none
   3662           *
   3663           * @return  none
   3664           */
   3665          static void ZDSecMgrWriteNV( void )
   3666          {
   3667            uint16 i;
   3668            nvDeviceListHdr_t hdr;
   3669          
   3670            hdr.numRecs = 0;
   3671          
   3672            if (ZDSecMgrEntries != NULL)
   3673            {
   3674              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3675              {
   3676                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3677                {
   3678                  // Save off the record
   3679                  osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3680                          (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3681                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3682                  hdr.numRecs++;
   3683                }
   3684              }
   3685            }
   3686          
   3687            // Save off the header
   3688            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3689          }
   3690          #endif // NV_RESTORE
   3691          
   3692          #if defined ( NV_RESTORE )
   3693          /******************************************************************************
   3694           * @fn          ZDSecMgrRestoreFromNV
   3695           *
   3696           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   3697           *              the key data itself as they remain in NV until they are used. 
   3698           *              Only list data is restored.
   3699           *
   3700           * @param       none
   3701           *
   3702           * @return      None.
   3703           */
   3704          static void ZDSecMgrRestoreFromNV( void )
   3705          {
   3706            nvDeviceListHdr_t hdr;
   3707            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3708            
   3709            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3710                (hdr.numRecs <= ZDSECMGR_ENTRY_MAX))
   3711            {
   3712              uint8 x;
   3713          
   3714              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3715              
   3716              for (x = 0; x < hdr.numRecs; x++)
   3717              {
   3718                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3719                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3720                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   3721                {
   3722                  // update data only for valid entries 
   3723                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   3724                  {
   3725                    if (pApsLinkKey != NULL)
   3726                    {
   3727                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3728                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0, 
   3729                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3730                      
   3731                      // set new values for the counter 
   3732                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3733          
   3734                      // restore values for counters in RAM
   3735                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 
   3736                                                      pApsLinkKey->txFrmCntr;
   3737          
   3738                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 
   3739                                                      pApsLinkKey->rxFrmCntr;
   3740                      
   3741                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0, 
   3742                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3743                      
   3744                      // clear copy of key in RAM 
   3745                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   3746                    }
   3747                  }
   3748                }
   3749              }
   3750              
   3751              if (pApsLinkKey != NULL)
   3752              {
   3753                osal_mem_free(pApsLinkKey);
   3754              }    
   3755            }
   3756          }
   3757          #endif // NV_RESTORE
   3758          
   3759          /*********************************************************************
   3760           * @fn          ZDSecMgrSetDefaultNV
   3761           *
   3762           * @brief       Write the defaults to NV for Entry table and for APS key data table
   3763           *
   3764           * @param       none
   3765           *
   3766           * @return      none
   3767           */
   3768          void ZDSecMgrSetDefaultNV( void )
   3769          {
   3770            uint16 i;
   3771            nvDeviceListHdr_t hdr;
   3772            ZDSecMgrEntry_t secMgrEntry;
   3773            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3774              
   3775            // Initialize the header
   3776            hdr.numRecs = 0;
   3777          
   3778            // clear the header
   3779            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3780            
   3781            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   3782          
   3783            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3784            {
   3785              // Clear the record
   3786              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3787                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   3788                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   3789            }
   3790          
   3791            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3792          
   3793            if (pApsLinkKey != NULL)
   3794            {
   3795              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   3796          
   3797              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3798              {
   3799                // Clear the record
   3800                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3801                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   3802              }
   3803              
   3804              osal_mem_free(pApsLinkKey);
   3805            }
   3806          }
   3807          
   3808          /******************************************************************************
   3809           * @fn          ZDSecMgrAPSRemove
   3810           *
   3811           * @brief       Remove device from network.
   3812           *
   3813           * @param       nwkAddr - device's NWK address
   3814           * @param       extAddr - device's Extended address
   3815           * @param       parentAddr - parent's NWK address
   3816           *
   3817           * @return      ZStatus_t
   3818           */
   3819          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   3820          {
   3821            ZDSecMgrDevice_t device;
   3822          
   3823            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3824                 ( extAddr == NULL )              ||
   3825                 ( parentAddr == INVALID_NODE_ADDR ) )
   3826            {
   3827              return ( ZFailure );
   3828            }
   3829          
   3830            device.nwkAddr = nwkAddr;
   3831            device.extAddr = extAddr;
   3832            device.parentAddr = parentAddr;
   3833          
   3834            // remove device
   3835            ZDSecMgrDeviceRemove( &device );
   3836          
   3837            return ( ZSuccess );
   3838          }
   3839          
   3840          /******************************************************************************
   3841           * @fn          APSME_TCLinkKeyInit
   3842           *
   3843           * @brief       Initialize the NV table for preconfigured TC link key
   3844           *               
   3845           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3846           *              Trust Center Link Key is written to NV. A single tclk is used   
   3847           *              by all devices joining the network.
   3848           *              
   3849           * @param       setDefault - TRUE to set default values
   3850           *
   3851           * @return      none
   3852           */
   3853          void APSME_TCLinkKeyInit(uint8 setDefault)
   3854          {
   3855            uint8             i;
   3856            APSME_TCLinkKey_t tcLinkKey;
   3857            uint8             rtrn;
   3858            
   3859            // Initialize all NV items for preconfigured TCLK 
   3860            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3861            {
   3862              // Making sure data is cleared for every key all the time
   3863              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   3864          
   3865              // Initialize first element of the table with the default TCLK
   3866              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   3867              {
   3868                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   3869                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   3870              }
   3871          
   3872              // If the item doesn't exist in NV memory, create and initialize
   3873              // it with the default value passed in, either defaultTCLK or 0
   3874              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i), 
   3875                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   3876               
   3877              if (rtrn == SUCCESS)
   3878              {
   3879                // set the Frame counters to 0 to existing keys in NV
   3880                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0, 
   3881                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   3882                
   3883          #if defined ( NV_RESTORE )
   3884                if (setDefault == TRUE)
   3885                {
   3886                  // clear the value stored in NV  
   3887                  tcLinkKey.txFrmCntr = 0;
   3888                }
   3889                else
   3890                {
   3891                  // increase the value stored in NV  
   3892                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   3893                }
   3894          #else      
   3895                // Clear the counters if NV_RESTORE is not enabled and this NV item
   3896                // already existed in the NV memory
   3897                tcLinkKey.txFrmCntr = 0;
   3898                tcLinkKey.rxFrmCntr = 0;
   3899          #endif  // NV_RESTORE
   3900          
   3901                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   3902                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   3903                
   3904                // set initial values for counters in RAM
   3905                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   3906                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;    
   3907              }
   3908            }
   3909              
   3910            // clear copy of key in RAM
   3911            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   3912          
   3913          }
   3914          
   3915          /******************************************************************************
   3916           * @fn          APSME_TCLinkKeySync
   3917           *
   3918           * @brief       Sync Trust Center LINK key data.
   3919           *
   3920           * @param       srcAddr - [in] srcAddr
   3921           * @param       si      - [in, out] SSP_Info_t
   3922           *
   3923           * @return      ZStatus_t
   3924           */
   3925          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   3926          {
   3927            ZStatus_t status = ZSecNoKey;
   3928            uint8 i;
   3929            APSME_TCLinkKey_t tcLinkKey;       
   3930            uint32 *tclkRxFrmCntr;
   3931            
   3932            // Look up the IEEE address of the trust center if it's available
   3933            if ( AddrMgrExtAddrValid( si->extAddr ) == false )
   3934            {
   3935              APSME_LookupExtAddr( srcAddr, si->extAddr );
   3936            }
   3937            
   3938            // Look up the TC link key associated with the device
   3939            // or the default TC link key (extAddr is all FFs), whichever is found
   3940            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3941            {
   3942              // Read entry i of the TC link key table from NV
   3943              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3944                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   3945              
   3946              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3947                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   3948              {
   3949                tclkRxFrmCntr = &TCLinkKeyFrmCntr[i].rxFrmCntr;
   3950          
   3951                // verify that the incoming frame counter is valid
   3952                if ( si->frmCntr >= *tclkRxFrmCntr )
   3953                {
   3954                  // set the keyNvId to use
   3955                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   3956                  
   3957                  // update the rx frame counter
   3958                  *tclkRxFrmCntr = si->frmCntr + 1;
   3959                  
   3960                  status = ZSuccess;
   3961                }
   3962                else
   3963                {
   3964                  status = ZSecOldFrmCount;
   3965                }
   3966                
   3967                return status;
   3968              }
   3969            }
   3970            
   3971            // clear copy of key in RAM 
   3972            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   3973            
   3974            return status;
   3975          }
   3976          
   3977          /******************************************************************************
   3978           * @fn          APSME_TCLinkKeyLoad
   3979           *
   3980           * @brief       Load Trust Center LINK key data.
   3981           *
   3982           * @param       dstAddr - [in] dstAddr
   3983           * @param       si      - [in, out] SSP_Info_t
   3984           *
   3985           * @return      ZStatus_t
   3986           */
   3987          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   3988          {
   3989            uint8              i;
   3990            APSME_TCLinkKey_t  tcLinkKey;
   3991            AddrMgrEntry_t     addrEntry;  
   3992            uint32 *tclkTxFrmCntr;
   3993            
   3994            // Look up the ami of the srcAddr if available
   3995            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   3996            addrEntry.nwkAddr = dstAddr;
   3997          
   3998            APSME_LookupExtAddr( dstAddr, si->extAddr );
   3999          
   4000            if ( AddrMgrExtAddrValid( si->extAddr ) == TRUE )
   4001            {
   4002              // Look up the TC link key associated with the device
   4003              // or the master TC link key (ami = 0xFFFF), whichever is found
   4004              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   4005              {
   4006                // Read entry i of the TC link key table from NV
   4007                osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   4008                             sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   4009                
   4010                if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   4011                   APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   4012                {
   4013                  tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   4014                  
   4015                  // set the keyNvId to use
   4016                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   4017                  
   4018                  // update link key related fields
   4019                  si->keyID   = SEC_KEYID_LINK;
   4020                  si->frmCntr = *tclkTxFrmCntr;
   4021                
   4022                  // update outgoing frame counter
   4023                  (*tclkTxFrmCntr)++;
   4024                  
   4025          #if defined ( NV_RESTORE )
   4026                  // write periodically to NV
   4027                  if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   4028                  {
   4029                    // set the flag to write key to NV
   4030                    TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   4031                    
   4032                    // Notify the ZDApp that the frame counter has changed.
   4033                    osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   4034                  }        
   4035          #endif
   4036                  
   4037                  return ZSuccess;
   4038                }
   4039              }
   4040            }
   4041              
   4042            // If no TC link key found, remove the device from the address manager
   4043            if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   4044            {
   4045              AddrMgrEntryRelease( &addrEntry );
   4046            }
   4047            
   4048              // clear copy of key in RAM 
   4049            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   4050          
   4051            return ZSecNoKey;
   4052          }
   4053          
   4054          /******************************************************************************
   4055           * @fn          APSME_IsDefaultTCLK
   4056           *
   4057           * @brief       Return true or false based on the extended address.  If the 
   4058           *              input ext address is all FFs, it means the trust center link
   4059           *              assoiciated with the address is the default trust center link key
   4060           *
   4061           * @param       extAddr - [in] extended address
   4062           *
   4063           * @return      uint8 TRUE/FALSE
   4064           */
   4065          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   4066          {
   4067            uint8 i = 0;
   4068            
   4069            if( extAddr == NULL )
   4070            {
   4071              return FALSE;
   4072            }
   4073            
   4074            while( i++ < Z_EXTADDR_LEN )
   4075            {
   4076              if( *extAddr++ != 0xFF )
   4077              {
   4078                return FALSE;
   4079              }
   4080            }
   4081            
   4082            return TRUE;
   4083          }
   4084          
   4085          /******************************************************************************
   4086           * @fn          ZDSecMgrNwkKeyInit
   4087           *
   4088           * @brief       Initialize the NV items for 
   4089           *                  ZCD_NV_NWKKEY, 
   4090           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and 
   4091           *                  ZCD_NV_NWK_ALTERN_KEY_INFO 
   4092           *               
   4093           * @param       setDefault
   4094           *
   4095           * @return      none
   4096           */
   4097          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   4098          {
   4099            uint8 status;
   4100            nwkKeyDesc nwkKey;
   4101          
   4102            // Initialize NV items for NWK key, this structure contains the frame counter
   4103            // and is only used when NV_RESTORE is enabled
   4104            nwkActiveKeyItems keyItems;  
   4105              
   4106            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   4107            
   4108            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   4109          
   4110          #if defined ( NV_RESTORE )
   4111            // reset the values of NV items if NV_RESTORE is not enabled
   4112            if ((status == SUCCESS) && (setDefault == TRUE))
   4113            {
   4114              // clear NV data to default values
   4115              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   4116            }
   4117          #else
   4118            (void)setDefault;   // to eliminate compiler warning
   4119            
   4120            // reset the values of NV items if NV_RESTORE is not enabled
   4121            if (status == SUCCESS)
   4122            {
   4123              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   4124            }
   4125          #endif // defined (NV_RESTORE)    
   4126          
   4127            // Initialize NV items for NWK Active and Alternate keys. These items are used 
   4128            // all the time, independently of NV_RESTORE being set or not
   4129            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   4130          
   4131            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   4132            
   4133          #if defined ( NV_RESTORE )
   4134            // reset the values of NV items if NV_RESTORE is not enabled
   4135            if ((status == SUCCESS) && (setDefault == TRUE))
   4136            {
   4137              // clear NV data to default values
   4138              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4139            }
   4140          #else
   4141            // reset the values of NV items if NV_RESTORE is not enabled
   4142            if (status == SUCCESS)
   4143            {
   4144              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4145            }
   4146          #endif // defined (NV_RESTORE)    
   4147            
   4148            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   4149            
   4150          #if defined ( NV_RESTORE )
   4151            // reset the values of NV items if NV_RESTORE is not enabled
   4152            if ((status == SUCCESS) && (setDefault == TRUE))
   4153            {
   4154              // clear NV data to default values
   4155              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4156            }
   4157          #else
   4158            // reset the values of NV items if NV_RESTORE is not enabled
   4159            if (status == SUCCESS)
   4160            {
   4161              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4162            }
   4163          #endif // defined (NV_RESTORE)
   4164          
   4165          }
   4166          
   4167          /*********************************************************************
   4168           * @fn          ZDSecMgrReadKeyFromNv
   4169           *
   4170           * @brief       Looks for a specific key in NV based on Index value
   4171           *
   4172           * @param   keyNvId - Index of key to look in NV
   4173           *                    valid values are:
   4174           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO    
   4175           *                    ZCD_NV_NWK_ALTERN_KEY_INFO 
   4176           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4177           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4178           *                    ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4179           *                    ZCD_NV_PRECFGKEY
   4180           *
   4181           * @param  *keyinfo - Data is read into this buffer.
   4182           *
   4183           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   4184           *          Otherwise, NV_OPER_FAILED for failure.
   4185           */
   4186          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   4187          {
   4188            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   4189                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   4190            {
   4191              // get NWK active or alternate key from NV
   4192              return (osal_nv_read(keyNvId, 
   4193                                   osal_offsetof(nwkKeyDesc, key), 
   4194                                   SEC_KEY_LEN, 
   4195                                   keyinfo));
   4196            }
   4197            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   4198                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   4199            {
   4200              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   4201              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4202              return (osal_nv_read(keyNvId, 
   4203                                   osal_offsetof(APSME_TCLinkKey_t, key), 
   4204                                   SEC_KEY_LEN, 
   4205                                   keyinfo));
   4206            }
   4207            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   4208                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   4209            {
   4210              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   4211              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4212              return (osal_nv_read(keyNvId, 
   4213                                   osal_offsetof(APSME_LinkKeyData_t, key), 
   4214                                   SEC_KEY_LEN, 
   4215                                   keyinfo));
   4216            }
   4217            else if ((keyNvId >= ZCD_NV_MASTER_KEY_DATA_START) &&
   4218                     (keyNvId < (ZCD_NV_MASTER_KEY_DATA_START + ZDSECMGR_MASTERKEY_MAX)))
   4219            {
   4220              // Read entry keyNvId of the MASTER key table from NV. keyNvId should be
   4221              // ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4222              return (osal_nv_read(keyNvId, 
   4223                                   osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   4224                                   SEC_KEY_LEN, 
   4225                                   keyinfo));
   4226            }
   4227            else if (keyNvId == ZCD_NV_PRECFGKEY)
   4228            {
   4229              // Read entry keyNvId of the Preconfig key from NV. 
   4230              return (osal_nv_read(keyNvId, 
   4231                                   0, 
   4232                                   SEC_KEY_LEN, 
   4233                                   keyinfo));
   4234            }
   4235            
   4236            return NV_OPER_FAILED;
   4237          }
   4238          
   4239          /******************************************************************************
   4240           * @fn          ZDSecMgrApsLinkKeyInit
   4241           *
   4242           * @brief       Initialize the NV table for Application link keys
   4243           *           
   4244           * @param       none
   4245           *
   4246           * @return      none
   4247           */
   4248          void ZDSecMgrApsLinkKeyInit(void)
   4249          {
   4250            APSME_LinkKeyData_t pApsLinkKey;
   4251            uint8 i;
   4252            uint8 status;
   4253            
   4254            // Initialize all NV items for APS link key, if not exist already.
   4255            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   4256            
   4257            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   4258            {
   4259              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 
   4260                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   4261              
   4262          #if defined ( NV_RESTORE )
   4263              (void)status;   // to eliminate compiler warning
   4264          #else
   4265              // reset the values of NV items if NV_RESTORE is not enabled
   4266              if (status == SUCCESS)
   4267              {
   4268                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0, 
   4269                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   4270                
   4271              }
   4272          #endif // defined (NV_RESTORE)
   4273            }
   4274          }
   4275          
   4276          /******************************************************************************
   4277           * @fn          ZDSecMgrInitNVKeyTables
   4278           *
   4279           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   4280           *           
   4281           * @param       setDefault - TRUE to set default values 
   4282           *
   4283           * @return      none
   4284           */
   4285          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   4286          {
   4287            ZDSecMgrNwkKeyInit(setDefault);
   4288            ZDSecMgrMasterKeyInit();
   4289            ZDSecMgrApsLinkKeyInit();
   4290            APSME_TCLinkKeyInit(setDefault);
   4291          }
   4292          
   4293          /******************************************************************************
   4294           * @fn          ZDSecMgrSaveApsLinkKey
   4295           *
   4296           * @brief       Save APS Link Key to NV. It will loop through all the keys  
   4297           *              to see which one to save.
   4298           *           
   4299           * @param       none
   4300           *
   4301           * @return      none
   4302           */
   4303          void ZDSecMgrSaveApsLinkKey(void)
   4304          {
   4305            APSME_LinkKeyData_t *pKeyData = NULL;
   4306            int i;
   4307            
   4308            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   4309            
   4310            if (pKeyData != NULL)
   4311            {          
   4312              // checks all pending flags to know which one to save
   4313              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   4314              {
   4315                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   4316                {
   4317                  // retrieve key from NV
   4318                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0, 
   4319                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   4320                  {                
   4321                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   4322                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   4323                    
   4324                    // Write the APS link key back to the NV
   4325                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0, 
   4326                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   4327                    
   4328                    // clear the pending write flag
   4329                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   4330                  }
   4331                }
   4332              }
   4333              
   4334              // clear copy of key in RAM 
   4335              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   4336              
   4337              osal_mem_free(pKeyData);
   4338            }  
   4339          }
   4340          
   4341          /******************************************************************************
   4342           * @fn          ZDSecMgrSaveTCLinkKey
   4343           *
   4344           * @brief       Save TC Link Key to NV. It will loop through all the keys 
   4345           *              to see which one to save.
   4346           *           
   4347           * @param       none
   4348           *
   4349           * @return      none
   4350           */
   4351          void ZDSecMgrSaveTCLinkKey(void)
   4352          {
   4353            APSME_TCLinkKey_t *pKeyData = NULL;
   4354            int i;
   4355            
   4356            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   4357            
   4358            if (pKeyData != NULL)
   4359            {          
   4360              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   4361              {
   4362                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   4363                {
   4364                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0, 
   4365                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   4366                  {                
   4367                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   4368                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   4369                    
   4370                    // Write the TC link key back to the NV
   4371                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0, 
   4372                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   4373                    
   4374                    // clear the pending write flag
   4375                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   4376                  }
   4377                }
   4378              }
   4379                // clear copy of key in RAM 
   4380              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   4381              
   4382              osal_mem_free(pKeyData);
   4383            }
   4384          }
   4385          
   4386          #if defined ( NV_RESTORE )
   4387          /******************************************************************************
   4388           * @fn          ZDSecMgrClearNVKeyValues
   4389           *
   4390           * @brief       If NV_RESTORE is enabled and the status of the network needs 
   4391           *              default values this fuction clears ZCD_NV_NWKKEY, 
   4392           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link 
   4393           *           
   4394           * @param       none
   4395           *
   4396           * @return      none
   4397           */
   4398          void ZDSecMgrClearNVKeyValues(void)
   4399          {
   4400            nwkActiveKeyItems keyItems;
   4401            nwkKeyDesc nwkKey;
   4402          
   4403            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   4404          
   4405            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   4406          
   4407            // Initialize NV items for NWK Active and Alternate keys. 
   4408            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   4409          
   4410            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4411          
   4412            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4413          }
   4414          #endif // defined ( NV_RESTORE )
   4415          
   4416          /******************************************************************************
   4417          ******************************************************************************/
   4418          

Errors: 1
Warnings: none
