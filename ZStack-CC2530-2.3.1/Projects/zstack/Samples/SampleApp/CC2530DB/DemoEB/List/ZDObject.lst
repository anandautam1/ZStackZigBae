###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                08/Jun/2011  10:49:47 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Component #
#                          s\stack\zdo\ZDObject.c                             #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proje #
#                          cts\zstack\Samples\SampleApp\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wCoord.cfg" (-DCPU32MHZ              #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proje #
#                          cts\zstack\Samples\SampleApp\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wConfig.cfg" (-DSECURE=0             #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.3.1\Components\stack\z #
#                          do\ZDObject.c" -D BUILD_ALL_DEVICES -D             #
#                          HOLD_AUTO_START -D LCD_SUPPORTED -D                #
#                          HAL_UART=FALSE -lC "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\DemoEB\List\" -lA         #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\DemoEB\List\"   #
#                          --diag_suppress Pe001,Pa010 -o "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\DemoEB\Obj\" -e           #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\" -I "C:\Texas            #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\SOURCE\" -I "C:\Texas  #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\" #
#                           -I "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\MT\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \HAL\INCLUDE\" -I "C:\Texas                        #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \HAL\TARGET\CC2530EB\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \OSAL\MCU\CCSOC\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \OSAL\INCLUDE\" -I "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\AF\" -I "C:\Texas                           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\NWK\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SEC\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SAPI\" -I "C:\Texas                         #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SYS\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\ZDO\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \ZMAC\F8W\" -I "C:\Texas                           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \ZMAC\" -I "C:\Texas Instruments\ZStack-CC2530-2.3 #
#                          .1\Projects\zstack\Samples\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\SERVICES\SADDR\" -I          #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\SERVICES\SDATA\" -I "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\INCLUDE\" -I "C:\Texas                        #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\HIGH_LEVEL\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\LOW_LEVEL\srf04\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program  #
#                          Files\IAR Systems\Embedded Workbench               #
#                          5.3\8051\INC\" -I "C:\Program Files\IAR            #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\DemoEB\List\ZDOb #
#                          ject.lst                                           #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\DemoEB\Obj\ZDObj #
#                          ect.r51                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.3.1\Components\stack\zdo\ZDObject.c
      1          /**************************************************************************************************
      2            Filename:       ZDObject.c
      3            Revised:        $Date: 2010-06-28 16:08:35 -0700 (Mon, 28 Jun 2010) $
      4            Revision:       $Revision: 22835 $
      5          
      6            Description:    This is the Zigbee Device Object.
      7          
      8          
      9            Copyright 2004-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComdef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Nv.h"
     46          #include "rtg.h"
     47          #include "NLMEDE.h"
     48          #include "nwk_globals.h"
     49          #include "APS.h"
     50          #include "APSMEDE.h"
     51          #include "AssocList.h"
     52          #include "BindingTable.h"
     53          #include "AddrMgr.h"
     54          #include "AF.h"
     55          #include "ZDObject.h"
     56          #include "ZDProfile.h"
     57          #include "ZDConfig.h"
     58          #include "ZDSecMgr.h"
     59          #include "ZDApp.h"
     60          #include "nwk_util.h"   // NLME_IsAddressBroadcast()
     61          #include "ZGlobals.h"
     62          #if defined MT_ZDO_CB_FUNC
     63          #include "MT.h"
     64          #endif
     65          
     66          #if defined( LCD_SUPPORTED )
     67            #include "OnBoard.h"
     68          #endif
     69          
     70          /* HAL */
     71          #include "hal_lcd.h"
     72          
     73          /*********************************************************************
     74           * MACROS
     75           */
     76          
     77          /*********************************************************************
     78           * CONSTANTS
     79           */
     80          // NLME Stub Implementations
     81          #define ZDO_ProcessMgmtPermitJoinTimeout NLME_PermitJoiningTimeout
     82          
     83          // Status fields used by ZDO_ProcessMgmtRtgReq
     84          #define ZDO_MGMT_RTG_ENTRY_ACTIVE             0x00
     85          #define ZDO_MGMT_RTG_ENTRY_DISCOVERY_UNDERWAY 0x01
     86          #define ZDO_MGMT_RTG_ENTRY_DISCOVERY_FAILED   0x02
     87          #define ZDO_MGMT_RTG_ENTRY_INACTIVE           0x03
     88          
     89          /*********************************************************************
     90           * TYPEDEFS
     91           */
     92          #if defined ( REFLECTOR )
     93          typedef struct
     94          {
     95            byte SrcTransSeq;
     96            zAddrType_t SrcAddr;
     97            uint16 LocalCoordinator;
     98            byte epIntf;
     99            uint16 ProfileID;
    100            byte numInClusters;
    101            uint16 *inClusters;
    102            byte numOutClusters;
    103            uint16 *outClusters;
    104            byte SecurityUse;
    105            byte status;
    106          } ZDO_EDBind_t;
    107          #endif // defined ( REFLECTOR )
    108          
    109          enum
    110          {
    111            ZDMATCH_INIT,           // Initialized
    112            ZDMATCH_WAIT_REQ,       // Received first request, waiting for second
    113            ZDMATCH_SENDING_BINDS   // Received both requests, sending unbind/binds
    114          };
    115          
    116          enum
    117          {
    118            ZDMATCH_SENDING_NOT,
    119            ZDMATCH_SENDING_UNBIND,
    120            ZDMATCH_SENDING_BIND
    121          };
    122          
    123          /*********************************************************************
    124           * GLOBAL VARIABLES
    125           */
    126          
    127          /*********************************************************************
    128           * EXTERNAL VARIABLES
    129           */
    130          
    131          /*********************************************************************
    132           * EXTERNAL FUNCTIONS
    133           */
    134          
    135          /*********************************************************************
    136           * LOCAL VARIABLES
    137           */
    138          static uint16 ZDOBuildBuf[26];  // temp area to build data without allocation
    139          
    140          #if defined ( REFLECTOR )
    141          static ZDO_EDBind_t *ZDO_EDBind;     // Null when not used
    142          #endif
    143          
    144          #if defined ( MANAGED_SCAN )
    145            uint32 managedScanNextChannel = 0;
    146            uint32 managedScanChannelMask = 0;
    147            uint8  managedScanTimesPerChannel = 0;
    148          #endif
    149          
    150          ZDMatchEndDeviceBind_t *matchED = (ZDMatchEndDeviceBind_t *)NULL;
    151          
    152          uint32 apsChannelMask = 0;
    153          
    154          /*********************************************************************
    155           * LOCAL FUNCTIONS
    156           */
    157          static void ZDODeviceSetup( void );
    158          #if defined ( MANAGED_SCAN )
    159            static void ZDOManagedScan_Next( void );
    160          #endif
    161          #if defined ( REFLECTOR )
    162            static void ZDO_RemoveEndDeviceBind( void );
    163            static void ZDO_SendEDBindRsp( byte TransSeq, zAddrType_t *dstAddr, byte Status, byte secUse );
    164          #endif
    165          static byte ZDO_CompareClusterLists( byte numList1, uint16 *list1,
    166                                          byte numList2, uint16 *list2, uint16 *pMatches );
    167          static void ZDO_RemoveMatchMemory( void );
    168          static uint8 ZDO_CopyMatchInfo( ZDEndDeviceBind_t *destReq, ZDEndDeviceBind_t *srcReq );
    169          static void ZDO_EndDeviceBindMatchTimeoutCB( void );
    170          uint8 *ZDO_ConvertOTAClusters( uint8 cnt, uint8 *inBuf, uint16 *outList );
    171          static void zdoSendStateChangeMsg(uint8 state, uint8 taskId);
    172          
    173          /*********************************************************************
    174           * @fn          ZDO_Init
    175           *
    176           * @brief       ZDObject and ZDProfile initialization.
    177           *
    178           * @param       none
    179           *
    180           * @return      none
    181           */
    182          void ZDO_Init( void )
    183          {
    184            // Initialize ZD items
    185            #if defined ( REFLECTOR )
    186            ZDO_EDBind = NULL;
    187            #endif
    188          
    189            // Initialize default ZDO_UseExtendedPANID to the APS one.
    190            osal_cpyExtAddr( ZDO_UseExtendedPANID, AIB_apsUseExtendedPANID );
    191          
    192            // Setup the device - type of device to create.
    193            ZDODeviceSetup();
    194          }
    195          
    196          #if defined ( MANAGED_SCAN )
    197          /*********************************************************************
    198           * @fn      ZDOManagedScan_Next()
    199           *
    200           * @brief   Setup a managed scan.
    201           *
    202           * @param   none
    203           *
    204           * @return  none
    205           */
    206          static void ZDOManagedScan_Next( void )
    207          {
    208            // Is it the first time
    209            if ( managedScanNextChannel == 0 && managedScanTimesPerChannel == 0 )
    210            {
    211              // Setup the defaults
    212              managedScanNextChannel  = 1;
    213          
    214              while( managedScanNextChannel && (zgDefaultChannelList & managedScanNextChannel) == 0 )
    215                managedScanNextChannel <<= 1;
    216          
    217              managedScanChannelMask = managedScanNextChannel;
    218              managedScanTimesPerChannel = MANAGEDSCAN_TIMES_PRE_CHANNEL;
    219            }
    220            else
    221            {
    222              // Do we need to go to the next channel
    223              if ( managedScanTimesPerChannel == 0 )
    224              {
    225                // Find next active channel
    226                managedScanChannelMask  = managedScanNextChannel;
    227                managedScanTimesPerChannel = MANAGEDSCAN_TIMES_PRE_CHANNEL;
    228              }
    229              else
    230              {
    231                managedScanTimesPerChannel--;
    232          
    233                if ( managedScanTimesPerChannel == 0 )
    234                {
    235                  managedScanNextChannel  <<= 1;
    236                  while( managedScanNextChannel && (zgDefaultChannelList & managedScanNextChannel) == 0 )
    237                    managedScanNextChannel <<= 1;
    238          
    239                  if ( managedScanNextChannel == 0 )
    240                    zdoDiscCounter  = NUM_DISC_ATTEMPTS + 1; // Stop
    241                }
    242              }
    243            }
    244          }
    245          #endif // MANAGED_SCAN
    246          
    247          /*********************************************************************
    248           * @fn      ZDODeviceSetup()
    249           *
    250           * @brief   Call set functions depending on the type of device compiled.
    251           *
    252           * @param   none
    253           *
    254           * @return  none
    255           */
    256          static void ZDODeviceSetup( void )
    257          {
    258            if ( ZG_BUILD_COORDINATOR_TYPE )
    259            {
    260              NLME_CoordinatorInit();
    261            }
    262          
    263          #if defined ( REFLECTOR )
    264            APS_ReflectorInit( (ZG_DEVICE_COORDINATOR_TYPE) ? APS_REFLECTOR_PUBLIC :  APS_REFLECTOR_PRIVATE );
    265          #endif
    266          
    267            if ( ZG_BUILD_JOINING_TYPE )
    268            {
    269              NLME_DeviceJoiningInit();
    270            }
    271          }
    272          
    273          /*********************************************************************
    274           * @fn          ZDO_StartDevice
    275           *
    276           * @brief       This function starts a device in a network.
    277           *
    278           * @param       logicalType     - Device type to start
    279           *              startMode       - indicates mode of device startup
    280           *              beaconOrder     - indicates time betwen beacons
    281           *              superframeOrder - indicates length of active superframe
    282           *
    283           * @return      none
    284           */
    285          void ZDO_StartDevice( byte logicalType, devStartModes_t startMode, byte beaconOrder, byte superframeOrder )
    286          {
    287            ZStatus_t ret;
    288          #if defined ( ZIGBEE_FREQ_AGILITY )
    289            static uint8 discRetries = 0;
    290          #endif
    291          #if defined ( ZIGBEE_COMMISSIONING )
    292            static uint8 scanCnt = 0;
    293          #endif
    294          
    295            ret = ZUnsupportedMode;
    296          
    297            if ( ZG_BUILD_COORDINATOR_TYPE && logicalType == NODETYPE_COORDINATOR )
    298            {
    299              if ( startMode == MODE_HARD )
    300              {
    301                devState = DEV_COORD_STARTING;
    302                ret = NLME_NetworkFormationRequest( zgConfigPANID, zgApsUseExtendedPANID, zgDefaultChannelList,
    303                                                    zgDefaultStartingScanDuration, beaconOrder,
    304                                                    superframeOrder, false );
    305              }
    306              else if ( startMode == MODE_RESUME )
    307              {
    308                // Just start the coordinator
    309                devState = DEV_COORD_STARTING;
    310                ret = NLME_StartRouterRequest( beaconOrder, beaconOrder, false );
    311              }
    312              else
    313              {
    314          #if defined( LCD_SUPPORTED )
    315                HalLcdWriteScreen( "StartDevice ERR", "MODE unknown" );
    316          #endif
    317              }
    318            }
    319          
    320            if ( ZG_BUILD_JOINING_TYPE && (logicalType == NODETYPE_ROUTER || logicalType == NODETYPE_DEVICE) )
    321            {
    322              if ( (startMode == MODE_JOIN) || (startMode == MODE_REJOIN) )
    323              {
    324                devState = DEV_NWK_DISC;
    325          
    326            #if defined( MANAGED_SCAN )
    327                ZDOManagedScan_Next();
    328                ret = NLME_NetworkDiscoveryRequest( managedScanChannelMask, BEACON_ORDER_15_MSEC );
    329            #else
    330                ret = NLME_NetworkDiscoveryRequest( zgDefaultChannelList, zgDefaultStartingScanDuration );
    331              #if defined ( ZIGBEE_FREQ_AGILITY )
    332                if ( !( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE ) &&
    333                      ( ret == ZSuccess ) && ( ++discRetries == 4 ) )
    334                {
    335                  // For devices with RxOnWhenIdle equals to FALSE, any network channel
    336                  // change will not be recieved. On these devices or routers that have
    337                  // lost the network, an active scan shall be conducted on the Default
    338                  // Channel list using the extended PANID to find the network. If the
    339                  // extended PANID isn't found using the Default Channel list, an scan
    340                  // should be completed using all channels.
    341                  zgDefaultChannelList = MAX_CHANNELS_24GHZ;
    342                }
    343              #endif // ZIGBEE_FREQ_AGILITY
    344              #if defined ( ZIGBEE_COMMISSIONING )
    345                if (startMode == MODE_REJOIN && scanCnt++ >= 5 )
    346                {
    347                  // When ApsUseExtendedPanID is commissioned to a non zero value via
    348                  // application specific means, the device shall conduct an active scan
    349                  // on the Default Channel list and join the PAN with the same
    350                  // ExtendedPanID. If the PAN is not found, an scan should be completed
    351                  // on all channels.
    352                  // When devices rejoin the network and the PAN is not found from
    353                  zgDefaultChannelList = MAX_CHANNELS_24GHZ;
    354                }
    355              #endif // ZIGBEE_COMMISSIONING
    356            #endif
    357              }
    358              else if ( startMode == MODE_RESUME )
    359              {
    360                if ( logicalType == NODETYPE_ROUTER )
    361                {
    362                  ZMacScanCnf_t scanCnf;
    363                  devState = DEV_NWK_ORPHAN;
    364          
    365                  /* if router and nvram is available, fake successful orphan scan */
    366                  scanCnf.hdr.Status = ZSUCCESS;
    367                  scanCnf.ScanType = ZMAC_ORPHAN_SCAN;
    368                  scanCnf.UnscannedChannels = 0;
    369                  scanCnf.ResultListSize = 0;
    370                  nwk_ScanJoiningOrphan(&scanCnf);
    371          
    372                  ret = ZSuccess;
    373                }
    374                else
    375                {
    376                  devState = DEV_NWK_ORPHAN;
    377                  ret = NLME_OrphanJoinRequest( zgDefaultChannelList,
    378                                                zgDefaultStartingScanDuration );
    379                }
    380              }
    381              else
    382              {
    383          #if defined( LCD_SUPPORTED )
    384                HalLcdWriteScreen( "StartDevice ERR", "MODE unknown" );
    385          #endif
    386              }
    387            }
    388          
    389            if ( ret != ZSuccess )
    390              osal_start_timerEx(ZDAppTaskID, ZDO_NETWORK_INIT, NWK_RETRY_DELAY );
    391          }
    392          
    393          /**************************************************************************************************
    394           * @fn          zdoSendStateChangeMsg
    395           *
    396           * @brief       Helper function for ZDO_UpdateNwkStatus.
    397           *
    398           * input parameters
    399           *
    400           * @param       taskId - The OSAL task identifier to which to send the ZDO_STATE_CHANGE_EVT.
    401           * @param       state - The current device state.
    402           *
    403           * output parameters
    404           *
    405           * None.
    406           *
    407           * @return      None.
    408           **************************************************************************************************
    409           */
    410          static void zdoSendStateChangeMsg(uint8 state, uint8 taskId)
    411          {
    412            osal_event_hdr_t *pMsg = (osal_event_hdr_t *)osal_msg_find(taskId, ZDO_STATE_CHANGE);
    413          
    414            if (NULL == pMsg)
    415            {
    416              if (NULL == (pMsg = (osal_event_hdr_t *)osal_msg_allocate(sizeof(osal_event_hdr_t))))
    417              {
    418                // Upon failure to notify any EndPoint of the state change, re-set the ZDO event to
    419                // try again later when more Heap may be available.
    420                osal_set_event(ZDAppTaskID, ZDO_STATE_CHANGE_EVT);
    421              }
    422              else
    423              {
    424                pMsg->event = ZDO_STATE_CHANGE;
    425                pMsg->status = state;
    426          
    427                (void)osal_msg_send(taskId, (uint8 *)pMsg);
    428              }
    429            }
    430            else
    431            {
    432              // Modify in place the status of an existing ZDO_STATE_CHANGE message to the EndPoint.
    433              pMsg->status = state;
    434            }
    435          }
    436          
    437          /**************************************************************************************************
    438           * @fn          ZDO_UpdateNwkStatus
    439           *
    440           * @brief       This function sends a ZDO_STATE_CHANGE message to the task of every EndPoint
    441           *              registered with AF (except, of course, the ZDO_EP). Even if a single task has more
    442           *              than one registered EndPoint, it will only receive one notification per state
    443           *              change. Although the device may go through a sequence of state changes, the
    444           *              Application task may only receive notification of the final, steady-state state
    445           *              because it has the lowest priority and never even runs to receive the intermediate
    446           *              state change notifications.
    447           *
    448           * input parameters
    449           *
    450           * @param       state - The current device state.
    451           *
    452           * output parameters
    453           *
    454           * None.
    455           *
    456           * @return      None.
    457           **************************************************************************************************
    458           */
    459          void ZDO_UpdateNwkStatus(devStates_t state)
    460          {
    461            epList_t *pItem = epList;
    462          
    463            while (pItem != NULL)
    464            {
    465              if (pItem->epDesc->endPoint != ZDO_EP)
    466              {
    467                zdoSendStateChangeMsg(state, *(pItem->epDesc->task_id));
    468              }
    469          
    470              pItem = pItem->nextDesc;
    471            }
    472          #if defined MT_ZDO_CB_FUNC
    473            zdoSendStateChangeMsg(state, MT_TaskID);
    474          #endif
    475          
    476            ZDAppNwkAddr.addr.shortAddr = NLME_GetShortAddr();
    477            (void)NLME_GetExtAddr();  // Load the saveExtAddr pointer.
    478          }
    479          
    480          #if defined ( REFLECTOR )
    481          /*********************************************************************
    482           * @fn          ZDO_RemoveEndDeviceBind
    483           *
    484           * @brief       Remove the end device bind
    485           *
    486           * @param  none
    487           *
    488           * @return      none
    489           */
    490          static void ZDO_RemoveEndDeviceBind( void )
    491          {
    492            if ( ZDO_EDBind != NULL )
    493            {
    494              // Free the RAM
    495              if ( ZDO_EDBind->inClusters != NULL )
    496                osal_mem_free( ZDO_EDBind->inClusters );
    497              if ( ZDO_EDBind->outClusters != NULL )
    498                osal_mem_free( ZDO_EDBind->outClusters );
    499              osal_mem_free( ZDO_EDBind );
    500              ZDO_EDBind = NULL;
    501            }
    502          }
    503          #endif // REFLECTOR
    504          
    505          #if defined ( REFLECTOR )
    506          /*********************************************************************
    507           * @fn          ZDO_RemoveEndDeviceBind
    508           *
    509           * @brief       Remove the end device bind
    510           *
    511           * @param  none
    512           *
    513           * @return      none
    514           */
    515          static void ZDO_SendEDBindRsp( byte TransSeq, zAddrType_t *dstAddr, byte Status, byte secUse )
    516          {
    517            ZDP_EndDeviceBindRsp( TransSeq, dstAddr, Status, secUse );
    518          
    519          #if defined( LCD_SUPPORTED )
    520            HalLcdWriteString( "End Device Bind", HAL_LCD_LINE_1 );
    521            if ( Status == ZDP_SUCCESS )
    522              HalLcdWriteString( "Success Sent", HAL_LCD_LINE_2 );
    523            else
    524              HalLcdWriteString( "Timeout", HAL_LCD_LINE_2 );
    525          #endif
    526          
    527          }
    528          #endif // REFLECTOR
    529          
    530          /*********************************************************************
    531           * @fn          ZDO_CompareClusterLists
    532           *
    533           * @brief       Compare one list to another list
    534           *
    535           * @param       numList1 - number of items in list 1
    536           * @param       list1 - first list of cluster IDs
    537           * @param       numList2 - number of items in list 2
    538           * @param       list2 - second list of cluster IDs
    539           * @param       pMatches - buffer to put matches
    540           *
    541           * @return      number of matches
    542           */
    543          static byte ZDO_CompareClusterLists( byte numList1, uint16 *list1,
    544                                    byte numList2, uint16 *list2, uint16 *pMatches )
    545          {
    546            byte x, y;
    547            uint16 z;
    548            byte numMatches = 0;
    549          
    550            // Check the first in against the seconds out
    551            for ( x = 0; x < numList1; x++ )
    552            {
    553              for ( y = 0; y < numList2; y++ )
    554              {
    555                z = list2[y];
    556                if ( list1[x] == z )
    557                  pMatches[numMatches++] = z;
    558              }
    559            }
    560          
    561            return ( numMatches );
    562          }
    563          
    564          /*********************************************************************
    565           * Utility functions
    566           */
    567          
    568          /*********************************************************************
    569           * @fn          ZDO_CompareByteLists
    570           *
    571           * @brief       Compares two lists for matches.
    572           *
    573           * @param       ACnt  - number of entries in list A
    574           * @param       AList  - List A
    575           * @param       BCnt  - number of entries in list B
    576           * @param       BList  - List B
    577           *
    578           * @return      true if a match is found
    579           */
    580          byte ZDO_AnyClusterMatches( byte ACnt, uint16 *AList, byte BCnt, uint16 *BList )
    581          {
    582            byte x, y;
    583          
    584            for ( x = 0; x < ACnt; x++ )
    585            {
    586              for ( y = 0; y < BCnt; y++ )
    587              {
    588                if ( AList[x] == BList[y] )
    589                {
    590                  return true;
    591                }
    592              }
    593            }
    594          
    595            return false;
    596          }
    597          
    598          /*********************************************************************
    599           * Callback functions from ZDProfile
    600           */
    601          
    602          /*********************************************************************
    603           * @fn          ZDO_ProcessNodeDescReq
    604           *
    605           * @brief       This function processes and responds to the
    606           *              Node_Desc_req message.
    607           *
    608           * @param       inMsg - incoming message
    609           *
    610           * @return      none
    611           */
    612          void ZDO_ProcessNodeDescReq( zdoIncomingMsg_t *inMsg )
    613          {
    614            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
    615            NodeDescriptorFormat_t *desc = NULL;
    616          
    617            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
    618            {
    619              desc = &ZDO_Config_Node_Descriptor;
    620            }
    621          
    622            if ( desc != NULL )
    623            {
    624              ZDP_NodeDescMsg( inMsg, aoi, desc );
    625            }
    626            else
    627            {
    628              ZDP_GenericRsp( inMsg->TransSeq, &(inMsg->srcAddr),
    629                        ZDP_INVALID_REQTYPE, aoi, Node_Desc_rsp, inMsg->SecurityUse );
    630            }
    631          }
    632          
    633          /*********************************************************************
    634           * @fn          ZDO_ProcessPowerDescReq
    635           *
    636           * @brief       This function processes and responds to the
    637           *              Node_Power_req message.
    638           *
    639           * @param       inMsg  - incoming request
    640           *
    641           * @return      none
    642           */
    643          void ZDO_ProcessPowerDescReq( zdoIncomingMsg_t *inMsg )
    644          {
    645            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
    646            NodePowerDescriptorFormat_t *desc = NULL;
    647          
    648            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
    649            {
    650              desc = &ZDO_Config_Power_Descriptor;
    651            }
    652          
    653            if ( desc != NULL )
    654            {
    655              ZDP_PowerDescMsg( inMsg, aoi, desc );
    656            }
    657            else
    658            {
    659              ZDP_GenericRsp( inMsg->TransSeq, &(inMsg->srcAddr),
    660                        ZDP_INVALID_REQTYPE, aoi, Power_Desc_rsp, inMsg->SecurityUse );
    661            }
    662          }
    663          
    664          /*********************************************************************
    665           * @fn          ZDO_ProcessSimpleDescReq
    666           *
    667           * @brief       This function processes and responds to the
    668           *              Simple_Desc_req message.
    669           *
    670           * @param       inMsg - incoming message (request)
    671           *
    672           * @return      none
    673           */
    674          void ZDO_ProcessSimpleDescReq( zdoIncomingMsg_t *inMsg )
    675          {
    676            SimpleDescriptionFormat_t *sDesc = NULL;
    677            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
    678            byte endPoint = inMsg->asdu[2];
    679            byte free = false;
    680            byte stat = ZDP_SUCCESS;
    681          
    682            if ( (endPoint == ZDO_EP) || (endPoint > MAX_ENDPOINTS) )
    683            {
    684              stat = ZDP_INVALID_EP;
    685            }
    686            else if ( aoi == ZDAppNwkAddr.addr.shortAddr )
    687            {
    688              free = afFindSimpleDesc( &sDesc, endPoint );
    689              if ( sDesc == NULL )
    690              {
    691                stat = ZDP_NOT_ACTIVE;
    692              }
    693            }
    694            else
    695            {
    696              if ( ZSTACK_ROUTER_BUILD )
    697              {
    698                stat = ZDP_DEVICE_NOT_FOUND;
    699              }
    700              else if ( ZSTACK_END_DEVICE_BUILD )
    701              {
    702                stat = ZDP_INVALID_REQTYPE;
    703              }
    704            }
    705          
    706            ZDP_SimpleDescMsg( inMsg, stat, sDesc );
    707          
    708            if ( free && sDesc )
    709            {
    710              osal_mem_free( sDesc );
    711            }
    712          }
    713          
    714          /*********************************************************************
    715           * @fn          ZDO_ProcessActiveEPReq
    716           *
    717           * @brief       This function processes and responds to the
    718           *              Active_EP_req message.
    719           *
    720           * @param       inMsg  - incoming message (request)
    721           *
    722           * @return      none
    723           */
    724          void ZDO_ProcessActiveEPReq( zdoIncomingMsg_t *inMsg )
    725          {
    726            byte cnt = 0;
    727            uint16 aoi;
    728            byte stat = ZDP_SUCCESS;
    729          
    730            aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
    731          
    732            if ( aoi == NLME_GetShortAddr() )
    733            {
    734              cnt = afNumEndPoints() - 1;  // -1 for ZDO endpoint descriptor
    735              afEndPoints( (uint8 *)ZDOBuildBuf, true );
    736            }
    737            else
    738            {
    739              stat = ZDP_INVALID_REQTYPE;
    740            }
    741          
    742            ZDP_ActiveEPRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat,
    743                            aoi, cnt, (uint8 *)ZDOBuildBuf, inMsg->SecurityUse );
    744          }
    745          
    746          /*********************************************************************
    747           * @fn          ZDO_ConvertOTAClusters
    748           *
    749           * @brief       This function will convert the over-the-air cluster list
    750           *              format to an internal format.
    751           *
    752           * @param       inMsg  - incoming message (request)
    753           *
    754           * @return      pointer to incremented inBuf
    755           */
    756          uint8 *ZDO_ConvertOTAClusters( uint8 cnt, uint8 *inBuf, uint16 *outList )
    757          {
    758            uint8 x;
    759          
    760            for ( x = 0; x < cnt; x++ )
    761            {
    762              // convert ota format to internal
    763              outList[x] = BUILD_UINT16( inBuf[0], inBuf[1] );
    764              inBuf += sizeof( uint16 );
    765            }
    766            return ( inBuf );
    767          }
    768          
    769          /*********************************************************************
    770           * @fn          ZDO_ProcessMatchDescReq
    771           *
    772           * @brief       This function processes and responds to the
    773           *              Match_Desc_req message.
    774           *
    775           * @param       inMsg  - incoming message (request)
    776           *
    777           * @return      none
    778           */
    779          void ZDO_ProcessMatchDescReq( zdoIncomingMsg_t *inMsg )
    780          {
    781            uint8 epCnt = 0;
    782            uint8 numInClusters;
    783            uint16 *inClusters = NULL;
    784            uint8 numOutClusters;
    785            uint16 *outClusters = NULL;
    786            epList_t *epDesc;
    787            SimpleDescriptionFormat_t *sDesc = NULL;
    788            uint8 allocated;
    789            uint8 *msg;
    790            uint16 aoi;
    791            uint16 profileID;
    792          
    793            // Parse the incoming message
    794            msg = inMsg->asdu;
    795            aoi = BUILD_UINT16( msg[0], msg[1] );
    796            profileID = BUILD_UINT16( msg[2], msg[3] );
    797            msg += 4;
    798          
    799            if ( ADDR_BCAST_NOT_ME == NLME_IsAddressBroadcast(aoi) )
    800            {
    801              ZDP_MatchDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_INVALID_REQTYPE,
    802                                    ZDAppNwkAddr.addr.shortAddr, 0, NULL, inMsg->SecurityUse );
    803              return;
    804            }
    805            else if ( (ADDR_NOT_BCAST == NLME_IsAddressBroadcast(aoi)) && (aoi != ZDAppNwkAddr.addr.shortAddr) )
    806            {
    807              ZDP_MatchDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_INVALID_REQTYPE,
    808                                       ZDAppNwkAddr.addr.shortAddr, 0, NULL, inMsg->SecurityUse );
    809              return;
    810            }
    811          
    812            if ((numInClusters = *msg++) &&
    813                (inClusters = (uint16*)osal_mem_alloc( numInClusters * sizeof( uint16 ) )))
    814            {
    815              msg = ZDO_ConvertOTAClusters( numInClusters, msg, inClusters );
    816            }
    817            else
    818            {
    819              numInClusters = 0;
    820            }
    821          
    822            if ((numOutClusters = *msg++) &&
    823                (outClusters = (uint16 *)osal_mem_alloc( numOutClusters * sizeof( uint16 ) )))
    824            {
    825              msg = ZDO_ConvertOTAClusters( numOutClusters, msg, outClusters );
    826            }
    827            else
    828            {
    829              numOutClusters = 0;
    830            }
    831          
    832            // First count the number of endpoints that match.
    833            epDesc = epList;
    834            while ( epDesc )
    835            {
    836              // Don't search endpoint 0 and check if response is allowed
    837              if ( epDesc->epDesc->endPoint != ZDO_EP && (epDesc->flags&eEP_AllowMatch) )
    838              {
    839                if ( epDesc->pfnDescCB )
    840                {
    841                  sDesc = (SimpleDescriptionFormat_t *)epDesc->pfnDescCB( AF_DESCRIPTOR_SIMPLE, epDesc->epDesc->endPoint );
    842                  allocated = TRUE;
    843                }
    844                else
    845                {
    846                  sDesc = epDesc->epDesc->simpleDesc;
    847                  allocated = FALSE;
    848                }
    849          
    850                if ( sDesc && sDesc->AppProfId == profileID )
    851                {
    852                  uint8 *uint8Buf = (uint8 *)ZDOBuildBuf;
    853          
    854                  // Are there matching input clusters?
    855                  if ((ZDO_AnyClusterMatches( numInClusters, inClusters,
    856                             sDesc->AppNumInClusters, sDesc->pAppInClusterList )) ||
    857                      // Are there matching output clusters?
    858                      (ZDO_AnyClusterMatches( numOutClusters, outClusters,
    859                             sDesc->AppNumOutClusters, sDesc->pAppOutClusterList )))
    860                  {
    861                    // Notify the endpoint of the match.
    862                    uint8 bufLen = sizeof( ZDO_MatchDescRspSent_t ) + (numOutClusters + numInClusters) * sizeof(uint16);
    863                    ZDO_MatchDescRspSent_t *pRspSent = (ZDO_MatchDescRspSent_t *) osal_msg_allocate( bufLen );
    864          
    865                    if (pRspSent)
    866                    {
    867                      pRspSent->hdr.event = ZDO_MATCH_DESC_RSP_SENT;
    868                      pRspSent->nwkAddr = inMsg->srcAddr.addr.shortAddr;
    869                      pRspSent->numInClusters = numInClusters;
    870                      pRspSent->numOutClusters = numOutClusters;
    871          
    872                      if (numInClusters)
    873                      {
    874                        pRspSent->pInClusters = (uint16*) (pRspSent + 1);
    875                        osal_memcpy(pRspSent->pInClusters, inClusters, numInClusters * sizeof(uint16));
    876                      }
    877                      else
    878                      {
    879                        pRspSent->pInClusters = NULL;
    880                      }
    881          
    882                      if (numOutClusters)
    883                      {
    884                        pRspSent->pOutClusters = (uint16*)(pRspSent + 1) + numInClusters;
    885                        osal_memcpy(pRspSent->pOutClusters, outClusters, numOutClusters * sizeof(uint16));
    886                      }
    887                      else
    888                      {
    889                        pRspSent->pOutClusters = NULL;
    890                      }
    891          
    892                      osal_msg_send( *epDesc->epDesc->task_id, (uint8 *)pRspSent );
    893                    }
    894          
    895                    uint8Buf[epCnt++] = sDesc->EndPoint;
    896                  }
    897                }
    898          
    899                if ( allocated )
    900                {
    901                  osal_mem_free( sDesc );
    902                }
    903              }
    904              epDesc = epDesc->nextDesc;
    905            }
    906          
    907            // Send the message only if at least one match found.
    908            if ( epCnt )
    909            {
    910              if ( ZSuccess == ZDP_MatchDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_SUCCESS,
    911                        ZDAppNwkAddr.addr.shortAddr, epCnt, (uint8 *)ZDOBuildBuf, inMsg->SecurityUse ) )
    912              {
    913          #if defined( LCD_SUPPORTED )
    914                HalLcdWriteScreen( "Match Desc Req", "Rsp Sent" );
    915          #endif
    916              }
    917            }
    918            else
    919            {
    920          #if defined( LCD_SUPPORTED )
    921              HalLcdWriteScreen( "Match Desc Req", "Non Matched" );
    922          #endif
    923            }
    924          
    925            if ( inClusters != NULL )
    926            {
    927              osal_mem_free( inClusters );
    928            }
    929            
    930            if ( outClusters != NULL )
    931            {
    932              osal_mem_free( outClusters );
    933            }
    934          }
    935          
    936          
    937          /*********************************************************************
    938           * @fn      ZDO_ProcessBindUnbindReq()
    939           *
    940           * @brief   Called to process a Bind or Unbind Request message.
    941           *
    942           * @param   inMsg  - incoming message (request)
    943           * @param   pReq - place to put parsed information
    944           *
    945           * @return  none
    946           */
    947          void ZDO_ProcessBindUnbindReq( zdoIncomingMsg_t *inMsg, ZDO_BindUnbindReq_t *pReq )
    948          {
    949            zAddrType_t SourceAddr;       // Binding Source addres
    950            byte bindStat;
    951          
    952            SourceAddr.addrMode = Addr64Bit;
    953            osal_cpyExtAddr( SourceAddr.addr.extAddr, pReq->srcAddress );
    954          
    955          
    956            // If the local device is not the primary binding cache
    957            // check the src address of the bind request.
    958            // If it is not the local device's extended address
    959            // discard the request.
    960            if ( !osal_ExtAddrEqual( SourceAddr.addr.extAddr, NLME_GetExtAddr()) ||
    961                  (pReq->dstAddress.addrMode != Addr64Bit &&
    962                   pReq->dstAddress.addrMode != AddrGroup) )
    963            {
    964              bindStat = ZDP_NOT_SUPPORTED;
    965            }
    966            else
    967            {
    968              // Check source & destination endpoints
    969              if ( (pReq->srcEndpoint == 0 || pReq->srcEndpoint > MAX_ENDPOINTS)
    970                  || (( pReq->dstAddress.addrMode == Addr64Bit ) &&
    971                      (pReq->dstEndpoint == 0 || pReq->dstEndpoint > MAX_ENDPOINTS)) )
    972              {
    973                bindStat = ZDP_INVALID_EP;
    974              }
    975              else
    976              {
    977                if ( inMsg->clusterID == Bind_req )
    978                {
    979                  // Assume the table is full
    980                  bindStat = ZDP_TABLE_FULL;
    981          
    982                  if ( bindNumOfEntries() < gNWK_MAX_BINDING_ENTRIES )
    983                  {
    984                    if ( APSME_BindRequest( pReq->srcEndpoint, pReq->clusterID,
    985                                   &(pReq->dstAddress), pReq->dstEndpoint ) == ZSuccess )
    986                    {
    987                      uint16 nwkAddr;
    988          
    989                      // valid entry
    990                      bindStat = ZDP_SUCCESS;
    991          
    992                      // Notify to save info into NV
    993                      ZDApp_NVUpdate();
    994          
    995                      // Check for the destination address
    996                      if ( pReq->dstAddress.addrMode == Addr64Bit )
    997                      {
    998                        if ( APSME_LookupNwkAddr( pReq->dstAddress.addr.extAddr, &nwkAddr ) == FALSE )
    999                        {
   1000                          ZDP_NwkAddrReq( pReq->dstAddress.addr.extAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   1001                        }
   1002                      }
   1003                    }
   1004                  }
   1005                }
   1006                else // Unbind_req
   1007                {
   1008                  if ( APSME_UnBindRequest( pReq->srcEndpoint, pReq->clusterID,
   1009                                 &(pReq->dstAddress), pReq->dstEndpoint ) == ZSuccess )
   1010                  {
   1011                    bindStat = ZDP_SUCCESS;
   1012          
   1013                    // Notify to save info into NV
   1014                    ZDApp_NVUpdate();
   1015                  }
   1016                  else
   1017                    bindStat = ZDP_NO_ENTRY;
   1018                }
   1019              }
   1020            }
   1021          
   1022            // Send back a response message
   1023            ZDP_SendData( &(inMsg->TransSeq), &(inMsg->srcAddr),
   1024                         (inMsg->clusterID | ZDO_RESPONSE_BIT), 1, &bindStat,
   1025                         inMsg->SecurityUse );
   1026          }
   1027          
   1028          /*********************************************************************
   1029           * @fn      ZDO_UpdateAddrManager
   1030           *
   1031           * @brief   Update the Address Manager.
   1032           *
   1033           * @param   nwkAddr - network address
   1034           * @param   extAddr - extended address
   1035           *
   1036           * @return  none
   1037           */
   1038          void ZDO_UpdateAddrManager( uint16 nwkAddr, uint8 *extAddr )
   1039          {
   1040            AddrMgrEntry_t addrEntry;
   1041          
   1042            // Update the address manager
   1043            addrEntry.user = ADDRMGR_USER_DEFAULT;
   1044            addrEntry.nwkAddr = nwkAddr;
   1045            AddrMgrExtAddrSet( addrEntry.extAddr, extAddr );
   1046            AddrMgrEntryUpdate( &addrEntry );
   1047          }
   1048          
   1049          /*********************************************************************
   1050           * @fn      ZDO_ProcessServerDiscReq
   1051           *
   1052           * @brief   Process the Server_Discovery_req message.
   1053           *
   1054           * @param   inMsg  - incoming message (request)
   1055           *
   1056           * @return  none
   1057           */
   1058          void ZDO_ProcessServerDiscReq( zdoIncomingMsg_t *inMsg )
   1059          {
   1060            uint16 serverMask = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   1061            uint16 matchMask = serverMask & ZDO_Config_Node_Descriptor.ServerMask;
   1062          
   1063            if ( matchMask )
   1064            {
   1065              ZDP_ServerDiscRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZSUCCESS,
   1066                          ZDAppNwkAddr.addr.shortAddr, matchMask, inMsg->SecurityUse );
   1067            }
   1068          }
   1069          
   1070          /*********************************************************************
   1071           * Call Back Functions from APS  - API
   1072           */
   1073          
   1074          /*********************************************************************
   1075           * @fn          ZDO_EndDeviceTimeoutCB
   1076           *
   1077           * @brief       This function handles the binding timer for the End
   1078           *              Device Bind command.
   1079           *
   1080           * @param       none
   1081           *
   1082           * @return      none
   1083           */
   1084          void ZDO_EndDeviceTimeoutCB( void )
   1085          {
   1086          #if defined ( REFLECTOR )
   1087            byte stat;
   1088            if ( ZDO_EDBind )
   1089            {
   1090              stat = ZDO_EDBind->status;
   1091          
   1092              // Send the response message to the first sent
   1093              ZDO_SendEDBindRsp( ZDO_EDBind->SrcTransSeq, &(ZDO_EDBind->SrcAddr),
   1094                                  stat, ZDO_EDBind->SecurityUse );
   1095          
   1096              ZDO_RemoveEndDeviceBind();
   1097            }
   1098          #endif  // REFLECTOR
   1099          }
   1100          
   1101          /*********************************************************************
   1102           * Optional Management Messages
   1103           */
   1104          
   1105          /*********************************************************************
   1106           * @fn          ZDO_ProcessMgmtLqiReq
   1107           *
   1108           * @brief       This function handles parsing the incoming Management
   1109           *              LQI request and generate the response.
   1110           *
   1111           *   Note:      This function will limit the number of items returned
   1112           *              to ZDO_MAX_LQI_ITEMS items.
   1113           *
   1114           * @param       inMsg - incoming message (request)
   1115           *
   1116           * @return      none
   1117           */
   1118          void ZDO_ProcessMgmtLqiReq( zdoIncomingMsg_t *inMsg )
   1119          {
   1120            byte x;
   1121            byte index;
   1122            byte numItems;
   1123            byte maxItems;
   1124            ZDP_MgmtLqiItem_t* table = NULL;
   1125            ZDP_MgmtLqiItem_t* item;
   1126            neighborEntry_t    entry;
   1127            byte aItems;
   1128            associated_devices_t *aDevice;
   1129            AddrMgrEntry_t  nwkEntry;
   1130            uint8 StartIndex = inMsg->asdu[0];
   1131          
   1132            // Get the number of neighbor items
   1133            NLME_GetRequest( nwkNumNeighborTableEntries, 0, &maxItems );
   1134          
   1135            // Get the number of associated items
   1136            aItems = (uint8)AssocCount( PARENT, CHILD_FFD_RX_IDLE );
   1137          
   1138            // Total number of items
   1139            maxItems += aItems;
   1140          
   1141            // Start with the supplied index
   1142            if ( maxItems > StartIndex )
   1143            {
   1144              numItems = maxItems - StartIndex;
   1145          
   1146              // limit the size of the list
   1147              if ( numItems > ZDO_MAX_LQI_ITEMS )
   1148                numItems = ZDO_MAX_LQI_ITEMS;
   1149          
   1150              // Allocate the memory to build the table
   1151              table = (ZDP_MgmtLqiItem_t*)osal_mem_alloc( (short)
   1152                        ( numItems * sizeof( ZDP_MgmtLqiItem_t ) ) );
   1153          
   1154              if ( table != NULL )
   1155              {
   1156                x = 0;
   1157                item = table;
   1158                index = StartIndex;
   1159          
   1160                // Loop through associated items and build list
   1161                for ( ; x < numItems; x++ )
   1162                {
   1163                  if ( index < aItems )
   1164                  {
   1165                    // get next associated device
   1166                    aDevice = AssocFindDevice( index++ );
   1167          
   1168                    // set basic fields
   1169                    item->panID   = _NIB.nwkPanId;
   1170                    osal_cpyExtAddr( item->extPanID, _NIB.extendedPANID );
   1171                    item->nwkAddr = aDevice->shortAddr;
   1172                    item->permit  = ZDP_MGMT_BOOL_UNKNOWN;
   1173                    item->depth   = 0xFF;
   1174                    item->lqi     = aDevice->linkInfo.rxLqi;
   1175          
   1176                    // set extented address
   1177                    nwkEntry.user    = ADDRMGR_USER_DEFAULT;
   1178                    nwkEntry.nwkAddr = aDevice->shortAddr;
   1179          
   1180                    if ( AddrMgrEntryLookupNwk( &nwkEntry ) == TRUE )
   1181                    {
   1182                      osal_cpyExtAddr( item->extAddr, nwkEntry.extAddr );
   1183                    }
   1184                    else
   1185                    {
   1186                      osal_memset( item->extAddr, 0xFF, Z_EXTADDR_LEN );
   1187                    }
   1188          
   1189                    // use association info to set other fields
   1190                    if ( aDevice->nodeRelation == PARENT )
   1191                    {
   1192                      if (  aDevice->shortAddr == 0 )
   1193                      {
   1194                        item->devType = ZDP_MGMT_DT_COORD;
   1195                        item->depth = 0;
   1196                      }
   1197                      else
   1198                      {
   1199                        item->devType = ZDP_MGMT_DT_ROUTER;
   1200                        item->depth = _NIB.nodeDepth - 1;
   1201                      }
   1202          
   1203                      item->rxOnIdle = ZDP_MGMT_BOOL_UNKNOWN;
   1204                      item->relation = ZDP_MGMT_REL_PARENT;
   1205                    }
   1206                    else
   1207                    {
   1208                      // If not parent, then it's a child
   1209                      item->depth = _NIB.nodeDepth + 1;
   1210          
   1211                      if ( aDevice->nodeRelation < CHILD_FFD )
   1212                      {
   1213                        item->devType = ZDP_MGMT_DT_ENDDEV;
   1214          
   1215                        if ( aDevice->nodeRelation == CHILD_RFD )
   1216                        {
   1217                          item->rxOnIdle = FALSE;
   1218                        }
   1219                        else
   1220                        {
   1221                          item->rxOnIdle = TRUE;
   1222                        }
   1223                      }
   1224                      else
   1225                      {
   1226                        item->devType = ZDP_MGMT_DT_ROUTER;
   1227          
   1228                        if ( aDevice->nodeRelation == CHILD_FFD )
   1229                        {
   1230                          item->rxOnIdle = FALSE;
   1231                        }
   1232                        else
   1233                        {
   1234                          item->rxOnIdle = TRUE;
   1235                        }
   1236                      }
   1237          
   1238                      item->relation = ZDP_MGMT_REL_CHILD;
   1239                    }
   1240          
   1241                    item++;
   1242                  }
   1243                  else
   1244                  {
   1245                    if ( StartIndex <= aItems )
   1246                      // Start with 1st neighbor
   1247                      index = 0;
   1248                    else
   1249                      // Start with >1st neighbor
   1250                      index = StartIndex - aItems;
   1251                    break;
   1252                  }
   1253                }
   1254          
   1255                // Loop through neighbor items and finish list
   1256                for ( ; x < numItems; x++ )
   1257                {
   1258                  // Add next neighbor table item
   1259                  NLME_GetRequest( nwkNeighborTable, index++, &entry );
   1260          
   1261                  // set ZDP_MgmtLqiItem_t fields
   1262                  item->panID    = entry.panId;
   1263                  osal_cpyExtAddr( item->extPanID, _NIB.extendedPANID );
   1264                  osal_memset( item->extAddr, 0xFF, Z_EXTADDR_LEN );
   1265                  item->nwkAddr  = entry.neighborAddress;
   1266                  item->rxOnIdle = ZDP_MGMT_BOOL_UNKNOWN;
   1267                  item->relation = ZDP_MGMT_REL_UNKNOWN;
   1268                  item->permit   = ZDP_MGMT_BOOL_UNKNOWN;
   1269                  item->depth    = 0xFF;
   1270                  item->lqi      = entry.linkInfo.rxLqi;
   1271          
   1272                  if ( item->nwkAddr == 0 )
   1273                  {
   1274                    item->devType = ZDP_MGMT_DT_COORD;
   1275                  }
   1276                  else
   1277                  {
   1278                    item->devType = ZDP_MGMT_DT_ROUTER;
   1279                  }
   1280          
   1281                  item++;
   1282                }
   1283              }
   1284            }
   1285            else
   1286            {
   1287              numItems = 0;
   1288            }
   1289          
   1290            // Send response
   1291            ZDP_MgmtLqiRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZSuccess, maxItems,
   1292                            StartIndex, numItems, table, false );
   1293          
   1294            if ( table )
   1295            {
   1296              osal_mem_free( table );
   1297            }
   1298          }
   1299          
   1300          /*********************************************************************
   1301           * @fn          ZDO_ProcessMgmtNwkDiscReq
   1302           *
   1303           * @brief       This function handles parsing the incoming Management
   1304           *              Network Discover request and starts the request.
   1305           *
   1306           * @param       inMsg - incoming message (request)
   1307           *
   1308           * @return      none
   1309           */
   1310          void ZDO_ProcessMgmtNwkDiscReq( zdoIncomingMsg_t *inMsg )
   1311          {
   1312            NLME_ScanFields_t scan;
   1313            uint8             index;
   1314            uint8             *msg;
   1315          
   1316            msg = inMsg->asdu;
   1317            scan.channels = osal_build_uint32( msg, 4 );
   1318            msg += 4;
   1319            scan.duration = *msg++;
   1320            index         = *msg;
   1321            scan.scanType = ZMAC_ACTIVE_SCAN;
   1322            scan.scanApp  = NLME_DISC_SCAN;
   1323          
   1324            // Save off the information to be used for the response
   1325            zdappMgmtNwkDiscReqInProgress          = true;
   1326            zdappMgmtNwkDiscRspAddr.addrMode       = Addr16Bit;
   1327            zdappMgmtNwkDiscRspAddr.addr.shortAddr = inMsg->srcAddr.addr.shortAddr;
   1328            zdappMgmtNwkDiscStartIndex             = index;
   1329            zdappMgmtNwkDiscRspTransSeq            = inMsg->TransSeq;
   1330          
   1331            if ( NLME_NwkDiscReq2( &scan ) != ZSuccess )
   1332            {
   1333              NLME_NwkDiscTerm();
   1334          
   1335              // zdappMgmtNwkDiscReqInProgress will be reset in the confirm callback
   1336            }
   1337          }
   1338          
   1339          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
   1340          /*********************************************************************
   1341           * @fn          ZDO_FinishProcessingMgmtNwkDiscReq
   1342           *
   1343           * @brief       This function finishes the processing of the Management
   1344           *              Network Discover Request and generates the response.
   1345           *
   1346           *   Note:      This function will limit the number of items returned
   1347           *              to ZDO_MAX_NWKDISC_ITEMS items.
   1348           *
   1349           * @param       ResultCountSrcAddr - source of the request
   1350           * @param       msg - pointer to incoming message
   1351           * @param       SecurityUse -
   1352           *
   1353           * @return      none
   1354           */
   1355          void ZDO_FinishProcessingMgmtNwkDiscReq( byte ResultCount,
   1356                                                   networkDesc_t *NetworkList )
   1357          {
   1358            byte count, i;
   1359            networkDesc_t *newDesc = NULL, *pList = NetworkList;
   1360          
   1361            if ( ZSTACK_ROUTER_BUILD )
   1362            {
   1363              // Look for my PanID.
   1364              while ( pList )
   1365              {
   1366                if ( pList->panId == _NIB.nwkPanId )
   1367                {
   1368                  break;
   1369                }
   1370          
   1371          
   1372                if ( !pList->nextDesc )
   1373                {
   1374                  break;
   1375                }
   1376                pList = pList->nextDesc;
   1377              }
   1378          
   1379          
   1380              // If my Pan not present (query to a star network ZC or an isolated ZR?),
   1381              // prepend it.
   1382              if ( !pList || (pList->panId != _NIB.nwkPanId) )
   1383              {
   1384                newDesc = (networkDesc_t *)osal_mem_alloc( sizeof( networkDesc_t ) );
   1385                if ( newDesc )
   1386                {
   1387                  byte pJoin;
   1388          
   1389                  newDesc->panId = _NIB.nwkPanId;
   1390                  newDesc->logicalChannel = _NIB.nwkLogicalChannel;
   1391                  newDesc->beaconOrder = _NIB.beaconOrder;
   1392                  newDesc->superFrameOrder = _NIB.superFrameOrder;
   1393                  newDesc->version = NLME_GetProtocolVersion();
   1394                  newDesc->stackProfile = zgStackProfile;
   1395                  //Extended PanID
   1396                  osal_cpyExtAddr( newDesc->extendedPANID, _NIB.extendedPANID);
   1397          
   1398                  ZMacGetReq( ZMacAssociationPermit, &pJoin );
   1399                  newDesc->chosenRouter = ((pJoin) ? ZDAppNwkAddr.addr.shortAddr :
   1400                                                     INVALID_NODE_ADDR);
   1401          
   1402                  newDesc->nextDesc = NetworkList;
   1403                  NetworkList = newDesc;
   1404                  ResultCount++;
   1405                }
   1406              }
   1407            }
   1408          
   1409            // Calc the count and apply a max count.
   1410            if ( zdappMgmtNwkDiscStartIndex > ResultCount )
   1411            {
   1412              count = 0;
   1413            }
   1414            else
   1415            {
   1416              count = ResultCount - zdappMgmtNwkDiscStartIndex;
   1417              if ( count > ZDO_MAX_NWKDISC_ITEMS )
   1418              {
   1419                count = ZDO_MAX_NWKDISC_ITEMS;
   1420              }
   1421          
   1422              // Move the list pointer up to the start index.
   1423              for ( i = 0; i < zdappMgmtNwkDiscStartIndex; i++ )
   1424              {
   1425                NetworkList = NetworkList->nextDesc;
   1426              }
   1427            }
   1428          
   1429            ZDP_MgmtNwkDiscRsp( zdappMgmtNwkDiscRspTransSeq,
   1430                               &zdappMgmtNwkDiscRspAddr, ZSuccess, ResultCount,
   1431                                zdappMgmtNwkDiscStartIndex,
   1432                                count,
   1433                                NetworkList,
   1434                                false );
   1435          
   1436            if ( ZSTACK_ROUTER_BUILD )
   1437            {
   1438              if ( newDesc != NULL )
   1439              {
   1440                osal_mem_free( newDesc );
   1441              }
   1442            }
   1443          
   1444            NLME_NwkDiscTerm();
   1445          }
   1446          #endif
   1447          
   1448          /*********************************************************************
   1449           * @fn          ZDO_ProcessMgmtRtgReq
   1450           *
   1451           * @brief       This function finishes the processing of the Management
   1452           *              Routing Request and generates the response.
   1453           *
   1454           *   Note:      This function will limit the number of items returned
   1455           *              to ZDO_MAX_RTG_ITEMS items.
   1456           *
   1457           * @param       inMsg - incoming message (request)
   1458           *
   1459           * @return      none
   1460           */
   1461          void ZDO_ProcessMgmtRtgReq( zdoIncomingMsg_t *inMsg )
   1462          {
   1463            byte x;
   1464            byte maxNumItems;
   1465            byte numItems = 0;
   1466            uint8 *pBuf = NULL;
   1467            rtgItem_t *pList;
   1468            uint8 StartIndex = inMsg->asdu[0];
   1469          
   1470            // Get the number of table items
   1471            NLME_GetRequest( nwkNumRoutingTableEntries, 0, &maxNumItems );
   1472          
   1473            if ( maxNumItems > StartIndex )
   1474            {
   1475              numItems = maxNumItems - StartIndex;    // Start at the passed in index
   1476          
   1477              // limit the size of the list
   1478              if ( numItems > ZDO_MAX_RTG_ITEMS )
   1479              {
   1480                numItems = ZDO_MAX_RTG_ITEMS;
   1481              }
   1482          
   1483              // Allocate the memory to build the table
   1484              pBuf = osal_mem_alloc( (short)(sizeof( rtgItem_t ) * numItems) );
   1485          
   1486              if ( pBuf != NULL )
   1487              {
   1488                // Convert buffer to list
   1489                pList = (rtgItem_t *)pBuf;
   1490          
   1491                // Loop through items and build list
   1492                for ( x = 0; x < numItems; x++ )
   1493                {
   1494                  NLME_GetRequest( nwkRoutingTable, (uint16)(x + StartIndex), (void*)pList );
   1495          
   1496                  // Remap the status to the RoutingTableList Record Format defined in the ZigBee spec
   1497                  switch( pList->status )
   1498                  {
   1499                    case RT_ACTIVE:
   1500                      pList->status = ZDO_MGMT_RTG_ENTRY_ACTIVE;
   1501                      break;
   1502          
   1503                    case RT_DISC:
   1504                      pList->status = ZDO_MGMT_RTG_ENTRY_DISCOVERY_UNDERWAY;
   1505                      break;
   1506          
   1507                    case RT_LINK_FAIL:
   1508                      pList->status = ZDO_MGMT_RTG_ENTRY_DISCOVERY_FAILED;
   1509          
   1510                    case RT_INIT:
   1511                    case RT_REPAIR:
   1512                    default:
   1513                      pList->status = ZDO_MGMT_RTG_ENTRY_INACTIVE;
   1514                      break;
   1515                  }
   1516          
   1517                  // Increment pointer to next record
   1518                  pList++;
   1519                }
   1520              }
   1521              else
   1522              {
   1523                numItems = 0;
   1524              }
   1525            }
   1526          
   1527            // Send response
   1528            ZDP_MgmtRtgRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZSuccess, maxNumItems, StartIndex, numItems,
   1529                                  (rtgItem_t *)pBuf, false );
   1530          
   1531            if ( pBuf )
   1532            {
   1533              osal_mem_free( pBuf );
   1534            }
   1535          }
   1536          
   1537          /*********************************************************************
   1538           * @fn          ZDO_ProcessMgmtBindReq
   1539           *
   1540           * @brief       This function finishes the processing of the Management
   1541           *              Bind Request and generates the response.
   1542           *
   1543           *   Note:      This function will limit the number of items returned
   1544           *              to ZDO_MAX_BIND_ITEMS items.
   1545           *
   1546           * @param       inMsg - incoming message (request)
   1547           *
   1548           * @return      none
   1549           */
   1550          void ZDO_ProcessMgmtBindReq( zdoIncomingMsg_t *inMsg )
   1551          {
   1552          #if defined ( REFLECTOR )
   1553            byte x;
   1554            uint16 maxNumItems;
   1555            uint16 numItems;
   1556            uint8 *pBuf = NULL;
   1557            apsBindingItem_t *pList;
   1558            uint8 StartIndex = inMsg->asdu[0];
   1559            uint8 status;
   1560          
   1561            // Get the number of table items
   1562            APSME_GetRequest( apsNumBindingTableEntries, 0, (byte*)(&maxNumItems) );
   1563          
   1564            if ( maxNumItems > StartIndex )
   1565            {
   1566              numItems = maxNumItems - StartIndex;    // Start at the passed in index
   1567            }
   1568            else
   1569            {
   1570              numItems = 0;
   1571            }
   1572          
   1573            // limit the size of the list
   1574            if ( numItems > ZDO_MAX_BIND_ITEMS )
   1575            {
   1576              numItems = ZDO_MAX_BIND_ITEMS;
   1577            }
   1578          
   1579            // Allocate the memory to build the table
   1580            if ( numItems && (pBuf = osal_mem_alloc( sizeof( apsBindingItem_t ) * numItems )) )
   1581            {
   1582              status = ZSuccess;
   1583          
   1584              // Convert buffer to list
   1585              pList = (apsBindingItem_t *)pBuf;
   1586          
   1587              // Loop through items and build list
   1588              for ( x = 0; x < numItems; x++ )
   1589              {
   1590                APSME_GetRequest( apsBindingTable, (x + StartIndex), (void*)pList );
   1591                pList++;
   1592              }
   1593          
   1594            }
   1595            else
   1596            {
   1597              status = ZDP_NOT_PERMITTED;
   1598              numItems = 0;
   1599            }
   1600          
   1601            // Send response
   1602            ZDP_MgmtBindRsp( inMsg->TransSeq, &(inMsg->srcAddr), status, (byte)maxNumItems, StartIndex,
   1603                             (byte)numItems, (apsBindingItem_t *)pBuf, false );
   1604          
   1605            if ( pBuf )
   1606            {
   1607              osal_mem_free( pBuf );
   1608            }
   1609          #else
   1610            (void)inMsg;
   1611          #endif
   1612          }
   1613          
   1614          /*********************************************************************
   1615           * @fn          ZDO_ProcessMgmtDirectJoinReq
   1616           *
   1617           * @brief       This function finishes the processing of the Management
   1618           *              Direct Join Request and generates the response.
   1619           *
   1620           * @param       inMsg - incoming message (request)
   1621           *
   1622           * @return      none
   1623           */
   1624          void ZDO_ProcessMgmtDirectJoinReq( zdoIncomingMsg_t *inMsg )
   1625          {
   1626            uint8 *deviceAddr;
   1627            uint8 capInfo;
   1628            uint8 stat;
   1629          
   1630            // Parse the message
   1631            deviceAddr = inMsg->asdu;
   1632            capInfo = inMsg->asdu[Z_EXTADDR_LEN];
   1633          
   1634            stat = (byte) NLME_DirectJoinRequest( deviceAddr, capInfo );
   1635          
   1636            ZDP_MgmtDirectJoinRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat, false );
   1637          }
   1638          
   1639          /*********************************************************************
   1640           * @fn          ZDO_ProcessMgmtLeaveReq
   1641           *
   1642           * @brief       This function processes a Management Leave Request
   1643           *              and generates the response.
   1644           *
   1645           * @param       inMsg - incoming message (request)
   1646           *
   1647           * @return      none
   1648           */
   1649          void ZDO_ProcessMgmtLeaveReq( zdoIncomingMsg_t *inMsg )
   1650          {
   1651            NLME_LeaveReq_t req;
   1652            ZStatus_t       status;
   1653            uint8           option;
   1654            uint8 *msg = inMsg->asdu;
   1655          
   1656            if ( ( AddrMgrExtAddrValid( msg ) == FALSE                 ) ||
   1657                 ( osal_ExtAddrEqual( msg, NLME_GetExtAddr() ) == TRUE )    )
   1658            {
   1659              // Remove this device
   1660              req.extAddr = NULL;
   1661            }
   1662            else
   1663            {
   1664              // Remove child device
   1665              req.extAddr = msg;
   1666            }
   1667          
   1668            option = msg[Z_EXTADDR_LEN];
   1669            if ( option & ZDP_MGMT_LEAVE_REQ_RC )
   1670            {
   1671              req.removeChildren = TRUE;
   1672            }
   1673          
   1674            if ( option & ZDP_MGMT_LEAVE_REQ_REJOIN )
   1675            {
   1676               req.rejoin = TRUE;
   1677            }
   1678          
   1679            req.silent = FALSE;
   1680          
   1681            status = NLME_LeaveReq( &req );
   1682          
   1683            ZDP_MgmtLeaveRsp( inMsg->TransSeq, &(inMsg->srcAddr), status, FALSE );
   1684          }
   1685          
   1686          
   1687          /*********************************************************************
   1688           * @fn          ZDO_ProcessMgmtPermitJoinReq
   1689           *
   1690           * @brief       This function processes a Management Permit Join Request
   1691           *              and generates the response.
   1692           *
   1693           * @param       inMsg - incoming message (request)
   1694           *
   1695           * @return      none
   1696           */
   1697          void ZDO_ProcessMgmtPermitJoinReq( zdoIncomingMsg_t *inMsg )
   1698          {
   1699            uint8 stat;
   1700            uint8 duration;
   1701            uint8 tcsig;
   1702          
   1703            duration = inMsg->asdu[ZDP_MGMT_PERMIT_JOIN_REQ_DURATION];
   1704            tcsig    = inMsg->asdu[ZDP_MGMT_PERMIT_JOIN_REQ_TC_SIG];
   1705          
   1706            // Set the network layer permit join duration
   1707            stat = (byte) NLME_PermitJoiningRequest( duration );
   1708          
   1709            // Handle the Trust Center Significance
   1710            if ( ZG_SECURE_ENABLED && ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
   1711            {
   1712              if ( tcsig == TRUE )
   1713              {
   1714                ZDSecMgrPermitJoining( duration );
   1715              }
   1716            }
   1717          
   1718            // Send a response if unicast
   1719            if (inMsg->srcAddr.addr.shortAddr != NWK_BROADCAST_SHORTADDR)
   1720            {
   1721              ZDP_MgmtPermitJoinRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat, false );
   1722            }
   1723          }
   1724          
   1725          /*
   1726           * This function stub allows the next higher layer to be notified of
   1727           * a permit joining timeout.
   1728           */
   1729          /*********************************************************************
   1730           * @fn          ZDO_ProcessMgmtPermitJoinTimeout
   1731           *
   1732           * @brief       This function stub allows the next higher layer to be
   1733           *              notified of a permit joining timeout. Currently, this
   1734           *              directly bypasses the APS layer.
   1735           *
   1736           * @param       none
   1737           *
   1738           * @return      none
   1739           */
   1740          void ZDO_ProcessMgmtPermitJoinTimeout( void )
   1741          {
   1742            #if defined( ZDO_MGMT_PERMIT_JOIN_RESPONSE )
   1743            // Currently, only the ZDSecMgr needs to be notified
   1744            if ( ZG_SECURE_ENABLED && ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
   1745            {
   1746              ZDSecMgrPermitJoiningTimeout();
   1747            }
   1748            #endif
   1749          }
   1750          
   1751          /*********************************************************************
   1752           * @fn          ZDO_ProcessUserDescReq
   1753           *
   1754           * @brief       This function finishes the processing of the User
   1755           *              Descriptor Request and generates the response.
   1756           *
   1757           * @param       inMsg - incoming message (request)
   1758           *
   1759           * @return      none
   1760           */
   1761          void ZDO_ProcessUserDescReq( zdoIncomingMsg_t *inMsg )
   1762          {
   1763            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   1764            UserDescriptorFormat_t userDesc;
   1765          
   1766            if ( (aoi == ZDAppNwkAddr.addr.shortAddr) && (ZSUCCESS == osal_nv_read(
   1767                       ZCD_NV_USERDESC, 0, sizeof(UserDescriptorFormat_t), &userDesc )) )
   1768            {
   1769              ZDP_UserDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), aoi, &userDesc, false );
   1770            }
   1771            else
   1772            {
   1773              ZDP_GenericRsp(inMsg->TransSeq, &(inMsg->srcAddr),
   1774                     ZDP_NOT_SUPPORTED, aoi, User_Desc_rsp, inMsg->SecurityUse );
   1775            }
   1776          }
   1777          
   1778          /*********************************************************************
   1779           * @fn          ZDO_ProcessUserDescSet
   1780           *
   1781           * @brief       This function finishes the processing of the User
   1782           *              Descriptor Set and generates the response.
   1783           *
   1784           * @param       inMsg - incoming message (request)
   1785           *
   1786           * @return      none
   1787           */
   1788          void ZDO_ProcessUserDescSet( zdoIncomingMsg_t *inMsg )
   1789          {
   1790            uint8 *msg;
   1791            uint16 aoi;
   1792            UserDescriptorFormat_t userDesc;
   1793            uint8 outMsg[3];
   1794            uint8 status;
   1795          
   1796            msg = inMsg->asdu;
   1797            aoi = BUILD_UINT16( msg[0], msg[1] );
   1798          
   1799            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   1800            {
   1801              userDesc.len = (msg[2] < AF_MAX_USER_DESCRIPTOR_LEN) ? msg[2] : AF_MAX_USER_DESCRIPTOR_LEN;
   1802              msg ++;  // increment one for the length field
   1803          
   1804              osal_memcpy( userDesc.desc, &msg[2], userDesc.len );
   1805              osal_nv_write( ZCD_NV_USERDESC, 0, sizeof(UserDescriptorFormat_t), &userDesc );
   1806              if ( userDesc.len != 0 )
   1807              {
   1808                ZDO_Config_Node_Descriptor.UserDescAvail = TRUE;
   1809              }
   1810              else
   1811              {
   1812                ZDO_Config_Node_Descriptor.UserDescAvail = FALSE;
   1813              }
   1814          
   1815              status = ZDP_SUCCESS;
   1816            }
   1817            else
   1818            {
   1819              status =  ZDP_NOT_SUPPORTED;
   1820            }
   1821          
   1822            outMsg[0] = status;
   1823            outMsg[1] = LO_UINT16( aoi );
   1824            outMsg[2] = LO_UINT16( aoi );
   1825          
   1826            ZDP_SendData( &(inMsg->TransSeq), &(inMsg->srcAddr), User_Desc_conf, 3, outMsg,
   1827                         inMsg->SecurityUse );
   1828          }
   1829          
   1830          /*********************************************************************
   1831           * @fn          ZDO_ProcessDeviceAnnce
   1832           *
   1833           * @brief       This function processes a device annouce message.
   1834           *
   1835           * @param       inMsg - incoming message
   1836           *
   1837           * @return      none
   1838           */
   1839          void ZDO_ProcessDeviceAnnce( zdoIncomingMsg_t *inMsg )
   1840          {
   1841            ZDO_DeviceAnnce_t Annce;
   1842            AddrMgrEntry_t addrEntry;
   1843            uint8 parentExt[Z_EXTADDR_LEN];
   1844          
   1845            // Parse incoming message
   1846            ZDO_ParseDeviceAnnce( inMsg, &Annce );
   1847          
   1848            if ( ZSTACK_END_DEVICE_BUILD )
   1849            {
   1850              // Make sure the message didn't come from myself - end device only
   1851              if ( osal_ExtAddrEqual( NLME_GetExtAddr(), Annce.extAddr ) && Annce.nwkAddr == NLME_GetShortAddr() )
   1852              {
   1853                return;
   1854              }
   1855            }
   1856          
   1857          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
   1858            // Clean up the neighbor table
   1859            nwkNeighborRemoveAllStranded();
   1860          
   1861            // If address conflict is detected, no need to update the address manager
   1862            if ( NLME_CheckNewAddrSet( Annce.nwkAddr, Annce.extAddr )== ZFailure )
   1863            {
   1864              return;
   1865            }
   1866          #endif
   1867          
   1868          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
   1869            // Check for parent's address
   1870            NLME_GetCoordExtAddr( parentExt );
   1871            if ( osal_ExtAddrEqual( parentExt, Annce.extAddr ) )
   1872            {
   1873              if ( Annce.nwkAddr != NLME_GetCoordShortAddr() )
   1874              {
   1875                // Set the Parent's MAC's new short address
   1876                _NIB.nwkCoordAddress = Annce.nwkAddr;
   1877                ZMacSetReq( ZMacCoordShortAddress, (byte*)&(_NIB.nwkCoordAddress) );
   1878              }
   1879            }
   1880          
   1881            if ( ZSTACK_ROUTER_BUILD )
   1882            {
   1883              // If the device annce comes from a end device child that has moved
   1884              // to another parent, remove it from associated device list
   1885          
   1886              // If the dev annce is coming from other device's children,
   1887              // (The dev annce from its own children shall be unicast to itself,
   1888              // So check the mac destination address)
   1889              // Remove it from the associated device list. If it is not
   1890              // a child, no action will be taken in AssocRemove() anyway.
   1891              if ( inMsg->macDestAddr != NLME_GetShortAddr() )
   1892              {
   1893                associated_devices_t *dev_ptr;
   1894          
   1895                // If it's an end device child
   1896                dev_ptr = AssocGetWithExt( Annce.extAddr );
   1897                if ( dev_ptr )
   1898                {
   1899                  if ( dev_ptr->nodeRelation == CHILD_RFD ||
   1900                       dev_ptr->nodeRelation == CHILD_RFD_RX_IDLE )
   1901                  {
   1902                    AssocRemove( Annce.extAddr );
   1903                  }
   1904                }
   1905              }
   1906          
   1907              if ( Annce.nwkAddr != NLME_GetShortAddr() )
   1908              {
   1909                // If an associated device is found with matched extended Address,
   1910                // update its short address
   1911                if ( AssocChangeNwkAddr( Annce.nwkAddr, Annce.extAddr ) )
   1912                {
   1913                  // Update the neighbor table
   1914                  nwkNeighborUpdateNwkAddr( Annce.nwkAddr, Annce.extAddr );
   1915          
   1916                  // Set event to save NV
   1917                  ZDApp_NVUpdate();
   1918                }
   1919              }
   1920            }
   1921            
   1922            // Assume that the device has moved, remove existing routing entries
   1923            RTG_RemoveRtgEntry( Annce.nwkAddr, 0 );
   1924            
   1925          #endif // ZIGBEE_STOCHASTIC_ADDRESSING
   1926          
   1927          
   1928            // Fill in the extended address in address manager if we don't have it already.
   1929            addrEntry.user = ADDRMGR_USER_DEFAULT;
   1930            addrEntry.nwkAddr = Annce.nwkAddr;
   1931            if ( AddrMgrEntryLookupNwk( &addrEntry ) )
   1932            {
   1933              osal_memset( parentExt, 0, Z_EXTADDR_LEN );
   1934              if ( osal_ExtAddrEqual( parentExt, addrEntry.extAddr ) )
   1935              {
   1936                AddrMgrExtAddrSet( addrEntry.extAddr, Annce.extAddr );
   1937                AddrMgrEntryUpdate( &addrEntry );
   1938              }
   1939            }
   1940          }
   1941          
   1942          /*********************************************************************
   1943           * @fn          ZDO_BuildSimpleDescBuf
   1944           *
   1945           * @brief       Build a byte sequence representation of a Simple Descriptor.
   1946           *
   1947           * @param       buf  - pointer to a byte array big enough for data.
   1948           * @param       desc - SimpleDescriptionFormat_t *
   1949           *
   1950           * @return      none
   1951           */
   1952          void ZDO_BuildSimpleDescBuf( uint8 *buf, SimpleDescriptionFormat_t *desc )
   1953          {
   1954            byte cnt;
   1955            uint16 *ptr;
   1956          
   1957            *buf++ = desc->EndPoint;
   1958            *buf++ = HI_UINT16( desc->AppProfId );
   1959            *buf++ = LO_UINT16( desc->AppProfId );
   1960            *buf++ = HI_UINT16( desc->AppDeviceId );
   1961            *buf++ = LO_UINT16( desc->AppDeviceId );
   1962          
   1963            *buf++ = (byte)(desc->AppDevVer << 4);
   1964          
   1965            *buf++ = desc->AppNumInClusters;
   1966            ptr = desc->pAppInClusterList;
   1967            for ( cnt = 0; cnt < desc->AppNumInClusters; ptr++, cnt++ )
   1968            {
   1969              *buf++ = HI_UINT16( *ptr );
   1970              *buf++ = LO_UINT16( *ptr );
   1971            }
   1972          
   1973            *buf++ = desc->AppNumOutClusters;
   1974            ptr = desc->pAppOutClusterList;
   1975            for ( cnt = 0; cnt < desc->AppNumOutClusters; ptr++, cnt++ )
   1976            {
   1977              *buf++ = HI_UINT16( *ptr );
   1978              *buf++ = LO_UINT16( *ptr );
   1979            }
   1980          }
   1981          
   1982          /*********************************************************************
   1983           * @fn      ZDO_MatchEndDeviceBind()
   1984           *
   1985           * @brief
   1986           *
   1987           *   Called to match end device binding requests
   1988           *
   1989           * @param  bindReq  - binding request information
   1990           * @param  SecurityUse - Security enable/disable
   1991           *
   1992           * @return  none
   1993           */
   1994          void ZDO_MatchEndDeviceBind( ZDEndDeviceBind_t *bindReq )
   1995          {
   1996            zAddrType_t dstAddr;
   1997            uint8 sendRsp = FALSE;
   1998            uint8 status;
   1999          
   2000            // Is this the first request?
   2001            if ( matchED == NULL )
   2002            {
   2003              // Create match info structure
   2004              matchED = (ZDMatchEndDeviceBind_t *)osal_mem_alloc( sizeof ( ZDMatchEndDeviceBind_t ) );
   2005              if ( matchED )
   2006              {
   2007                // Clear the structure
   2008                osal_memset( (uint8 *)matchED, 0, sizeof ( ZDMatchEndDeviceBind_t ) );
   2009          
   2010                // Copy the first request's information
   2011                if ( !ZDO_CopyMatchInfo( &(matchED->ed1), bindReq ) )
   2012                {
   2013          
   2014                  status = ZDP_NO_ENTRY;
   2015                  sendRsp = TRUE;
   2016                }
   2017              }
   2018              else
   2019              {
   2020                status = ZDP_NO_ENTRY;
   2021                sendRsp = TRUE;
   2022              }
   2023          
   2024              if ( !sendRsp )
   2025              {
   2026                // Set into the correct state
   2027                matchED->state = ZDMATCH_WAIT_REQ;
   2028          
   2029                // Setup the timeout
   2030                APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceBindMatchTimeoutCB );
   2031              }
   2032            }
   2033            else
   2034            {
   2035                matchED->state = ZDMATCH_SENDING_BINDS;
   2036          
   2037                // Copy the 2nd request's information
   2038                if ( !ZDO_CopyMatchInfo( &(matchED->ed2), bindReq ) )
   2039                {
   2040                  status = ZDP_NO_ENTRY;
   2041                  sendRsp = TRUE;
   2042                }
   2043          
   2044                // Make a source match for ed1
   2045                matchED->ed1numMatched = ZDO_CompareClusterLists(
   2046                            matchED->ed1.numOutClusters, matchED->ed1.outClusters,
   2047                            matchED->ed2.numInClusters, matchED->ed2.inClusters, ZDOBuildBuf );
   2048                if ( matchED->ed1numMatched )
   2049                {
   2050                  // Save the match list
   2051                  matchED->ed1Matched = osal_mem_alloc( (short)(matchED->ed1numMatched * sizeof ( uint16 )) );
   2052                  if ( matchED->ed1Matched )
   2053                  {
   2054                    osal_memcpy( matchED->ed1Matched, ZDOBuildBuf, (matchED->ed1numMatched * sizeof ( uint16 )) );
   2055                  }
   2056                  else
   2057                  {
   2058                    // Allocation error, stop
   2059                    status = ZDP_NO_ENTRY;
   2060                    sendRsp = TRUE;
   2061                  }
   2062                }
   2063          
   2064                // Make a source match for ed2
   2065                matchED->ed2numMatched = ZDO_CompareClusterLists(
   2066                            matchED->ed2.numOutClusters, matchED->ed2.outClusters,
   2067                            matchED->ed1.numInClusters, matchED->ed1.inClusters, ZDOBuildBuf );
   2068                if ( matchED->ed2numMatched )
   2069                {
   2070                  // Save the match list
   2071                  matchED->ed2Matched = osal_mem_alloc( (short)(matchED->ed2numMatched * sizeof ( uint16 )) );
   2072                  if ( matchED->ed2Matched )
   2073                  {
   2074                    osal_memcpy( matchED->ed2Matched, ZDOBuildBuf, (matchED->ed2numMatched * sizeof ( uint16 )) );
   2075                  }
   2076                  else
   2077                  {
   2078                    // Allocation error, stop
   2079                    status = ZDP_NO_ENTRY;
   2080                    sendRsp = TRUE;
   2081                  }
   2082                }
   2083          
   2084                if ( (sendRsp == FALSE) && (matchED->ed1numMatched || matchED->ed2numMatched) )
   2085                {
   2086                  // Do the first unbind/bind state
   2087                  ZDMatchSendState( ZDMATCH_REASON_START, ZDP_SUCCESS, 0 );
   2088                }
   2089                else
   2090                {
   2091                  status = ZDP_NO_MATCH;
   2092                  sendRsp = TRUE;
   2093                }
   2094            }
   2095          
   2096            if ( sendRsp )
   2097            {
   2098              // send response to this requester
   2099              dstAddr.addrMode = Addr16Bit;
   2100              dstAddr.addr.shortAddr = bindReq->srcAddr;
   2101              ZDP_EndDeviceBindRsp( bindReq->TransSeq, &dstAddr, status, bindReq->SecurityUse );
   2102          
   2103              if ( matchED->state == ZDMATCH_SENDING_BINDS )
   2104              {
   2105                // send response to first requester
   2106                dstAddr.addrMode = Addr16Bit;
   2107                dstAddr.addr.shortAddr = matchED->ed1.srcAddr;
   2108                ZDP_EndDeviceBindRsp( matchED->ed1.TransSeq, &dstAddr, status, matchED->ed1.SecurityUse );
   2109              }
   2110          
   2111              // Process ended - release memory used
   2112              ZDO_RemoveMatchMemory();
   2113            }
   2114          }
   2115          
   2116          /*********************************************************************
   2117           * @fn      ZDO_RemoveMatchMemory()
   2118           *
   2119           * @brief   Called to clear the memory used for the end device bind.
   2120           *
   2121           * @param  none
   2122           *
   2123           * @return  none
   2124           */
   2125          static void ZDO_RemoveMatchMemory( void )
   2126          {
   2127            if ( matchED != NULL )
   2128            {
   2129              if ( matchED->ed2Matched != NULL )
   2130                osal_mem_free( matchED->ed2Matched );
   2131              if ( matchED->ed1Matched != NULL )
   2132                osal_mem_free( matchED->ed1Matched );
   2133          
   2134              if ( matchED->ed1.inClusters != NULL )
   2135                osal_mem_free( matchED->ed1.inClusters );
   2136          
   2137              if ( matchED->ed1.outClusters != NULL )
   2138                osal_mem_free( matchED->ed1.outClusters );
   2139          
   2140              if ( matchED->ed2.inClusters != NULL )
   2141                osal_mem_free( matchED->ed2.inClusters );
   2142          
   2143              if ( matchED->ed2.outClusters != NULL )
   2144                osal_mem_free( matchED->ed2.outClusters );
   2145          
   2146              osal_mem_free( matchED );
   2147          
   2148              matchED = (ZDMatchEndDeviceBind_t *)NULL;
   2149            }
   2150          }
   2151          
   2152          /*********************************************************************
   2153           * @fn      ZDO_CopyMatchInfo()
   2154           *
   2155           * @brief   Called to copy memory used for the end device bind.
   2156           *
   2157           * @param  srcReq - source information
   2158           * @param  dstReq - destination location
   2159           *
   2160           * @return  TRUE if copy was successful.
   2161           */
   2162          static uint8 ZDO_CopyMatchInfo( ZDEndDeviceBind_t *destReq, ZDEndDeviceBind_t *srcReq )
   2163          {
   2164            uint8 allOK = TRUE;
   2165          
   2166            // Copy bind information into the match info structure
   2167            osal_memcpy( (uint8 *)destReq, srcReq, sizeof ( ZDEndDeviceBind_t ) );
   2168          
   2169            // Initialize the destination cluster pointers
   2170            destReq->inClusters = NULL;
   2171            destReq->outClusters = NULL;
   2172          
   2173            // Copy input cluster IDs
   2174            if ( srcReq->numInClusters )
   2175            {
   2176              destReq->inClusters = osal_mem_alloc( (short)(srcReq->numInClusters * sizeof ( uint16 )) );
   2177              if ( destReq->inClusters )
   2178              {
   2179                // Copy the clusters
   2180                osal_memcpy( (uint8*)(destReq->inClusters), (uint8 *)(srcReq->inClusters),
   2181                                (srcReq->numInClusters * sizeof ( uint16 )) );
   2182              }
   2183              else
   2184                allOK = FALSE;
   2185            }
   2186          
   2187            // Copy output cluster IDs
   2188            if ( srcReq->numOutClusters )
   2189            {
   2190              destReq->outClusters = osal_mem_alloc( (short)(srcReq->numOutClusters * sizeof ( uint16 )) );
   2191              if ( destReq->outClusters )
   2192              {
   2193                // Copy the clusters
   2194                osal_memcpy( (uint8 *)(destReq->outClusters), (uint8 *)(srcReq->outClusters),
   2195                                (srcReq->numOutClusters * sizeof ( uint16 )) );
   2196              }
   2197              else
   2198                allOK = FALSE;
   2199            }
   2200          
   2201            if ( !allOK )
   2202            {
   2203              if ( destReq->inClusters != NULL )
   2204                osal_mem_free( destReq->inClusters );
   2205              if ( destReq->outClusters != NULL )
   2206                osal_mem_free( destReq->outClusters );
   2207            }
   2208          
   2209            return ( allOK );
   2210          }
   2211          
   2212          /*********************************************************************
   2213           * @fn      ZDMatchSendState()
   2214           *
   2215           * @brief   State machine for the End device match message algorithm.
   2216           *
   2217           * @param  reason - state of algoritm
   2218           * @param  status - initial message status
   2219           * @param  TransSeq - next transaction sequence number
   2220           *
   2221           * @return  FALSE if error and we are not currently matching, TRUE
   2222           *          if success.
   2223           */
   2224          uint8 ZDMatchSendState( uint8 reason, uint8 status, uint8 TransSeq )
   2225          {
   2226            uint8 *dstIEEEAddr = NULL;
   2227            uint8 dstEP = 0xFF;
   2228            zAddrType_t dstAddr;
   2229            zAddrType_t destinationAddr;
   2230            uint16 msgType;
   2231            uint16 clusterID = 0xFFFF;
   2232            ZDEndDeviceBind_t *ed = NULL;
   2233            uint8 rspStatus = ZDP_SUCCESS;
   2234          
   2235            if ( matchED == NULL )
   2236              return ( FALSE );
   2237          
   2238            // Check sequence number
   2239            if ( reason == ZDMATCH_REASON_BIND_RSP || reason == ZDMATCH_REASON_UNBIND_RSP )
   2240            {
   2241              if ( TransSeq != matchED->transSeq )
   2242                return( FALSE ); // ignore the message
   2243            }
   2244          
   2245            // turn off timer
   2246            APS_SetEndDeviceBindTimeout( 0, ZDO_EndDeviceBindMatchTimeoutCB );
   2247          
   2248            if ( reason == ZDMATCH_REASON_TIMEOUT )
   2249            {
   2250              rspStatus = ZDP_TIMEOUT;    // The process will stop
   2251            }
   2252          
   2253            if ( reason == ZDMATCH_REASON_START || reason == ZDMATCH_REASON_BIND_RSP )
   2254            {
   2255              matchED->sending = ZDMATCH_SENDING_UNBIND;
   2256          
   2257              if ( reason == ZDMATCH_REASON_BIND_RSP && status != ZDP_SUCCESS )
   2258              {
   2259                rspStatus = status;
   2260              }
   2261            }
   2262            else if ( reason == ZDMATCH_REASON_UNBIND_RSP )
   2263            {
   2264              if ( status == ZDP_SUCCESS )
   2265              {
   2266                matchED->sending = ZDMATCH_SENDING_UNBIND;
   2267              }
   2268              else
   2269              {
   2270                matchED->sending = ZDMATCH_SENDING_BIND;
   2271              }
   2272            }
   2273          
   2274            if ( reason != ZDMATCH_REASON_START && matchED->sending == ZDMATCH_SENDING_UNBIND )
   2275            {
   2276              // Move to the next cluster ID
   2277              if ( matchED->ed1numMatched )
   2278                matchED->ed1numMatched--;
   2279              else if ( matchED->ed2numMatched )
   2280                matchED->ed2numMatched--;
   2281            }
   2282          
   2283            // What message do we send now
   2284            if ( matchED->ed1numMatched )
   2285            {
   2286              ed = &(matchED->ed1);
   2287              clusterID = matchED->ed1Matched[matchED->ed1numMatched-1];
   2288              dstIEEEAddr = matchED->ed2.ieeeAddr;
   2289              dstEP = matchED->ed2.endpoint;
   2290            }
   2291            else if ( matchED->ed2numMatched )
   2292            {
   2293              ed = &(matchED->ed2);
   2294              clusterID = matchED->ed2Matched[matchED->ed2numMatched-1];
   2295              dstIEEEAddr = matchED->ed1.ieeeAddr;
   2296              dstEP = matchED->ed1.endpoint;
   2297            }
   2298          
   2299            dstAddr.addrMode = Addr16Bit;
   2300          
   2301            // Send the next message
   2302            if ( rspStatus == ZDP_SUCCESS && ed )
   2303            {
   2304              // Send unbind/bind message to source
   2305              if ( matchED->sending == ZDMATCH_SENDING_UNBIND )
   2306                msgType = Unbind_req;
   2307              else
   2308                msgType = Bind_req;
   2309          
   2310              dstAddr.addr.shortAddr = ed->srcAddr;
   2311          
   2312              // Save off the transaction sequence number
   2313              matchED->transSeq = ZDP_TransID;
   2314          
   2315              destinationAddr.addrMode = Addr64Bit;
   2316              osal_cpyExtAddr( destinationAddr.addr.extAddr, dstIEEEAddr );
   2317          
   2318              ZDP_BindUnbindReq( msgType, &dstAddr, ed->ieeeAddr, ed->endpoint, clusterID,
   2319                  &destinationAddr, dstEP, ed->SecurityUse );
   2320          
   2321              // Set timeout for response
   2322              APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceBindMatchTimeoutCB );
   2323            }
   2324            else
   2325            {
   2326              // Send the response messages to requesting devices
   2327              // send response to first requester
   2328              dstAddr.addr.shortAddr = matchED->ed1.srcAddr;
   2329              ZDP_EndDeviceBindRsp( matchED->ed1.TransSeq, &dstAddr, rspStatus, matchED->ed1.SecurityUse );
   2330          
   2331              // send response to second requester
   2332              if ( matchED->state == ZDMATCH_SENDING_BINDS )
   2333              {
   2334                dstAddr.addr.shortAddr = matchED->ed2.srcAddr;
   2335                ZDP_EndDeviceBindRsp( matchED->ed2.TransSeq, &dstAddr, rspStatus, matchED->ed2.SecurityUse );
   2336              }
   2337          
   2338              // Process ended - release memory used
   2339              ZDO_RemoveMatchMemory();
   2340            }
   2341          
   2342            return ( TRUE );
   2343          }
   2344          
   2345          /*********************************************************************
   2346           * @fn      ZDO_EndDeviceBindMatchTimeoutCB()
   2347           *
   2348           * @brief   End device bind timeout.
   2349           *
   2350           * @param  none
   2351           *
   2352           * @return  none
   2353           */
   2354          static void ZDO_EndDeviceBindMatchTimeoutCB( void )
   2355          {
   2356            ZDMatchSendState( ZDMATCH_REASON_TIMEOUT, ZDP_TIMEOUT, 0 );
   2357          }
   2358          
   2359          /*********************************************************************
   2360           * ZDO MESSAGE PARSING API FUNCTIONS
   2361           */
   2362          
   2363          /*********************************************************************
   2364           * @fn          ZDO_ParseEndDeviceBindReq
   2365           *
   2366           * @brief       This function parses the End_Device_Bind_req message.
   2367           *
   2368           *     NOTE:  The clusters lists in bindReq are allocated in this
   2369           *            function and must be freed by that calling function.
   2370           *
   2371           * @param       inMsg  - incoming message (request)
   2372           * @param       bindReq - pointer to place to parse message to
   2373           *
   2374           * @return      none
   2375           */
   2376          void ZDO_ParseEndDeviceBindReq( zdoIncomingMsg_t *inMsg, ZDEndDeviceBind_t *bindReq )
   2377          {
   2378            uint8 *msg;
   2379          
   2380            // Parse the message
   2381            bindReq->TransSeq = inMsg->TransSeq;
   2382            bindReq->srcAddr = inMsg->srcAddr.addr.shortAddr;
   2383            bindReq->SecurityUse = inMsg->SecurityUse;
   2384            msg = inMsg->asdu;
   2385          
   2386            bindReq->localCoordinator = BUILD_UINT16( msg[0], msg[1] );
   2387            msg += 2;
   2388          
   2389            osal_cpyExtAddr( bindReq->ieeeAddr, msg );
   2390            msg += Z_EXTADDR_LEN;
   2391          
   2392            bindReq->endpoint = *msg++;
   2393            bindReq->profileID = BUILD_UINT16( msg[0], msg[1] );
   2394            msg += 2;
   2395          
   2396            bindReq->inClusters = NULL;
   2397            bindReq->outClusters = NULL;
   2398          
   2399            if ((bindReq->numInClusters = *msg++) &&
   2400                (bindReq->inClusters = (uint16*)osal_mem_alloc( (bindReq->numInClusters * sizeof( uint16 )))))
   2401            {
   2402              msg = ZDO_ConvertOTAClusters( bindReq->numInClusters, msg, bindReq->inClusters );
   2403            }
   2404            else
   2405            {
   2406              bindReq->numInClusters = 0;
   2407            }
   2408          
   2409            if ((bindReq->numOutClusters = *msg++) &&
   2410                (bindReq->outClusters = (uint16*)osal_mem_alloc((bindReq->numOutClusters * sizeof(uint16)))))
   2411            {
   2412              msg = ZDO_ConvertOTAClusters( bindReq->numOutClusters, msg, bindReq->outClusters );
   2413            }
   2414            else
   2415            {
   2416              bindReq->numOutClusters = 0;
   2417            }
   2418          }
   2419          
   2420          /*********************************************************************
   2421           * @fn          ZDO_ParseBindUnbindReq
   2422           *
   2423           * @brief       This function parses the Bind_req or Unbind_req message.
   2424           *
   2425           * @param       inMsg  - incoming message (request)
   2426           * @param       pReq - place to put parsed information
   2427           *
   2428           * @return      none
   2429           */
   2430          void ZDO_ParseBindUnbindReq( zdoIncomingMsg_t *inMsg, ZDO_BindUnbindReq_t *pReq )
   2431          {
   2432            uint8 *msg;
   2433          
   2434            msg = inMsg->asdu;
   2435            osal_cpyExtAddr( pReq->srcAddress, msg );
   2436            msg += Z_EXTADDR_LEN;
   2437            pReq->srcEndpoint = *msg++;
   2438            pReq->clusterID = BUILD_UINT16( msg[0], msg[1] );
   2439            msg += 2;
   2440            pReq->dstAddress.addrMode = *msg++;
   2441            if ( pReq->dstAddress.addrMode == Addr64Bit )
   2442            {
   2443              osal_cpyExtAddr( pReq->dstAddress.addr.extAddr, msg );
   2444              msg += Z_EXTADDR_LEN;
   2445              pReq->dstEndpoint = *msg;
   2446            }
   2447            else
   2448            {
   2449              // copy group address
   2450              pReq->dstAddress.addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   2451            }
   2452          }
   2453          
   2454          /*********************************************************************
   2455           * @fn      ZDO_ParseAddrRsp
   2456           *
   2457           * @brief   Turns the inMsg (incoming message) into the out parsed
   2458           *          structure.
   2459           *
   2460           * @param   inMsg - incoming message
   2461           *
   2462           * @return  pointer to parsed structures.  This structure was
   2463           *          allocated using osal_mem_alloc, so it must be freed
   2464           *          by the calling function [osal_mem_free()].
   2465           */
   2466          ZDO_NwkIEEEAddrResp_t *ZDO_ParseAddrRsp( zdoIncomingMsg_t *inMsg )
   2467          {
   2468            ZDO_NwkIEEEAddrResp_t *rsp;
   2469            uint8 *msg;
   2470            byte cnt = 0;
   2471          
   2472            // Calculate the number of items in the list
   2473            if ( inMsg->asduLen > (1 + Z_EXTADDR_LEN + 2) )
   2474              cnt = inMsg->asdu[1 + Z_EXTADDR_LEN + 2];
   2475            else
   2476              cnt = 0;
   2477          
   2478            // Make buffer
   2479            rsp = (ZDO_NwkIEEEAddrResp_t *)osal_mem_alloc( sizeof(ZDO_NwkIEEEAddrResp_t) + (cnt * sizeof ( uint16 )) );
   2480          
   2481            if ( rsp )
   2482            {
   2483              msg = inMsg->asdu;
   2484          
   2485              rsp->status = *msg++;
   2486              if ( rsp->status == ZDO_SUCCESS )
   2487              {
   2488                osal_cpyExtAddr( rsp->extAddr, msg );
   2489                msg += Z_EXTADDR_LEN;
   2490                rsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2491          
   2492                msg += 2;
   2493                rsp->numAssocDevs = 0;
   2494          
   2495                // StartIndex field is only present if NumAssocDev field is non-zero.
   2496                if ( cnt > 0 )
   2497                {
   2498                  uint16 *pList = &(rsp->devList[0]);
   2499                  byte n = cnt;
   2500          
   2501                  rsp->numAssocDevs = *msg++;
   2502                  rsp->startIndex = *msg++;
   2503          
   2504                  while ( n != 0 )
   2505                  {
   2506                    *pList++ = BUILD_UINT16( msg[0], msg[1] );
   2507                    msg += sizeof( uint16 );
   2508                    n--;
   2509                  }
   2510                }
   2511              }
   2512            }
   2513            return ( rsp );
   2514          }
   2515          
   2516          /*********************************************************************
   2517           * @fn          ZDO_ParseNodeDescRsp
   2518           *
   2519           * @brief       This function parses the Node_Desc_rsp message.
   2520           *
   2521           * @param       inMsg - incoming message
   2522           * @param       pNDRsp - place to parse the message into
   2523           *
   2524           * @return      none
   2525           */
   2526          void ZDO_ParseNodeDescRsp( zdoIncomingMsg_t *inMsg, ZDO_NodeDescRsp_t *pNDRsp )
   2527          {
   2528            uint8 *msg;
   2529          
   2530            msg = inMsg->asdu;
   2531          
   2532            pNDRsp->status = *msg++;
   2533            pNDRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2534          
   2535            if ( pNDRsp->status == ZDP_SUCCESS )
   2536            {
   2537              msg += 2;
   2538              pNDRsp->nodeDesc.LogicalType = *msg & 0x07;
   2539          
   2540              pNDRsp->nodeDesc.ComplexDescAvail = ( *msg & 0x08 ) >> 3;
   2541              pNDRsp->nodeDesc.UserDescAvail = ( *msg & 0x10 ) >> 4;
   2542          
   2543              msg++;  // Reserved bits.
   2544              pNDRsp->nodeDesc.FrequencyBand = (*msg >> 3) & 0x1f;
   2545              pNDRsp->nodeDesc.APSFlags = *msg++ & 0x07;
   2546              pNDRsp->nodeDesc.CapabilityFlags = *msg++;
   2547              pNDRsp->nodeDesc.ManufacturerCode[0] = *msg++;
   2548              pNDRsp->nodeDesc.ManufacturerCode[1] = *msg++;
   2549              pNDRsp->nodeDesc.MaxBufferSize = *msg++;
   2550              pNDRsp->nodeDesc.MaxInTransferSize[0] = *msg++;
   2551              pNDRsp->nodeDesc.MaxInTransferSize[1] = *msg++;
   2552              pNDRsp->nodeDesc.ServerMask = BUILD_UINT16( msg[0], msg[1] );
   2553              msg += 2;
   2554              pNDRsp->nodeDesc.MaxOutTransferSize[0] = *msg++;
   2555              pNDRsp->nodeDesc.MaxOutTransferSize[1] = *msg++;
   2556              pNDRsp->nodeDesc.DescriptorCapability = *msg;
   2557            }
   2558          }
   2559          
   2560          /*********************************************************************
   2561           * @fn          ZDO_ParesPowerDescRsp
   2562           *
   2563           * @brief       This function parses the Power_Desc_rsp message.
   2564           *
   2565           * @param       inMsg  - incoming message
   2566           * @param       pNPRsp - place to parse the message into
   2567           *
   2568           * @return      none
   2569           */
   2570          void ZDO_ParsePowerDescRsp( zdoIncomingMsg_t *inMsg, ZDO_PowerRsp_t *pNPRsp )
   2571          {
   2572            uint8 *msg;
   2573          
   2574            msg = inMsg->asdu;
   2575            pNPRsp->status = *msg++;
   2576            pNPRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2577          
   2578            if ( pNPRsp->status == ZDP_SUCCESS )
   2579            {
   2580              msg += 2;
   2581              pNPRsp->pwrDesc.AvailablePowerSources = *msg >> 4;
   2582              pNPRsp->pwrDesc.PowerMode = *msg++ & 0x0F;
   2583              pNPRsp->pwrDesc.CurrentPowerSourceLevel = *msg >> 4;
   2584              pNPRsp->pwrDesc.CurrentPowerSource = *msg++ & 0x0F;
   2585            }
   2586          }
   2587          
   2588          /*********************************************************************
   2589           * @fn          ZDO_ParseSimpleDescRsp
   2590           *
   2591           * @brief       This function parse the Simple_Desc_rsp message.
   2592           *
   2593           *   NOTE: The pAppInClusterList and pAppOutClusterList fields
   2594           *         in the SimpleDescriptionFormat_t structure are allocated
   2595           *         and the calling function needs to free [osal_msg_free()]
   2596           *         these buffers.
   2597           *
   2598           * @param       inMsg  - incoming message
   2599           * @param       pSimpleDescRsp - place to parse the message into
   2600           *
   2601           * @return      none
   2602           */
   2603          void ZDO_ParseSimpleDescRsp( zdoIncomingMsg_t *inMsg, ZDO_SimpleDescRsp_t *pSimpleDescRsp )
   2604          {
   2605            uint8 *msg;
   2606          
   2607            msg = inMsg->asdu;
   2608            pSimpleDescRsp->status = *msg++;
   2609            pSimpleDescRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2610            msg += sizeof ( uint16 );
   2611            msg++; // Skip past the length field.
   2612          
   2613            if ( pSimpleDescRsp->status == ZDP_SUCCESS )
   2614            {
   2615              ZDO_ParseSimpleDescBuf( msg, &(pSimpleDescRsp->simpleDesc) );
   2616            }
   2617          }
   2618          
   2619          /*********************************************************************
   2620           * @fn          ZDO_ParseEPListRsp
   2621           *
   2622           * @brief       This parse the Active_EP_rsp or Match_Desc_rsp message.
   2623           *
   2624           * @param       inMsg  - incoming message
   2625           *
   2626           * @return      none
   2627           */
   2628          ZDO_ActiveEndpointRsp_t *ZDO_ParseEPListRsp( zdoIncomingMsg_t *inMsg )
   2629          {
   2630            ZDO_ActiveEndpointRsp_t *pRsp;
   2631            uint8 *msg;
   2632            uint8 Status;
   2633            uint8 cnt;
   2634          
   2635            msg = inMsg->asdu;
   2636            Status = *msg++;
   2637            cnt = msg[2];
   2638          
   2639            pRsp = (ZDO_ActiveEndpointRsp_t *)osal_mem_alloc( sizeof(  ZDO_ActiveEndpointRsp_t ) + cnt );
   2640            if ( pRsp )
   2641            {
   2642              pRsp->status = Status;
   2643              pRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2644              msg += sizeof( uint16 );
   2645              pRsp->cnt = cnt;
   2646              msg++; // pass cnt
   2647              osal_memcpy( pRsp->epList, msg, cnt );
   2648            }
   2649          
   2650            return ( pRsp );
   2651          }
   2652          
   2653          /*********************************************************************
   2654           * @fn          ZDO_ParseServerDiscRsp
   2655           *
   2656           * @brief       Parse the Server_Discovery_rsp message.
   2657           *
   2658           * @param       inMsg - incoming message.
   2659           * @param       pRsp - place to put the parsed information.
   2660           *
   2661           * @return      none
   2662           */
   2663          void ZDO_ParseServerDiscRsp( zdoIncomingMsg_t *inMsg, ZDO_ServerDiscRsp_t *pRsp )
   2664          {
   2665            pRsp->status = inMsg->asdu[0];
   2666            pRsp->serverMask = BUILD_UINT16( inMsg->asdu[1], inMsg->asdu[2] );
   2667          }
   2668          
   2669          /*********************************************************************
   2670           * @fn          ZDO_ParseMgmtLqiRsp
   2671           *
   2672           * @brief       This function parses the incoming Management
   2673           *              LQI response
   2674           *
   2675           * @param       inMsg - incoming message
   2676           *
   2677           * @return      a pointer to parsed response structure (NULL if not allocated).
   2678           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2679           *          by the calling function [osal_mem_free()].
   2680           */
   2681          ZDO_MgmtLqiRsp_t *ZDO_ParseMgmtLqiRsp( zdoIncomingMsg_t *inMsg )
   2682          {
   2683            ZDO_MgmtLqiRsp_t *pRsp;
   2684            uint8 status;
   2685            uint8 startIndex = 0;
   2686            uint8 neighborLqiCount = 0;
   2687            uint8 neighborLqiEntries = 0;
   2688            uint8 *msg;
   2689          
   2690            msg = inMsg->asdu;
   2691          
   2692            status = *msg++;
   2693            if ( status == ZSuccess )
   2694            {
   2695              neighborLqiEntries = *msg++;
   2696              startIndex = *msg++;
   2697              neighborLqiCount = *msg++;
   2698            }
   2699          
   2700            // Allocate a buffer big enough to handle the list.
   2701            pRsp = (ZDO_MgmtLqiRsp_t *)osal_mem_alloc(
   2702                      sizeof( ZDO_MgmtLqiRsp_t ) + (neighborLqiCount * sizeof( neighborLqiItem_t )) );
   2703            if ( pRsp )
   2704            {
   2705              uint8 x;
   2706              neighborLqiItem_t *pList = pRsp->list;
   2707              pRsp->status = status;
   2708              pRsp->neighborLqiEntries = neighborLqiEntries;
   2709              pRsp->startIndex = startIndex;
   2710              pRsp->neighborLqiCount = neighborLqiCount;
   2711          
   2712              for ( x = 0; x < neighborLqiCount; x++ )
   2713              {
   2714                osal_cpyExtAddr(pList->extPANId, msg);   //Copy extended PAN ID
   2715                msg += Z_EXTADDR_LEN;
   2716          
   2717                msg += Z_EXTADDR_LEN;  // Throwing away IEEE.
   2718                pList->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2719                msg += 2 + 1 + 1 + 1;      // Skip DeviceType, RxOnIdle, Rlationship, PermitJoining and Depth
   2720                pList->rxLqi = *msg++;
   2721                pList->txQuality = 0;  // This is not specified OTA by ZigBee 1.1.
   2722                pList++;
   2723              }
   2724            }
   2725          
   2726            return ( pRsp );
   2727          }
   2728          
   2729          /*********************************************************************
   2730           * @fn          ZDO_ParseMgmNwkDiscRsp
   2731           *
   2732           * @brief       This function parses the incoming Management
   2733           *              Network Discover response.
   2734           *
   2735           * @param       inMsg - incoming message
   2736           *
   2737           * @return      pointer to parsed response.  This structure was
   2738           *          allocated using osal_mem_alloc, so it must be freed
   2739           *          by the calling function [osal_mem_free()].
   2740           */
   2741          ZDO_MgmNwkDiscRsp_t *ZDO_ParseMgmNwkDiscRsp( zdoIncomingMsg_t *inMsg )
   2742          {
   2743            ZDO_MgmNwkDiscRsp_t *pRsp;
   2744            uint8 status;
   2745            uint8 networkCount = 0;
   2746            uint8 startIndex = 0;
   2747            uint8 networkListCount = 0;
   2748            uint8 *msg;
   2749          
   2750            msg = inMsg->asdu;
   2751            status = *msg++;
   2752          
   2753            if ( status == ZSuccess )
   2754            {
   2755              networkCount = *msg++;
   2756              startIndex = *msg++;
   2757              networkListCount = *msg++;
   2758            }
   2759          
   2760            // Allocate a buffer big enough to handle the list.
   2761            pRsp = (ZDO_MgmNwkDiscRsp_t *)osal_mem_alloc( sizeof( ZDO_MgmNwkDiscRsp_t )
   2762                                            + (networkListCount * sizeof( mgmtNwkDiscItem_t )) );
   2763            if ( pRsp )
   2764            {
   2765              uint8 x;
   2766              mgmtNwkDiscItem_t *pList;
   2767          
   2768              pRsp->status = status;
   2769              pRsp->networkCount = networkCount;
   2770              pRsp->startIndex = startIndex;
   2771              pRsp->networkListCount = networkListCount;
   2772              pList = pRsp->list;
   2773          
   2774              for ( x = 0; x < networkListCount; x++ )
   2775              {
   2776                osal_cpyExtAddr(pList->extendedPANID, msg);   //Copy extended PAN ID
   2777                pList->PANId = BUILD_UINT16( msg[0], msg[1] );
   2778                msg += Z_EXTADDR_LEN;
   2779          
   2780                pList->logicalChannel = *msg++;
   2781                pList->stackProfile = (*msg) & 0x0F;
   2782                pList->version = (*msg++ >> 4) & 0x0F;
   2783                pList->beaconOrder = (*msg) & 0x0F;
   2784                pList->superFrameOrder = (*msg++ >> 4) & 0x0F;
   2785                pList->permitJoining = *msg++;
   2786                pList++;
   2787              }
   2788            }
   2789          
   2790            return ( pRsp );
   2791          }
   2792          
   2793          /*********************************************************************
   2794           * @fn          ZDO_ParseMgmtRtgRsp
   2795           *
   2796           * @brief       This function parses the incoming Management
   2797           *              Routing response.
   2798           *
   2799           * @param       inMsg - incoming message
   2800           *
   2801           * @return      a pointer to parsed response structure (NULL if not allocated).
   2802           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2803           *          by the calling function [osal_mem_free()].
   2804           */
   2805          ZDO_MgmtRtgRsp_t *ZDO_ParseMgmtRtgRsp( zdoIncomingMsg_t *inMsg )
   2806          {
   2807            ZDO_MgmtRtgRsp_t *pRsp;
   2808            uint8 status;
   2809            uint8 rtgCount = 0;
   2810            uint8 startIndex = 0;
   2811            uint8 rtgListCount = 0;
   2812            uint8 *msg;
   2813          
   2814            msg = inMsg->asdu;
   2815          
   2816            status = *msg++;
   2817            if ( status == ZSuccess )
   2818            {
   2819              rtgCount = *msg++;
   2820              startIndex = *msg++;
   2821              rtgListCount = *msg++;
   2822            }
   2823          
   2824            // Allocate a buffer big enough to handle the list
   2825            pRsp = (ZDO_MgmtRtgRsp_t *)osal_mem_alloc(
   2826                    sizeof( ZDO_MgmtRtgRsp_t ) + (rtgListCount * sizeof( rtgItem_t )) );
   2827            if ( pRsp )
   2828            {
   2829              uint8 x;
   2830              rtgItem_t *pList = pRsp->list;
   2831              pRsp->status = status;
   2832              pRsp->rtgCount = rtgCount;
   2833              pRsp->startIndex = startIndex;
   2834              pRsp->rtgListCount = rtgListCount;
   2835          
   2836              for ( x = 0; x < rtgListCount; x++ )
   2837              {
   2838                pList->dstAddress = BUILD_UINT16( msg[0], msg[1] );
   2839                msg += 2;
   2840                pList->status = *msg++;
   2841                pList->nextHopAddress = BUILD_UINT16( msg[0], msg[1] );
   2842                msg += 2;
   2843                pList++;
   2844              }
   2845            }
   2846          
   2847            return ( pRsp );
   2848          }
   2849          
   2850          /*********************************************************************
   2851           * @fn          ZDO_ParseMgmtBindRsp
   2852           *
   2853           * @brief       This function parses the incoming Management
   2854           *              Binding response.
   2855           *
   2856           * @param       inMsg - pointer to message to parse
   2857           *
   2858           * @return      a pointer to parsed response structure (NULL if not allocated).
   2859           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2860           *          by the calling function [osal_mem_free()].
   2861           */
   2862          ZDO_MgmtBindRsp_t *ZDO_ParseMgmtBindRsp( zdoIncomingMsg_t *inMsg )
   2863          {
   2864            ZDO_MgmtBindRsp_t *pRsp;
   2865            uint8 status;
   2866            uint8 bindingCount = 0;
   2867            uint8 startIndex = 0;
   2868            uint8 bindingListCount = 0;
   2869            uint8 *msg;
   2870          
   2871            msg = inMsg->asdu;
   2872          
   2873            status = *msg++;
   2874            if ( status == ZSuccess )
   2875            {
   2876              bindingCount = *msg++;
   2877              startIndex = *msg++;
   2878              bindingListCount = *msg++;
   2879            }
   2880          
   2881            // Allocate a buffer big enough to handle the list
   2882            pRsp = (ZDO_MgmtBindRsp_t *)osal_mem_alloc(
   2883                    (sizeof ( ZDO_MgmtBindRsp_t ) + (bindingListCount * sizeof( apsBindingItem_t ))) );
   2884            if ( pRsp )
   2885            {
   2886              uint8 x;
   2887              apsBindingItem_t *pList = pRsp->list;
   2888              pRsp->status = status;
   2889              pRsp->bindingCount = bindingCount;
   2890              pRsp->startIndex = startIndex;
   2891              pRsp->bindingListCount = bindingListCount;
   2892          
   2893              for ( x = 0; x < bindingListCount; x++ )
   2894              {
   2895                osal_cpyExtAddr( pList->srcAddr, msg );
   2896                msg += Z_EXTADDR_LEN;
   2897                pList->srcEP = *msg++;
   2898          
   2899                // Get the Cluster ID
   2900          
   2901                pList->clusterID = BUILD_UINT16( msg[0], msg[1] );
   2902                msg += 2;
   2903                pList->dstAddr.addrMode = *msg++;
   2904                if ( pList->dstAddr.addrMode == Addr64Bit )
   2905                {
   2906                  osal_cpyExtAddr( pList->dstAddr.addr.extAddr, msg );
   2907                  msg += Z_EXTADDR_LEN;
   2908                  pList->dstEP = *msg++;
   2909                }
   2910                else
   2911                {
   2912                  pList->dstAddr.addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   2913                  msg += 2;
   2914                }
   2915          
   2916                pList++;
   2917              }
   2918            }
   2919          
   2920            return ( pRsp );
   2921          }
   2922          
   2923          /*********************************************************************
   2924           * @fn          ZDO_ParseUserDescRsp
   2925           *
   2926           * @brief       This function parses the incoming User
   2927           *              Descriptor Response.
   2928           *
   2929           * @param       inMsg - incoming response message
   2930           *
   2931           * @return      a pointer to parsed response structure (NULL if not allocated).
   2932           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2933           *          by the calling function [osal_mem_free()].
   2934           */
   2935          ZDO_UserDescRsp_t *ZDO_ParseUserDescRsp( zdoIncomingMsg_t *inMsg )
   2936          {
   2937            ZDO_UserDescRsp_t *pRsp;
   2938            uint8 *msg;
   2939            uint8 descLen = 0;
   2940          
   2941            msg = inMsg->asdu;
   2942          
   2943            if ( msg[0] == ZSuccess )
   2944              descLen = msg[3];
   2945          
   2946            pRsp = (ZDO_UserDescRsp_t *)osal_mem_alloc( sizeof ( ZDO_UserDescRsp_t ) + descLen );
   2947            if ( pRsp )
   2948            {
   2949              pRsp->status = msg[0];
   2950              pRsp->nwkAddr = BUILD_UINT16( msg[1], msg[2] );
   2951              pRsp->length = descLen;
   2952              if ( descLen )
   2953                osal_memcpy( pRsp->desc, &msg[4], descLen );
   2954            }
   2955          
   2956            return ( pRsp );
   2957          }
   2958          
   2959          /*********************************************************************
   2960           * @fn          ZDO_ParseSimpleDescBuf
   2961           *
   2962           * @brief       Parse a byte sequence representation of a Simple Descriptor.
   2963           *
   2964           * @param       buf  - pointer to a byte array representing a Simple Desc.
   2965           * @param       desc - SimpleDescriptionFormat_t *
   2966           *
   2967           *              This routine allocates storage for the cluster IDs because
   2968           *              they are 16-bit and need to be aligned to be properly processed.
   2969           *              This routine returns non-zero if an allocation fails.
   2970           *
   2971           *              NOTE: This means that the caller or user of the input structure
   2972           *                    is responsible for freeing the memory
   2973           *
   2974           * @return      0: success
   2975           *              1: failure due to malloc failure.
   2976           */
   2977          uint8 ZDO_ParseSimpleDescBuf( uint8 *buf, SimpleDescriptionFormat_t *desc )
   2978          {
   2979            uint8 num, i;
   2980          
   2981            desc->EndPoint = *buf++;
   2982            desc->AppProfId = BUILD_UINT16( buf[0], buf[1] );
   2983            buf += 2;
   2984            desc->AppDeviceId = BUILD_UINT16( buf[0], buf[1] );
   2985            buf += 2;
   2986            desc->AppDevVer = *buf >> 4;
   2987          
   2988            desc->Reserved = 0;
   2989            buf++;
   2990          
   2991            // move in input cluster list (if any). allocate aligned memory.
   2992            num = desc->AppNumInClusters = *buf++;
   2993            if ( num )
   2994            {
   2995              if (!(desc->pAppInClusterList = (uint16 *)osal_mem_alloc(num*sizeof(uint16))))
   2996              {
   2997                // malloc failed. we're done.
   2998                return 1;
   2999              }
   3000              for (i=0; i<num; ++i)
   3001              {
   3002                desc->pAppInClusterList[i] = BUILD_UINT16( buf[0], buf[1] );
   3003                buf += 2;
   3004              }
   3005            }
   3006          
   3007            // move in output cluster list (if any). allocate aligned memory.
   3008            num = desc->AppNumOutClusters = *buf++;
   3009            if (num)
   3010            {
   3011              if (!(desc->pAppOutClusterList = (uint16 *)osal_mem_alloc(num*sizeof(uint16))))
   3012              {
   3013                // malloc failed. free input cluster list memory if there is any
   3014                if ( desc->pAppInClusterList != NULL )
   3015                {
   3016                  osal_mem_free(desc->pAppInClusterList);
   3017                  
   3018                  desc->pAppInClusterList = NULL;
   3019                }
   3020                return 1;
   3021              }
   3022              for (i=0; i<num; ++i)
   3023              {
   3024                desc->pAppOutClusterList[i] = BUILD_UINT16( buf[0], buf[1] );
   3025                buf += 2;
   3026              }
   3027            }
   3028            return 0;
   3029          }
   3030          
   3031          /*********************************************************************
   3032           * @fn          ZDO_ParseDeviceAnnce
   3033           *
   3034           * @brief       Parse a Device Announce message.
   3035           *
   3036           * @param       inMsg - Incoming message
   3037           * @param       pAnnce - place to put the parsed information
   3038           *
   3039           * @return      none
   3040           */
   3041          void ZDO_ParseDeviceAnnce( zdoIncomingMsg_t *inMsg, ZDO_DeviceAnnce_t *pAnnce )
   3042          {
   3043            uint8 *msg;
   3044          
   3045            // Parse incoming message
   3046            msg = inMsg->asdu;
   3047            pAnnce->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   3048            msg += 2;
   3049            osal_cpyExtAddr( pAnnce->extAddr, msg );
   3050            msg += Z_EXTADDR_LEN;
   3051            pAnnce->capabilities = *msg;
   3052          }
   3053          
   3054          /*********************************************************************
   3055           * @fn          ZDO_ParseMgmtNwkUpdateNotify
   3056           *
   3057           * @brief       This function handles parsing of the incoming Management
   3058           *              Network Update notify.
   3059           *
   3060           * @param       inMsg - incoming message (request)
   3061           *
   3062           * @return      a pointer to parsed response structure (NULL if not allocated).
   3063           *          This structure was allocated using osal_mem_alloc, so it must be freed
   3064           *          by the calling function [osal_mem_free()].
   3065           */
   3066          ZDO_MgmtNwkUpdateNotify_t *ZDO_ParseMgmtNwkUpdateNotify( zdoIncomingMsg_t *inMsg )
   3067          {
   3068            uint8 status;
   3069            uint32 scannedChannels = 0;
   3070            uint16 totalTransmissions = 0;
   3071            uint16 transmissionFailures = 0;
   3072            uint8 listCount = 0;
   3073            uint8 *msg = inMsg->asdu;
   3074            ZDO_MgmtNwkUpdateNotify_t *pRsp;
   3075          
   3076            status = *msg++;
   3077            if ( status == ZSuccess )
   3078            {
   3079              scannedChannels = osal_build_uint32( msg, 4 );
   3080              msg += 4;
   3081              totalTransmissions = BUILD_UINT16( msg[0], msg[1] );
   3082              msg += 2;
   3083              transmissionFailures = BUILD_UINT16( msg[0], msg[1] );
   3084              msg += 2;
   3085              listCount = *msg++;
   3086            }
   3087          
   3088            pRsp = (ZDO_MgmtNwkUpdateNotify_t *)osal_mem_alloc( sizeof ( ZDO_MgmtNwkUpdateNotify_t ) + listCount );
   3089          
   3090            if ( pRsp )
   3091            {
   3092              pRsp->status = status;
   3093              pRsp->scannedChannels = scannedChannels;
   3094              pRsp->totalTransmissions = totalTransmissions;
   3095              pRsp->transmissionFailures = transmissionFailures;
   3096              pRsp->listCount = listCount;
   3097          
   3098              // Allocate a buffer big enough to handle the list.
   3099              if ( listCount > 0 )
   3100                osal_memcpy( pRsp->energyValues, msg, listCount );
   3101            }
   3102          
   3103            return ( pRsp );
   3104          }
   3105          
   3106          /*********************************************************************
   3107           * @fn          ZDO_ParseMgmtNwkUpdateReq
   3108           *
   3109           * @brief       This function handles parsing the incoming Management
   3110           *              Network Update request and starts the request (if needed).
   3111           *
   3112           * @param       inMsg - incoming message (request)
   3113           * @param       pReq - pointer to place to parse message to
   3114           *
   3115           * @return      none
   3116           */
   3117          void ZDO_ParseMgmtNwkUpdateReq( zdoIncomingMsg_t *inMsg, ZDO_MgmtNwkUpdateReq_t *pReq )
   3118          {
   3119            uint8 *msg = inMsg->asdu;
   3120          
   3121            pReq->channelMask = osal_build_uint32( msg, 4 );
   3122            msg += 4;
   3123            pReq->scanDuration = *msg++;
   3124          
   3125            if ( pReq->scanDuration <= 0x05 )
   3126            {
   3127              // Request is to scan over channelMask
   3128              pReq->scanCount = *msg;
   3129            }
   3130            else if ( ( pReq->scanDuration == 0xFE ) || ( pReq->scanDuration == 0xFF ) )
   3131            {
   3132              // Request is to change Channel (0xFE) or apsChannelMask and NwkManagerAddr (0xFF)
   3133              pReq->nwkUpdateId = *msg++;
   3134          
   3135              if ( pReq->scanDuration == 0xFF )
   3136              {
   3137                pReq->nwkManagerAddr = BUILD_UINT16( msg[0], msg[1] );
   3138              }
   3139            }
   3140          }
   3141          
   3142          /*********************************************************************
   3143          *********************************************************************/
   3144          
   3145          

Errors: 1
Warnings: none
