###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                08/Jun/2011  10:49:35 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Component #
#                          s\stack\af\AF.c                                    #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proje #
#                          cts\zstack\Samples\SampleApp\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wCoord.cfg" (-DCPU32MHZ              #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proje #
#                          cts\zstack\Samples\SampleApp\CC2530DB\..\..\..\Too #
#                          ls\CC2530DB\f8wConfig.cfg" (-DSECURE=0             #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.3.1\Components\stack\a #
#                          f\AF.c" -D BUILD_ALL_DEVICES -D HOLD_AUTO_START    #
#                          -D LCD_SUPPORTED -D HAL_UART=FALSE -lC "C:\Texas   #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\DemoEB\List\" -lA         #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\DemoEB\List\"   #
#                          --diag_suppress Pe001,Pa010 -o "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\DemoEB\Obj\" -e           #
#                          --require_prototypes --debug --core=plain          #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\" -I "C:\Texas            #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\SOURCE\" -I "C:\Texas  #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\ZMAIN\TI2530DB\" #
#                           -I "C:\Texas Instruments\ZStack-CC2530-2.3.1\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\COMPONENTS\MT\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \HAL\INCLUDE\" -I "C:\Texas                        #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \HAL\TARGET\CC2530EB\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \OSAL\MCU\CCSOC\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \OSAL\INCLUDE\" -I "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\AF\" -I "C:\Texas                           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\NWK\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SEC\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SAPI\" -I "C:\Texas                         #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\SYS\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \STACK\ZDO\" -I "C:\Texas                          #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \ZMAC\F8W\" -I "C:\Texas                           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \ZMAC\" -I "C:\Texas Instruments\ZStack-CC2530-2.3 #
#                          .1\Projects\zstack\Samples\SampleApp\CC2530DB\..\. #
#                          .\..\..\..\COMPONENTS\SERVICES\SADDR\" -I          #
#                          "C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects #
#                          \zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\SERVICES\SDATA\" -I "C:\Texas           #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\INCLUDE\" -I "C:\Texas                        #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\HIGH_LEVEL\" -I "C:\Texas                     #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\LOW_LEVEL\srf04\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.3.1\Projects\zstack\Sa #
#                          mples\SampleApp\CC2530DB\..\..\..\..\..\COMPONENTS #
#                          \MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I "C:\Program  #
#                          Files\IAR Systems\Embedded Workbench               #
#                          5.3\8051\INC\" -I "C:\Program Files\IAR            #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\DemoEB\List\AF.l #
#                          st                                                 #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.3.1\Projects\ #
#                          zstack\Samples\SampleApp\CC2530DB\DemoEB\Obj\AF.r5 #
#                          1                                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.3.1\Components\stack\af\AF.c
      1          /**************************************************************************************************
      2            Filename:       AF.c
      3            Revised:        $Date: 2010-08-09 12:12:10 -0700 (Mon, 09 Aug 2010) $
      4            Revision:       $Revision: 23350 $
      5          
      6            Description:    Application Framework - Device Description helper functions
      7          
      8          
      9            Copyright 2004-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "OSAL.h"
     45          #include "AF.h"
     46          #include "nwk_globals.h"
     47          #include "nwk_util.h"
     48          #include "aps_groups.h"
     49          #include "ZDProfile.h"
     50          #include "aps_frag.h"
     51          #include "rtg.h"
     52          
     53          #if defined ( MT_AF_CB_FUNC )
     54            #include "MT_AF.h"
     55          #endif
     56          
     57          #if defined ( INTER_PAN )
     58            #include "stub_aps.h"
     59          #endif
     60          
     61          /*********************************************************************
     62           * MACROS
     63           */
     64          
     65          /*********************************************************************
     66           * @fn      afSend
     67           *
     68           * @brief   Helper macro for V1 API to invoke V2 API.
     69           *
     70           * input parameters
     71           *
     72           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
     73           * @param   srcEP - Origination (i.e. respond to or ack to) End Point.
     74           * @param   cID - A valid cluster ID as specified by the Profile.
     75           * @param   len - Number of bytes of data pointed to by next param.
     76           * @param  *buf - A pointer to the data bytes to send.
     77           * @param   options - Valid bit mask of AF Tx Options as defined in AF.h.
     78           * @param  *transID - A pointer to a byte which can be modified and which will
     79           *                    be used as the transaction sequence number of the msg.
     80           *
     81           * output parameters
     82           *
     83           * @param  *transID - Incremented by one if the return value is success.
     84           *
     85           * @return  afStatus_t - See previous definition of afStatus_... types.
     86           */
     87          #define afSend( dstAddr, srcEP, cID, len, buf, transID, options, radius ) \
     88                  AF_DataRequest( (dstAddr), afFindEndPointDesc( (srcEP) ), \
     89                                    (cID), (len), (buf), (transID), (options), (radius) )
     90          
     91          /*********************************************************************
     92           * CONSTANTS
     93           */
     94          
     95          /*********************************************************************
     96           * TYPEDEFS
     97           */
     98          
     99          /*********************************************************************
    100           * GLOBAL VARIABLES
    101           */
    102          
    103          epList_t *epList;
    104          
    105          /*********************************************************************
    106           * EXTERNAL VARIABLES
    107           */
    108          
    109          /*********************************************************************
    110           * EXTERNAL FUNCTIONS
    111           */
    112          
    113          /*********************************************************************
    114           * LOCAL VARIABLES
    115           */
    116          
    117          /*********************************************************************
    118           * LOCAL FUNCTIONS
    119           */
    120          
    121          static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
    122                          zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
    123                          byte SecurityUse, uint32 timestamp );
    124          
    125          static epList_t *afFindEndPointDescList( byte EndPoint );
    126          
    127          static pDescCB afGetDescCB( endPointDesc_t *epDesc );
    128          
    129          /*********************************************************************
    130           * NETWORK LAYER CALLBACKS
    131           */
    132          
    133          /*********************************************************************
    134           * PUBLIC FUNCTIONS
    135           */
    136          
    137          /*********************************************************************
    138           * @fn      afInit
    139           *
    140           * @brief   Initialization function for the AF.
    141           *
    142           * @param   none
    143           *
    144           * @return  none
    145           */
    146          void afInit( void )
    147          {
    148            // Start with no endpoint defined
    149            epList = NULL;
    150          }
    151          
    152          /*********************************************************************
    153           * @fn      afRegisterExtended
    154           *
    155           * @brief   Register an Application's EndPoint description.
    156           *
    157           * @param   epDesc - pointer to the Application's endpoint descriptor.
    158           * @param   descFn - pointer to descriptor callback function
    159           *
    160           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    161           *
    162           * @return  Pointer to epList_t on success, NULL otherwise.
    163           */
    164          epList_t *afRegisterExtended( endPointDesc_t *epDesc, pDescCB descFn )
    165          {
    166            epList_t *ep;
    167            epList_t *epSearch;
    168          
    169            ep = osal_mem_alloc( sizeof ( epList_t ) );
    170            if ( ep )
    171            {
    172              // Fill in the new list entry
    173              ep->epDesc = epDesc;
    174          
    175              // Default to allow Match Descriptor.
    176              ep->flags = eEP_AllowMatch;
    177              ep->pfnDescCB = descFn;
    178              ep->nextDesc = NULL;
    179          
    180              // Does a list exist?
    181              if ( epList == NULL )
    182                epList = ep;  // Make this the first entry
    183              else
    184              {
    185                // Look for the end of the list
    186                epSearch = epList;
    187                while( epSearch->nextDesc != NULL )
    188                  epSearch = epSearch->nextDesc;
    189          
    190                // Add new entry to end of list
    191                epSearch->nextDesc = ep;
    192              }
    193            }
    194          
    195            return ep;
    196          }
    197          
    198          /*********************************************************************
    199           * @fn      afRegister
    200           *
    201           * @brief   Register an Application's EndPoint description.
    202           *
    203           * @param   epDesc - pointer to the Application's endpoint descriptor.
    204           *
    205           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    206           *
    207           * @return  afStatus_SUCCESS - Registered
    208           *          afStatus_MEM_FAIL - not enough memory to add descriptor
    209           *          afStatus_INVALID_PARAMETER - duplicate endpoint
    210           */
    211          afStatus_t afRegister( endPointDesc_t *epDesc )
    212          {
    213            epList_t *ep;
    214            
    215            // Look for duplicate endpoint
    216            if ( afFindEndPointDescList( epDesc->endPoint ) )
    217              return ( afStatus_INVALID_PARAMETER );
    218            
    219            ep = afRegisterExtended( epDesc, NULL );
    220          
    221            return ((ep == NULL) ? afStatus_MEM_FAIL : afStatus_SUCCESS);
    222          }
    223          
    224          
    225          /*********************************************************************
    226           * @fn          afDataConfirm
    227           *
    228           * @brief       This function will generate the Data Confirm back to
    229           *              the application.
    230           *
    231           * @param       endPoint - confirm end point
    232           * @param       transID - transaction ID from APSDE_DATA_REQUEST
    233           * @param       status - status of APSDE_DATA_REQUEST
    234           *
    235           * @return      none
    236           */
    237          void afDataConfirm( uint8 endPoint, uint8 transID, ZStatus_t status )
    238          {
    239            endPointDesc_t *epDesc;
    240            afDataConfirm_t *msgPtr;
    241          
    242            // Find the endpoint description
    243            epDesc = afFindEndPointDesc( endPoint );
    244            if ( epDesc == NULL )
    245              return;
    246          
    247            // Determine the incoming command type
    248            msgPtr = (afDataConfirm_t *)osal_msg_allocate( sizeof(afDataConfirm_t) );
    249            if ( msgPtr )
    250            {
    251              // Build the Data Confirm message
    252              msgPtr->hdr.event = AF_DATA_CONFIRM_CMD;
    253              msgPtr->hdr.status = status;
    254              msgPtr->endpoint = endPoint;
    255              msgPtr->transID = transID;
    256          
    257          #if defined ( MT_AF_CB_FUNC )
    258              /* If MT has subscribed for this callback, don't send as a message. */
    259              if ( AFCB_CHECK(CB_ID_AF_DATA_CNF,*(epDesc->task_id)) )
    260              {
    261                /* Send callback if it's subscribed */
    262                MT_AfDataConfirm ((void *)msgPtr);
    263                /* Release the memory. */
    264                osal_msg_deallocate( (void *)msgPtr );
    265              }
    266              else
    267          #endif
    268              {
    269                /* send message through task message */
    270                osal_msg_send( *(epDesc->task_id), (byte *)msgPtr );
    271              }
    272            }
    273          }
    274          
    275          /*********************************************************************
    276           * @fn          afIncomingData
    277           *
    278           * @brief       Transfer a data PDU (ASDU) from the APS sub-layer to the AF.
    279           *
    280           * @param       aff  - pointer to APS frame format
    281           * @param       SrcAddress  - Source address
    282           * @param       sig - incoming message's link quality
    283           * @param       SecurityUse - Security enable/disable
    284           *
    285           * @return      none
    286           */
    287          void afIncomingData( aps_FrameFormat_t *aff, zAddrType_t *SrcAddress, uint16 SrcPanId,
    288                               NLDE_Signal_t *sig, byte SecurityUse, uint32 timestamp )
    289          {
    290            endPointDesc_t *epDesc = NULL;
    291            epList_t *pList = epList;
    292          #if !defined ( APS_NO_GROUPS )    
    293            uint8 grpEp = APS_GROUPS_EP_NOT_FOUND;
    294          #endif  
    295          
    296            if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
    297            {
    298          #if !defined ( APS_NO_GROUPS )    
    299              // Find the first endpoint for this group
    300              grpEp = aps_FindGroupForEndpoint( aff->GroupID, APS_GROUPS_FIND_FIRST );
    301              if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
    302                return;   // No endpoint found
    303          
    304              epDesc = afFindEndPointDesc( grpEp );
    305              if ( epDesc == NULL )
    306                return;   // Endpoint descriptor not found
    307          
    308              pList = afFindEndPointDescList( epDesc->endPoint );
    309          #else
    310              return; // Not supported
    311          #endif    
    312            }
    313            else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
    314            {
    315              // Set the list
    316              if ( pList != NULL )
    317              {
    318                epDesc = pList->epDesc;
    319              }
    320            }
    321            else if ( (epDesc = afFindEndPointDesc( aff->DstEndPoint )) )
    322            {
    323              pList = afFindEndPointDescList( epDesc->endPoint );
    324            }
    325          
    326            while ( epDesc )
    327            {
    328              uint16 epProfileID = 0xFFFF;  // Invalid Profile ID
    329              
    330              if ( pList->pfnDescCB )
    331              {
    332                uint16 *pID = (uint16 *)(pList->pfnDescCB(
    333                                           AF_DESCRIPTOR_PROFILE_ID, epDesc->endPoint ));
    334                if ( pID )
    335                {
    336                  epProfileID = *pID;
    337                  osal_mem_free( pID );
    338                }
    339              }
    340              else if ( epDesc->simpleDesc )
    341              {
    342                epProfileID = epDesc->simpleDesc->AppProfId;
    343              }
    344          
    345              if ( (aff->ProfileID == epProfileID) ||
    346                   ((epDesc->endPoint == ZDO_EP) && (aff->ProfileID == ZDO_PROFILE_ID)) )
    347              {
    348                {
    349                  // Save original endpoint
    350                  uint8 endpoint = aff->DstEndPoint;
    351                  
    352                  // overwrite with descriptor's endpoint
    353                  aff->DstEndPoint = epDesc->endPoint;   
    354                  
    355                  afBuildMSGIncoming( aff, epDesc, SrcAddress, SrcPanId, sig, SecurityUse, timestamp );
    356                  
    357                  // Restore with original endpoint
    358                  aff->DstEndPoint = endpoint;
    359                }
    360              }
    361          
    362              if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
    363              {
    364          #if !defined ( APS_NO_GROUPS )      
    365                // Find the next endpoint for this group
    366                grpEp = aps_FindGroupForEndpoint( aff->GroupID, grpEp );
    367                if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
    368                  return;   // No endpoint found
    369          
    370                epDesc = afFindEndPointDesc( grpEp );
    371                if ( epDesc == NULL )
    372                  return;   // Endpoint descriptor not found
    373          
    374                pList = afFindEndPointDescList( epDesc->endPoint );
    375          #else
    376                return;
    377          #endif      
    378              }
    379              else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
    380              {
    381                pList = pList->nextDesc;
    382                if ( pList )
    383                  epDesc = pList->epDesc;
    384                else
    385                  epDesc = NULL;
    386              }
    387              else
    388                epDesc = NULL;
    389            }
    390          }
    391          
    392          /*********************************************************************
    393           * @fn          afBuildMSGIncoming
    394           *
    395           * @brief       Build the message for the app
    396           *
    397           * @param
    398           *
    399           * @return      pointer to next in data buffer
    400           */
    401          static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
    402                           zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig, 
    403                           byte SecurityUse, uint32 timestamp )
    404          {
    405            afIncomingMSGPacket_t *MSGpkt;
    406            const byte len = sizeof( afIncomingMSGPacket_t ) + aff->asduLength;
    407            byte *asdu = aff->asdu;
    408            MSGpkt = (afIncomingMSGPacket_t *)osal_msg_allocate( len );
    409          
    410            if ( MSGpkt == NULL )
    411            {
    412              return;
    413            }
    414          
    415            MSGpkt->hdr.event = AF_INCOMING_MSG_CMD;
    416            MSGpkt->groupId = aff->GroupID;
    417            MSGpkt->clusterId = aff->ClusterID;
    418            afCopyAddress( &MSGpkt->srcAddr, SrcAddress );
    419            MSGpkt->srcAddr.endPoint = aff->SrcEndPoint;
    420            MSGpkt->endPoint = epDesc->endPoint;
    421            MSGpkt->wasBroadcast = aff->wasBroadcast;
    422            MSGpkt->LinkQuality = sig->LinkQuality;
    423            MSGpkt->correlation = sig->correlation;
    424            MSGpkt->rssi = sig->rssi;
    425            MSGpkt->SecurityUse = SecurityUse;
    426            MSGpkt->timestamp = timestamp;
    427            MSGpkt->macDestAddr = aff->macDestAddr;
    428            MSGpkt->srcAddr.panId = SrcPanId;
    429            MSGpkt->cmd.TransSeqNumber = 0;
    430            MSGpkt->cmd.DataLength = aff->asduLength;
    431          
    432            if ( MSGpkt->cmd.DataLength )
    433            {
    434              MSGpkt->cmd.Data = (byte *)(MSGpkt + 1);
    435              osal_memcpy( MSGpkt->cmd.Data, asdu, MSGpkt->cmd.DataLength );
    436            }
    437            else
    438            {
    439              MSGpkt->cmd.Data = NULL;
    440            }
    441          
    442          #if defined ( MT_AF_CB_FUNC )
    443            // If ZDO or SAPI have registered for this endpoint, dont intercept it here
    444            if (AFCB_CHECK(CB_ID_AF_DATA_IND, *(epDesc->task_id)))
    445            {
    446              MT_AfIncomingMsg( (void *)MSGpkt );
    447              // Release the memory.
    448              osal_msg_deallocate( (void *)MSGpkt );
    449            }
    450            else
    451          #endif
    452            {
    453              // Send message through task message.
    454              osal_msg_send( *(epDesc->task_id), (uint8 *)MSGpkt );
    455            }
    456          }
    457          
    458          /*********************************************************************
    459           * @fn      AF_DataRequest
    460           *
    461           * @brief   Common functionality for invoking APSDE_DataReq() for both
    462           *          SendMulti and MSG-Send.
    463           *
    464           * input parameters
    465           *
    466           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
    467           * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
    468           * @param   cID - A valid cluster ID as specified by the Profile.
    469           * @param   len - Number of bytes of data pointed to by next param.
    470           * @param  *buf - A pointer to the data bytes to send.
    471           * @param  *transID - A pointer to a byte which can be modified and which will
    472           *                    be used as the transaction sequence number of the msg.
    473           * @param   options - Valid bit mask of Tx options.
    474           * @param   radius - Normally set to AF_DEFAULT_RADIUS.
    475           *
    476           * output parameters
    477           *
    478           * @param  *transID - Incremented by one if the return value is success.
    479           *
    480           * @return  afStatus_t - See previous definition of afStatus_... types.
    481           */
    482          uint8 AF_DataRequestDiscoverRoute = TRUE;
    483          afStatus_t AF_DataRequest( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
    484                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
    485                                     uint8 options, uint8 radius )
    486          {
    487            pDescCB pfnDescCB;
    488            ZStatus_t stat;
    489            APSDE_DataReq_t req;
    490            afDataReqMTU_t mtu;
    491          
    492            // Verify source end point
    493            if ( srcEP == NULL )
    494            {
    495              return afStatus_INVALID_PARAMETER;
    496            }
    497          
    498          #if !defined( REFLECTOR )
    499            if ( dstAddr->addrMode == afAddrNotPresent )
    500            {
    501              return afStatus_INVALID_PARAMETER;
    502            }
    503          #endif
    504            
    505            // Check if route is available before sending data 
    506            if ( options & AF_LIMIT_CONCENTRATOR  )
    507            {
    508              if ( dstAddr->addrMode != afAddr16Bit )
    509              {
    510                return ( afStatus_INVALID_PARAMETER );
    511              }
    512               
    513              // First, make sure the destination is not its self, then check for an existing route.
    514              if ( (dstAddr->addr.shortAddr != NLME_GetShortAddr())
    515                  && (RTG_CheckRtStatus( dstAddr->addr.shortAddr, RT_ACTIVE, (MTO_ROUTE | NO_ROUTE_CACHE) ) != RTG_SUCCESS) )
    516              {
    517                // A valid route to a concentrator wasn't found
    518                return ( afStatus_NO_ROUTE );
    519              }
    520            } 
    521            
    522            // Validate broadcasting
    523            if ( ( dstAddr->addrMode == afAddr16Bit     ) ||
    524                 ( dstAddr->addrMode == afAddrBroadcast )    )
    525            {
    526              // Check for valid broadcast values
    527              if( ADDR_NOT_BCAST != NLME_IsAddressBroadcast( dstAddr->addr.shortAddr )  )
    528              {
    529                // Force mode to broadcast
    530                dstAddr->addrMode = afAddrBroadcast;
    531              }
    532              else
    533              {
    534                // Address is not a valid broadcast type
    535                if ( dstAddr->addrMode == afAddrBroadcast )
    536                {
    537                  return afStatus_INVALID_PARAMETER;
    538                }
    539              }
    540            }
    541            else if ( dstAddr->addrMode != afAddr64Bit &&
    542                      dstAddr->addrMode != afAddrGroup &&
    543                      dstAddr->addrMode != afAddrNotPresent )
    544            {
    545              return afStatus_INVALID_PARAMETER;
    546            }
    547            
    548            // Set destination address
    549            req.dstAddr.addrMode = dstAddr->addrMode;
    550            if ( dstAddr->addrMode == afAddr64Bit )
    551              osal_cpyExtAddr( req.dstAddr.addr.extAddr, dstAddr->addr.extAddr );
    552            else
    553              req.dstAddr.addr.shortAddr = dstAddr->addr.shortAddr;
    554            
    555            req.profileID = ZDO_PROFILE_ID;
    556          
    557            if ( (pfnDescCB = afGetDescCB( srcEP )) )
    558            {
    559              uint16 *pID = (uint16 *)(pfnDescCB(
    560                                           AF_DESCRIPTOR_PROFILE_ID, srcEP->endPoint ));
    561              if ( pID )
    562              {
    563                req.profileID = *pID;
    564                osal_mem_free( pID );
    565              }
    566            }
    567            else if ( srcEP->simpleDesc )
    568            {
    569              req.profileID = srcEP->simpleDesc->AppProfId;
    570            }
    571          
    572            req.txOptions = 0;
    573          
    574            if ( ( options & AF_ACK_REQUEST              ) &&
    575                 ( req.dstAddr.addrMode != AddrBroadcast ) &&
    576                 ( req.dstAddr.addrMode != AddrGroup     )    )
    577            {
    578              req.txOptions |=  APS_TX_OPTIONS_ACK;
    579            }
    580          
    581            if ( options & AF_SKIP_ROUTING )
    582            {
    583              req.txOptions |=  APS_TX_OPTIONS_SKIP_ROUTING;
    584            }
    585          
    586            if ( options & AF_EN_SECURITY )
    587            {
    588              req.txOptions |= APS_TX_OPTIONS_SECURITY_ENABLE;
    589              mtu.aps.secure = TRUE;
    590            }
    591            else
    592            {
    593              mtu.aps.secure = FALSE;
    594            }
    595          
    596            mtu.kvp = FALSE;
    597          
    598            req.transID       = *transID;
    599            req.srcEP         = srcEP->endPoint;
    600            req.dstEP         = dstAddr->endPoint;
    601            req.clusterID     = cID;
    602            req.asduLen       = len;
    603            req.asdu          = buf;
    604            req.discoverRoute = AF_DataRequestDiscoverRoute;//(uint8)((options & AF_DISCV_ROUTE) ? 1 : 0);
    605            req.radiusCounter = radius;
    606          #if defined ( INTER_PAN )
    607            req.dstPanId      = dstAddr->panId;
    608          
    609            if ( StubAPS_InterPan( dstAddr->panId, dstAddr->endPoint ) )
    610            {
    611              if ( len > INTERP_DataReqMTU() )
    612              {
    613                stat = afStatus_INVALID_PARAMETER;
    614              }
    615              else
    616              {
    617                stat = INTERP_DataReq( &req );
    618              }
    619            }
    620            else
    621          #endif // INTER_PAN
    622            {
    623              if (len > afDataReqMTU( &mtu ) )
    624              {
    625                if (apsfSendFragmented)
    626                {
    627                  stat = (*apsfSendFragmented)( &req );
    628                }
    629                else
    630                {
    631                  stat = afStatus_INVALID_PARAMETER;
    632                }
    633              }
    634              else
    635              {
    636                stat = APSDE_DataReq( &req );
    637              }
    638            }
    639          
    640            /*
    641             * If this is an EndPoint-to-EndPoint message on the same device, it will not
    642             * get added to the NWK databufs. So it will not go OTA and it will not get
    643             * a MACCB_DATA_CONFIRM_CMD callback. Thus it is necessary to generate the
    644             * AF_DATA_CONFIRM_CMD here. Note that APSDE_DataConfirm() only generates one
    645             * message with the first in line TransSeqNumber, even on a multi message.
    646             * Also note that a reflected msg will not have its confirmation generated
    647             * here.
    648             */
    649            if ( (req.dstAddr.addrMode == Addr16Bit) &&
    650                 (req.dstAddr.addr.shortAddr == NLME_GetShortAddr()) )
    651            {
    652              afDataConfirm( srcEP->endPoint, *transID, stat );
    653            }
    654          
    655            if ( stat == afStatus_SUCCESS )
    656            {
    657              (*transID)++;
    658            }
    659          
    660            return (afStatus_t)stat;
    661          }
    662          
    663          #if defined ( ZIGBEE_SOURCE_ROUTING )
    664          /*********************************************************************
    665           * @fn      AF_DataRequestSrcRtg
    666           *
    667           * @brief   Common functionality for invoking APSDE_DataReq() for both
    668           *          SendMulti and MSG-Send.
    669           *
    670           * input parameters
    671           *
    672           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
    673           * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
    674           * @param   cID - A valid cluster ID as specified by the Profile.
    675           * @param   len - Number of bytes of data pointed to by next param.
    676           * @param  *buf - A pointer to the data bytes to send.
    677           * @param  *transID - A pointer to a byte which can be modified and which will
    678           *                    be used as the transaction sequence number of the msg.
    679           * @param   options - Valid bit mask of Tx options.
    680           * @param   radius - Normally set to AF_DEFAULT_RADIUS.
    681           * @param   relayCnt - Number of devices in the relay list
    682           * @param   pRelayList - Pointer to the relay list
    683           *
    684           * output parameters
    685           *
    686           * @param  *transID - Incremented by one if the return value is success.
    687           *
    688           * @return  afStatus_t - See previous definition of afStatus_... types.
    689           */
    690          
    691          afStatus_t AF_DataRequestSrcRtg( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
    692                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
    693                                     uint8 options, uint8 radius, uint8 relayCnt, uint16* pRelayList )
    694          {
    695            uint8 status;
    696            
    697            /* Add the source route to the source routing table */
    698            status = RTG_AddSrcRtgEntry_Guaranteed( dstAddr->addr.shortAddr, relayCnt, 
    699                                                   pRelayList );
    700          
    701            if( status == RTG_SUCCESS)
    702            {
    703              /* Call AF_DataRequest to send the data */
    704              status = AF_DataRequest( dstAddr, srcEP, cID, len, buf, transID, options, radius );
    705            }
    706            else if( status == RTG_INVALID_PATH )
    707            {
    708              /* The source route relay count is exceeding the network limit */
    709              status = afStatus_INVALID_PARAMETER;
    710            }
    711            else
    712            {
    713              /* The guaranteed adding entry fails due to memory failure */
    714              status = afStatus_MEM_FAIL;
    715            }
    716            return status;
    717          }
    718          
    719          #endif
    720          
    721          /*********************************************************************
    722           * @fn      afFindEndPointDescList
    723           *
    724           * @brief   Find the endpoint description entry from the endpoint
    725           *          number.
    726           *
    727           * @param   EndPoint - Application Endpoint to look for
    728           *
    729           * @return  the address to the endpoint/interface description entry
    730           */
    731          static epList_t *afFindEndPointDescList( byte EndPoint )
    732          {
    733            epList_t *epSearch;
    734          
    735            // Start at the beginning
    736            epSearch = epList;
    737          
    738            // Look through the list until the end
    739            while ( epSearch )
    740            {
    741              // Is there a match?
    742              if ( epSearch->epDesc->endPoint == EndPoint )
    743              {
    744                return ( epSearch );
    745              }
    746              else
    747                epSearch = epSearch->nextDesc;  // Next entry
    748            }
    749          
    750            return ( (epList_t *)NULL );
    751          }
    752          
    753          /*********************************************************************
    754           * @fn      afFindEndPointDesc
    755           *
    756           * @brief   Find the endpoint description entry from the endpoint
    757           *          number.
    758           *
    759           * @param   EndPoint - Application Endpoint to look for
    760           *
    761           * @return  the address to the endpoint/interface description entry
    762           */
    763          endPointDesc_t *afFindEndPointDesc( byte EndPoint )
    764          {
    765            epList_t *epSearch;
    766          
    767            // Look for the endpoint
    768            epSearch = afFindEndPointDescList( EndPoint );
    769          
    770            if ( epSearch )
    771              return ( epSearch->epDesc );
    772            else
    773              return ( (endPointDesc_t *)NULL );
    774          }
    775          
    776          /*********************************************************************
    777           * @fn      afFindSimpleDesc
    778           *
    779           * @brief   Find the Simple Descriptor from the endpoint number.
    780           *
    781           * @param   EP - Application Endpoint to look for.
    782           *
    783           * @return  Non-zero to indicate that the descriptor memory must be freed.
    784           */
    785          byte afFindSimpleDesc( SimpleDescriptionFormat_t **ppDesc, byte EP )
    786          {
    787            epList_t *epItem = afFindEndPointDescList( EP );
    788            byte rtrn = FALSE;
    789          
    790            if ( epItem )
    791            {
    792              if ( epItem->pfnDescCB )
    793              {
    794                *ppDesc = epItem->pfnDescCB( AF_DESCRIPTOR_SIMPLE, EP );
    795                rtrn = TRUE;
    796              }
    797              else
    798              {
    799                *ppDesc = epItem->epDesc->simpleDesc;
    800              }
    801            }
    802            else
    803            {
    804              *ppDesc = NULL;
    805            }
    806          
    807            return rtrn;
    808          }
    809          
    810          /*********************************************************************
    811           * @fn      afGetDescCB
    812           *
    813           * @brief   Get the Descriptor callback function.
    814           *
    815           * @param   epDesc - pointer to the endpoint descriptor
    816           *
    817           * @return  function pointer or NULL
    818           */
    819          static pDescCB afGetDescCB( endPointDesc_t *epDesc )
    820          {
    821            epList_t *epSearch;
    822          
    823            // Start at the beginning
    824            epSearch = epList;
    825          
    826            // Look through the list until the end
    827            while ( epSearch )
    828            {
    829              // Is there a match?
    830              if ( epSearch->epDesc == epDesc )
    831              {
    832                return ( epSearch->pfnDescCB );
    833              }
    834              else
    835                epSearch = epSearch->nextDesc;  // Next entry
    836            }
    837          
    838            return ( (pDescCB)NULL );
    839          }
    840          
    841          /*********************************************************************
    842           * @fn      afDataReqMTU
    843           *
    844           * @brief   Get the Data Request MTU(Max Transport Unit).
    845           *
    846           * @param   fields - afDataReqMTU_t
    847           *
    848           * @return  uint8(MTU)
    849           */
    850          uint8 afDataReqMTU( afDataReqMTU_t* fields )
    851          {
    852            uint8 len;
    853            uint8 hdr;
    854          
    855            if ( fields->kvp == TRUE )
    856            {
    857              hdr = AF_HDR_KVP_MAX_LEN;
    858            }
    859            else
    860            {
    861              hdr = AF_HDR_V1_1_MAX_LEN;
    862            }
    863          
    864            len = (uint8)(APSDE_DataReqMTU(&fields->aps) - hdr);
    865          
    866            return len;
    867          }
    868          
    869          /*********************************************************************
    870           * @fn      afGetMatch
    871           *
    872           * @brief   Set the allow response flag.
    873           *
    874           * @param   ep - Application Endpoint to look for
    875           * @param   action - true - allow response, false - no response
    876           *
    877           * @return  TRUE allow responses, FALSE no response
    878           */
    879          uint8 afGetMatch( uint8 ep )
    880          {
    881            epList_t *epSearch;
    882          
    883            // Look for the endpoint
    884            epSearch = afFindEndPointDescList( ep );
    885          
    886            if ( epSearch )
    887            {
    888              if ( epSearch->flags & eEP_AllowMatch )
    889                return ( TRUE );
    890              else
    891                return ( FALSE );
    892            }
    893            else
    894              return ( FALSE );
    895          }
    896          
    897          /*********************************************************************
    898           * @fn      afSetMatch
    899           *
    900           * @brief   Set the allow response flag.
    901           *
    902           * @param   ep - Application Endpoint to look for
    903           * @param   action - true - allow response, false - no response
    904           *
    905           * @return  TRUE if success, FALSE if endpoint not found
    906           */
    907          uint8 afSetMatch( uint8 ep, uint8 action )
    908          {
    909            epList_t *epSearch;
    910          
    911            // Look for the endpoint
    912            epSearch = afFindEndPointDescList( ep );
    913          
    914            if ( epSearch )
    915            {
    916              if ( action )
    917              {
    918                epSearch->flags |= eEP_AllowMatch;
    919              }
    920              else
    921              {
    922                epSearch->flags &= (eEP_AllowMatch ^ 0xFFFF);
    923              }
    924              return ( TRUE );
    925            }
    926            else
    927              return ( FALSE );
    928          }
    929          
    930          /*********************************************************************
    931           * @fn      afNumEndPoints
    932           *
    933           * @brief   Returns the number of endpoints defined (including 0)
    934           *
    935           * @param   none
    936           *
    937           * @return  number of endpoints
    938           */
    939          byte afNumEndPoints( void )
    940          {
    941            epList_t *epSearch;
    942            byte endpoints;
    943          
    944            // Start at the beginning
    945            epSearch = epList;
    946            endpoints = 0;
    947          
    948            while ( epSearch )
    949            {
    950              endpoints++;
    951              epSearch = epSearch->nextDesc;
    952            }
    953          
    954            return ( endpoints );
    955          }
    956          
    957          /*********************************************************************
    958           * @fn      afEndPoints
    959           *
    960           * @brief   Fills in the passed in buffer with the endpoint (numbers).
    961           *          Use afNumEndPoints to find out how big a buffer to supply.
    962           *
    963           * @param   epBuf - pointer to mem used
    964           *
    965           * @return  void
    966           */
    967          void afEndPoints( byte *epBuf, byte skipZDO )
    968          {
    969            epList_t *epSearch;
    970            byte endPoint;
    971          
    972            // Start at the beginning
    973            epSearch = epList;
    974          
    975            while ( epSearch )
    976            {
    977              endPoint = epSearch->epDesc->endPoint;
    978          
    979              if ( !skipZDO || endPoint != 0 )
    980                *epBuf++ = endPoint;
    981          
    982              epSearch = epSearch->nextDesc;
    983            }
    984          }
    985          
    986          /*********************************************************************
    987           * @fn      afCopyAddress
    988           *
    989           * @brief   Fills in the passed in afAddrType_t parameter with the corresponding information
    990           *          from the zAddrType_t parameter. 
    991           *
    992           * @param   epBuf - pointer to mem used
    993           *
    994           * @return  void
    995           */
    996          void afCopyAddress( afAddrType_t *afAddr, zAddrType_t *zAddr )
    997          {
    998            afAddr->addrMode = (afAddrMode_t)zAddr->addrMode;
    999            if ( zAddr->addrMode == Addr64Bit )
   1000            {
   1001              (void)osal_cpyExtAddr( afAddr->addr.extAddr, zAddr->addr.extAddr );
   1002            }
   1003            else
   1004            {
   1005              afAddr->addr.shortAddr = zAddr->addr.shortAddr;
   1006            }
   1007          
   1008            // Since zAddrType_t has no INTER-PAN information, set the panId member to zero.
   1009            afAddr->panId = 0;
   1010          }
   1011          
   1012          /*********************************************************************
   1013          *********************************************************************/
   1014          

Errors: 1
Warnings: none
